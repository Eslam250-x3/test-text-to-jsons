<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÿ±ÿßŸÅÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ¨ŸÖÿπ - Bulk Question Uploader</title>
    <!-- Handsontable CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@14.3.0/dist/handsontable.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Naskh+Arabic:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --app-font: "Noto Naskh Arabic", 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* --- Basic Setup --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--app-font);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- Main Container --- */
        .container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* --- Header --- */
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .ai-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }

        /* --- Content Layout --- */
        .content {
            padding: 40px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 30px;
        }

        .panel {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e2e8f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .panel h3 {
            color: #4f46e5;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Statistics Section */
        .stats-section {
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 1px solid #e2e8f0;
        }

        .stat-label {
            font-weight: 600;
            color: #374151;
        }

        .stat-value {
            font-weight: 700;
            color: #4f46e5;
            font-size: 1.1em;
        }

        .question-types-stats {
            margin-top: 15px;
        }

        .type-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 6px;
            border-left: 3px solid #4f46e5;
        }

        .type-name {
            font-weight: 500;
            color: #475569;
        }

        .type-count {
            font-weight: 600;
            color: #4f46e5;
            background: #e0e7ff;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.9em;
        }

        .question-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .q-type-btn {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background-color: #fff;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 600;
            color: #475569;
            text-align: center;
        }

        .q-type-btn:hover {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
        }

        .q-type-btn.active {
            background-color: #e0e7ff;
            border-color: #4f46e5;
            color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .input-section textarea,
        .edit-textarea {
            width: 100%;
            min-height: 250px;
            padding: 20px;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.3s ease;
            background: white;
            font-family: "Noto Naskh Arabic", 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin-bottom: 10px;
        }

        .input-section textarea:focus,
        .edit-textarea:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .api-key-section {
            margin-top: 15px;
        }

        .api-key-section input,
        .api-key-section select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .api-key-section input:focus,
        .api-key-section select:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .controls .btn {
            flex-grow: 1;
        }

        .btn {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover:before {
            left: 100%;
        }

        .btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(79, 70, 229, 0.3);
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #d1d5db;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .btn-ai {
            background: linear-gradient(135deg, #ec4899 0%, #d946ef 100%);
            color: white;
        }

        .btn-ai:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(236, 72, 153, 0.3);
        }

        .json-output {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 12px;
            font-family: var(--app-font);
            font-size: 13px;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #334155;
            flex-grow: 1;
            margin-top: 15px;
        }

        .json-output .key {
            color: #60a5fa;
        }

        .json-output .string {
            color: #34d399;
        }

        .json-output .number {
            color: #fbbf24;
        }

        .json-output .boolean {
            color: #f87171;
        }

        .json-output .null {
            color: #a78bfa;
        }

        .analysis-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .analysis-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.9em;
        }

        .analysis-item:last-child {
            border-bottom: none;
        }

        .confidence-bar {
            width: 100px;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981);
            border-radius: 4px;
            transition: width 0.5s ease-in-out;
        }

        #questionsPreview {
            flex-grow: 1;
            overflow-y: auto;
            max-height: 70vh;
        }

        /* --- Poem Styling --- */
        .PoemContainer {
            margin: 12px 0;
        }

        .Poem {
            font-size: 1.25em;
            line-height: 2;
            font-family: "Noto Naskh Arabic", serif;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }

        .Poem.vertical-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 2rem;
            row-gap: .25em;
            grid-auto-flow: row dense;
            direction: rtl;
            text-align: center;
            align-items: start;
            justify-items: stretch;
            align-content: start;
            justify-content: center;
        }

        .Poem.vertical-split p {
            margin: 0.25em 0;
            white-space: pre-wrap;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            word-spacing: normal;
            letter-spacing: normal;
        }

        /* Correct order: First line (odd) in first column, second line (even) in second column */
        .Poem.vertical-split p:nth-child(odd) {
            grid-column: 1 / 2;
            justify-self: start;
            text-align: left;
        }

        .Poem.vertical-split p:nth-child(even) {
            grid-column: 2 / 3;
            justify-self: end;
            text-align: right;
        }

        @media (max-width: 768px) {
            .Poem.vertical-split {
                grid-template-columns: 1fr;
            }

            .Poem.vertical-split p {
                grid-column: 1 !important;
                text-align: right !important;
            }
        }

        .question-preview ul,
        .question-preview ol {
            margin: 8px 0;
            padding-inline-start: 20px;
            list-style-position: inside;
        }

        .question-preview {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 15px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            animation: fadeIn 0.5s ease;
            position: relative;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question-actions {
            position: absolute;
            top: 10px;
            left: 10px;
            display: none;
            gap: 8px;
            z-index: 10;
        }

        .question-preview:hover .question-actions {
            display: flex;
        }

        .action-btn {
            background: rgba(249, 250, 251, 0.8);
            border: 1px solid #d1d5db;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(2px);
        }

        .action-btn:hover {
            background: #4f46e5;
            border-color: #4f46e5;
            color: white;
            transform: scale(1.1);
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #e5e7eb;
        }

        /* Justify paragraph content */
        .LexicalTheme__paragraph {
            text-align: justify;
            text-justify: inter-word;
        }

        .validation-warning {
            position: absolute;
            top: 15px;
            left: 50px;
            font-size: 1.2em;
            cursor: help;
        }

        .question-preview h4,
        .question-preview .statement-preview {
            color: #374151;
            margin-bottom: 10px;
            font-size: 1.1em;
            line-height: 1.5;
        }

        .part-preview {
            border-top: 2px dashed #a5b4fc;
            margin-top: 15px;
            padding-top: 15px;
        }

        .part-preview h5 {
            color: #4338ca;
            font-size: 1em;
            margin-bottom: 8px;
        }

        .question-type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .type-mcq {
            background: #dbeafe;
            color: #1e40af;
        }

        .type-mrq {
            background: #e0e7ff;
            color: #3730a3;
        }

        .type-matching {
            background: #e0e7ff;
            color: #3730a3;
        }

        .type-gapText {
            background: #d1fae5;
            color: #065f46;
        }

        .type-string {
            background: #fef3c7;
            color: #92400e;
        }

        .type-frq_ai {
            background: #fce7f3;
            color: #be185d;
        }

        .type-oq {
            background: #fef9c3;
            color: #854d0e;
        }

        .type-input_box {
            background: #f3e8ff;
            color: #6b21a8;
        }

        .type-unknown {
            background: #fee2e2;
            color: #991b1b;
        }

        .choice-item {
            padding: 8px 15px;
            margin: 5px 0;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .part-preview[data-interactive="true"] .choice-item {
            cursor: pointer;
        }

        .part-preview[data-interactive="true"] .choice-item:hover {
            background: #f3f4f6;
            border-color: #4f46e5;
        }

        .choice-item.correct {
            background: #dcfce7;
            border-color: #16a34a;
            color: #15803d;
            font-weight: bold;
        }

        .choice-item.correct::before {
            content: '‚úî ';
            color: #15803d;
        }

        .matching-preview {
            display: flex;
            gap: 20px;
        }

        .matching-column {
            flex: 1;
        }

        .matching-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .gapped-text-answers {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }

        .gapped-text-answers strong {
            color: #4f46e5;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
        }

        .stat-card h4 {
            color: #4f46e5;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .stat-card span {
            font-size: 2em;
            font-weight: bold;
            color: #1f2937;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        .btn .spinner {
            width: 20px;
            height: 20px;
            margin: 0;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        button,
        input,
        select,
        textarea {
            font-family: var(--app-font);
        }

        .message-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .message {
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.5s ease, fadeOut 0.5s ease 3.5s forwards;
            font-weight: 500;
            min-width: 300px;
            text-align: center;
            position: relative;
        }

        .message.error {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fecaca;
        }

        .message.success {
            background: #dcfce7;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .message.warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .message .close-x {
            position: absolute;
            top: 6px;
            left: 8px;
            cursor: pointer;
            font-weight: bold;
            opacity: .6;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px) translateX(-50%);
                opacity: 0;
            }

            to {
                transform: translateY(0) translateX(-50%);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
                transform: translateY(-20px) translateX(-50%);
            }
        }

        #csvModalBg,
        #aiTemplateModalBg,
        #subjectTemplateModalBg,
        #generationModalBg {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.25);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        #csvModal,
        #aiTemplateModal,
        #subjectTemplateModal {
            background: white;
            border-radius: 16px;
            max-width: 1200px;
            width: 95vw;
            padding: 32px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            position: relative;
            min-height: 600px;
            min-width: 900px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #csvModal .hot-container,
        #aiTemplateModal .hot-container {
            margin-bottom: 18px;
            width: 100%;
        }

        #csvModal .btn,
        #aiTemplateModal .btn,
        #subjectTemplateModal .btn {
            min-width: 120px;
        }

        #csvModal .csv-warning {
            color: #dc2626;
            font-weight: bold;
            margin-bottom: 10px;
        }

        /* Handsontable font */
        .handsontable,
        .handsontable table,
        .handsontable input,
        .htCore {
            font-family: var(--app-font);
        }

        math-field {
            border: 1px solid #ddd;
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 1.1em;
            display: inline-block;
            background: #f9f9f9;
            min-width: 20px;
            vertical-align: -0.25em;
        }

        math-field:focus-within {
            background-color: #eef2ff;
            box-shadow: 0 0 0 2px #4f46e5;
            outline: none;
        }

        /* --- Blank Line Styling --- */
        span[data-node-type="blank-line"] {
            border-bottom: 2px solid #374151;
            display: inline-block;
            min-width: 80px;
            height: 1.2em;
            margin: 0 4px;
            vertical-align: baseline;
            position: relative;
            top: -2px;
        }

        /* Different styles for gap (GapText) vs space (other types) */
        span[data-node-type="blank-line"][data-node-variation="gap"] {
            border-bottom-color: #4f46e5;
            border-bottom-style: dashed;
            min-width: 100px;
        }

        span[data-node-type="blank-line"][data-node-variation="space"] {
            border-bottom-color: #374151;
            border-bottom-style: solid;
            min-width: 80px;
        }

        /* --- Tags Modal --- */
        #tagsModal {
            display: none;
            position: fixed;
            top: 150px;
            left: 150px;
            width: 380px;
            max-height: 85vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 4000;
            border: 1px solid #ccc;
            flex-direction: column;
            overflow: hidden;
        }

        #tagsModal[style*="display: block"],
        #tagsModal[style*="display:flex"] {
            display: flex !important;
        }

        #tagsModalHeader {
            padding: 12px 15px;
            cursor: move;
            background: #f1f5f9;
            border-bottom: 1px solid #e2e8f0;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: #475569;
        }

        #tags-modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #64748b;
            line-height: 1;
        }

        #tagsModalBody {
            padding: 15px;
            padding-bottom: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .tags-section h4 {
            font-size: 1em;
            color: #4f46e5;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e0e7ff;
        }

        .tag-group {
            margin-bottom: 15px;
        }

        .tag-group-title {
            font-size: 0.85em;
            font-weight: bold;
            color: #6b7280;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #eee;
        }

        .tags-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 0;
        }

        .tag-btn {
            padding: 8px 12px;
            font-family: "Noto Naskh Arabic", 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tag-btn:hover {
            background: #e0e7ff;
            border-color: #4f46e5;
            color: #4f46e5;
        }

        /* --- Generation Modal --- */
        #generationModal {
            background: white;
            border-radius: 16px;
            max-width: 1200px;
            width: 95vw;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            position: relative;
            display: flex;
            flex-direction: column;
            max-height: 90vh;
        }

        .generation-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .generation-header h2 {
            color: #4f46e5;
        }

        .generation-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .generation-column h4 {
            margin-bottom: 1rem;
            color: #4338ca;
        }

        .generation-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #e5e7eb;
            text-align: left;
        }

        #gen-image-drop-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #gen-image-drop-zone.dragover {
            background: #eef2ff;
            border-color: #4f46e5;
        }

        #gen-image-preview {
            margin-top: 1rem;
            max-width: 100%;
            max-height: 150px;
            border-radius: 8px;
        }

        .gen-q-type-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .gen-q-type-row label {
            font-weight: 500;
        }

        .gen-q-type-row input {
            width: 60px;
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            text-align: center;
        }

        #gen-multi-part-types {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            margin-top: 5px;
        }


        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .content {
                grid-template-columns: 1fr;
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .header p {
                font-size: 1em;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .question-type-selector {
                grid-template-columns: 1fr 1fr;
            }

            .generation-content {
                grid-template-columns: 1fr;
            }
        }

        /* --- Rich Text Editor Polishing --- */
        .ck.ck-editor {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.04);
        }

        .ck.ck-editor__top {
            background: #f8fafc;
        }

        .ck.ck-toolbar {
            border: 2px solid #e5e7eb !important;
            border-bottom: none !important;
        }

        .ck.ck-content {
            min-height: 280px;
            border: 2px solid #e5e7eb !important;
            border-top: none !important;
            border-radius: 0 0 12px 12px;
            font-size: 14px;
            line-height: 1.7;
            padding: 16px;
            background: #fff;
            font-family: var(--app-font);
        }

        .ck-focused .ck.ck-content {
            border-color: #4f46e5 !important;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        /* English Template Selector */
        .english-template-selector {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .english-template-selector:focus {
            outline: none;
            border-color: #2563eb !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .english-template-selector:hover {
            border-color: #60a5fa;
        }

        .english-template-selector option {
            padding: 8px;
            font-size: 14px;
        }

        /* ===== Rich Text Editor Styles ===== */
        /* ÿ™ŸÜÿ≥ŸäŸÇÿßÿ™ ÿ¥ÿßŸÖŸÑÿ© ŸÑŸÑŸÖÿπÿßŸäŸÜÿ© */
        .rich-text-preview {
            font-family: 'Cairo', 'Amiri', Arial, sans-serif;
            line-height: 1.6;
        }

        .rich-text-preview h1,
        .rich-text-preview h2,
        .rich-text-preview h3,
        .rich-text-preview h4,
        .rich-text-preview h5,
        .rich-text-preview h6 {
            font-weight: bold;
            margin: 1em 0 0.5em 0;
        }

        .rich-text-preview h1 {
            font-size: 2em;
        }

        .rich-text-preview h2 {
            font-size: 1.5em;
        }

        .rich-text-preview h3 {
            font-size: 1.3em;
        }

        .rich-text-preview u {
            text-decoration: underline;
        }

        .rich-text-preview strong,
        .rich-text-preview b {
            font-weight: bold;
        }

        .rich-text-preview em,
        .rich-text-preview i {
            font-style: italic;
        }

        .rich-text-preview s,
        .rich-text-preview strike {
            text-decoration: line-through;
        }

        .rich-text-preview sub {
            vertical-align: sub;
            font-size: 0.8em;
        }

        .rich-text-preview sup {
            vertical-align: super;
            font-size: 0.8em;
        }

        .rich-text-preview blockquote {
            border-left: 4px solid #ccc;
            margin: 1em 0;
            padding-left: 1em;
            font-style: italic;
        }

        .rich-text-preview hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 2em 0;
        }

        .rich-text-preview code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .rich-text-preview pre {
            background-color: #f4f4f4;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
        }

        .rich-text-preview ul,
        .rich-text-preview ol {
            margin: 1em 0;
            padding-left: 2em;
        }

        .rich-text-preview li {
            margin: 0.5em 0;
        }

        /* ŸÖÿ≠ÿßÿ∞ÿßÿ© ÿßŸÑŸÜÿµ */
        .rich-text-preview [style*="text-align: left"] {
            text-align: left;
        }

        .rich-text-preview [style*="text-align: center"] {
            text-align: center;
        }

        .rich-text-preview [style*="text-align: right"] {
            text-align: right;
        }

        .rich-text-preview [style*="text-align: justify"] {
            text-align: justify;
        }

        /* ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÜÿµ */
        .rich-text-preview [dir="rtl"] {
            direction: rtl;
            text-align: right;
        }

        .rich-text-preview [dir="ltr"] {
            direction: ltr;
            text-align: left;
        }


        /* MathLive Integration */
        .mathlive-mathfield {
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 8px;
            background: white;
        }

        .mathlive-mathfield:focus {
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
        }
        /* Rich Text Editor Styles */
        .rich-text-editor-wrapper {
            width: 100%;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            background: white;
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .rich-text-editor-wrapper:focus-within {
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .rich-text-toolbar {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 8px 12px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .rich-text-toolbar button,
        .rich-text-toolbar select {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 36px;
            justify-content: center;
            font-family: inherit;
        }

        .rich-text-toolbar button:hover,
        .rich-text-toolbar select:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .rich-text-toolbar button.active {
            background: #4f46e5;
            color: white;
            border-color: #4f46e5;
        }

        .rich-text-toolbar select {
            padding: 6px 8px;
            min-width: 120px;
        }

        .color-picker-wrapper {
            position: relative;
            display: inline-block;
        }

        .toolbar-btn.color-trigger {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 32px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
            padding: 4px 6px;
        }

        .toolbar-btn.color-trigger:hover {
            border-color: #4f46e5;
            box-shadow: 0 2px 6px rgba(79, 70, 229, 0.15);
        }

        .color-dropdown {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 12px;
            min-width: 200px;
        }

        .color-section {
            margin-bottom: 8px;
        }

        .color-section-title {
            font-size: 11px;
            color: #6b7280;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
        }

        .color-grid.square-grid .color-swatch {
            border-radius: 4px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.1s;
            background: transparent;
        }

        .color-swatch:hover {
            transform: scale(1.2);
            border-color: #999;
        }

        .color-separator {
            height: 1px;
            background: #e5e7eb;
            margin: 8px 0;
        }

        .color-reset-btn {
            font-size: 13px;
            cursor: pointer;
            padding: 6px;
            text-align: center;
            background: #f3f4f6;
            border-radius: 4px;
            color: #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .color-reset-btn:hover {
            background: #e5e7eb;
        }

        .rich-text-toolbar .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #dee2e6;
            margin: 0 4px;
        }

        .rich-text-editor {
            min-height: 250px;
            padding: 20px;
            font-size: 14px;
            line-height: 1.6;
            direction: rtl;
            text-align: right;
            outline: none;
            overflow-y: auto;
            font-family: "Noto Naskh Arabic", 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            resize: vertical;
            flex: 1;
        }

        .rich-text-editor:focus {
            outline: none;
        }

        .rich-text-editor p,
        .rich-text-editor div {
            margin: 0 0 8px 0;
            min-height: 1.5em;
        }

        .rich-text-editor p:last-child,
        .rich-text-editor div:last-child {
            margin-bottom: 0;
        }

        .rich-text-editor p:empty::before,
        .rich-text-editor div:empty::before {
            content: '\200B';
        }

        .rich-text-editor h1 {
            font-size: 2em;
            font-weight: bold;
            margin: 0.67em 0;
        }

        .rich-text-editor h3 {
            font-size: 1.17em;
            font-weight: bold;
            margin: 1em 0;
        }

        /* Inline Math Field Styles */
        .rich-text-editor math-field {
            display: inline-block;
            vertical-align: baseline;
            min-width: 60px;
            min-height: 1.5em;
            margin: 0 2px;
            padding: 2px 4px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: #f9fafb;
            font-size: 14px;
            line-height: 1.5;
        }

        .rich-text-editor math-field:focus,
        .rich-text-editor math-field:focus-within {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
            background: white;
        }

        .rich-text-editor math-field[contenteditable="true"] {
            cursor: text;
        }

        /* Block Math Wrapper */
        .math-block-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
            margin: 10px 0;
        }

        .math-block-wrapper math-field {
            display: block;
            font-size: 1.1em;
            min-width: 200px;
        }

        /* Syntax Highlighting for Keywords */
        .editor-keyword {
            color: #d946ef;
            font-weight: bold;
            background: #fae8ff;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        /* Table Styles */
        .rich-text-editor table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            border: 1px solid #ccc;
            background: white;
        }

        .rich-text-editor table td,
        .rich-text-editor table th {
            border: 1px solid #ccc;
            padding: 8px 12px;
            min-width: 50px;
            vertical-align: top;
            text-align: right;
        }

        .rich-text-editor table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .rich-text-editor table td[contenteditable="true"],
        .rich-text-editor table th[contenteditable="true"] {
            outline: none;
        }

        .rich-text-editor table td[contenteditable="true"]:focus,
        .rich-text-editor table th[contenteditable="true"]:focus {
            background: #f0f9ff;
            outline: 2px solid #4f46e5;
            outline-offset: -2px;
        }

        .rich-text-editor table.LexicalTheme__table {
            border-collapse: collapse;
            width: 100%;
        }

        /* Table Context Menu */
        .table-context-menu {
            position: absolute;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
            padding: 4px 0;
            display: none;
            font-size: 14px;
        }

        .table-context-menu.active {
            display: block;
        }

        .table-context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #495057;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .table-context-menu-item:hover {
            background: #f8f9fa;
        }

        .table-context-menu-item.danger {
            color: #dc2626;
        }

        .table-context-menu-item.danger:hover {
            background: #fee2e2;
        }

        .table-context-menu-separator {
            height: 1px;
            background: #e5e7eb;
            margin: 4px 0;
        }

        /* Table Modal Styles */
        .table-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .table-modal.active {
            display: flex;
        }

        .table-modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .table-modal-content h3 {
            margin-bottom: 20px;
            color: #1f2937;
        }

        .table-modal-form-group {
            margin-bottom: 16px;
        }

        .table-modal-form-group label {
            display: block;
            margin-bottom: 6px;
            color: #374151;
            font-weight: 500;
        }

        .table-modal-form-group input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .table-modal-form-group input[type="checkbox"] {
            margin-left: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .table-modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 24px;
            justify-content: flex-end;
        }

        .table-modal-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        .table-modal-actions .btn-insert {
            background: #4f46e5;
            color: white;
        }

        .table-modal-actions .btn-insert:hover {
            background: #4338ca;
        }

        .table-modal-actions .btn-cancel {
            background: #e5e7eb;
            color: #495057;
        }

        .table-modal-actions .btn-cancel:hover {
            background: #d1d5db;
        }
    </style>
</head>

<body>
    <div id="messageContainer" class="message-container" aria-live="polite"></div>
    <div class="container">
        <div class="header">
            <div class="ai-badge">ü§ñ AI Powered</div>
            <h1 id="main-title">üöÄ ŸÖÿ≠ŸàŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ∞ŸÉŸä ÿßŸÑŸÖÿ™ÿ∑Ÿàÿ±</h1>
            <p id="main-subtitle">ÿ≠ŸàŸëŸÑ ŸÜÿµŸàÿµ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ•ŸÑŸâ ÿµŸäÿ∫ÿ© JSON ŸÖÿ™ŸÇÿØŸÖÿ© ÿ®ÿ∂ÿ∫ÿ∑ÿ© ÿ≤ÿ±</p>
        </div>
        <div class="content">
            <!-- Input Panel -->
            <div class="panel">
                <h3 id="panel-title-1"><span style="font-size: 1.5em; line-height: 1;">‚ë†</span> ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ (ŸÑŸÑŸÜÿµ
                    ÿßŸÑÿ®ÿ≥Ÿäÿ∑)</h3>
                <div id="questionTypeSelector" class="question-type-selector"></div>
                <h3 id="panel-title-2" style="margin-top: 20px;"><span
                        style="font-size: 1.5em; line-height: 1;">‚ë°</span> ÿ£ÿØÿÆŸÑ ÿßŸÑŸÜÿµ</h3>
                <div class="input-section">
                    <!-- Hidden textarea for legacy parser compatibility -->
                    <textarea id="hiddenQuestionInput" style="display: none;"></textarea>
                    
                    <div id="questionInput" class="rich-text-editor-wrapper" data-placeholder="ÿ£ÿØÿÆŸÑ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß...
ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿ£Ÿä ÿ®ŸäÿßŸÜÿßÿ™ ŸàÿµŸÅŸäÿ© ŸÖÿ´ŸÑ id ÿ£Ÿà language (ŸÖÿß ÿπÿØÿß type ÿßŸÑÿ∞Ÿä ÿ≥Ÿäÿ∂ÿßŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß).
ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸàÿ≥ŸàŸÖ ŸÖÿ´ŸÑ @STEM Ÿà @CHOICES ŸÑÿ™ÿ≠ÿØŸäÿØ ÿ£ÿ¨ÿ≤ÿßÿ° ÿßŸÑÿ≥ÿ§ÿßŸÑ.
ÿßŸÅÿµŸÑ ÿ®ŸäŸÜ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ ÿ®ŸÄ ---
">
                        <div class="rich-text-toolbar" id="questionInput-toolbar">
                            <!-- History -->
                            <button data-action="undo" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
                            <button data-action="redo" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Headings -->
                            <select id="heading-select" title="Heading Style">
                                <option value="p">Normal</option>
                                <option value="h1">Heading 1</option>
                                <option value="h3">Heading 3</option>
                            </select>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Font Family -->
                            <select id="font-family-select" title="Font Family">
                                <option value="Noto Naskh Arabic">Noto Naskh Arabic</option>
                                <option value="Arial">Arial</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Verdana">Verdana</option>
                            </select>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Basic Format -->
                            <button data-format="bold" title="Bold (Ctrl+B)"><strong>B</strong></button>
                            <button data-format="italic" title="Italic (Ctrl+I)"><em>I</em></button>
                            <button data-format="underline" title="Underline (Ctrl+U)"><u>U</u></button>
                            <button data-format="strikethrough" title="Strikethrough"><s>T</s></button>
                            <select id="list-style-select" title="List Style" style="height: 32px; border-radius: 6px; border: 1px solid #d1d5db; color: #495057; font-size: 14px; padding: 0 8px; cursor: pointer;">
                                <option value="normal">Normal</option>
                                <option value="bullet">Bulleted List</option>
                                <option value="number">Numbered List</option>
                            </select>
                            <div class="color-picker-wrapper">
                                <button type="button" class="toolbar-btn color-trigger" id="color-picker-btn" title="Text & Highlight Color">
                                    <span style="font-weight:bold; font-family:serif; font-size:16px;">A</span>
                                    <div class="current-color-bar" id="current-color-bar" style="height:3px; width:100%; background:#d946ef; margin-top:2px;"></div>
                                </button>
                                <div class="color-dropdown" id="color-dropdown" style="display: none;">
                                    <div class="color-section">
                                        <div class="color-section-title">Text Color</div>
                                        <div class="color-grid" id="text-color-grid"></div>
                                    </div>
                                    <div class="color-separator"></div>
                                    <div class="color-section">
                                        <div class="color-section-title">Background Color</div>
                                        <div class="color-grid square-grid" id="bg-color-grid"></div>
                                    </div>
                                    <div class="color-separator"></div>
                                    <div class="color-reset-btn" id="reset-color-btn">
                                        <span>üö´</span> Reset / None
                                    </div>
                                </div>
                            </div>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Scripting -->
                            <button data-format="subscript" title="Subscript">X‚ÇÇ</button>
                            <button data-format="superscript" title="Superscript">X¬≤</button>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Color -->
                            
                            <!-- Math & Inserts -->
                            <button data-action="inline-math" title="Insert Inline Math">-Œ£-</button>
                            <button data-action="block-math" title="Insert Block Math">Œ£</button>
                            <button data-action="table" title="Insert Table">‚ñ¶</button>
                            <button data-action="separator" title="Insert Separator">---</button>
                            <button data-format="blockquote" title="Blockquote">"</button>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Direction -->
                            <button data-action="ltr" title="Left to Right">LTR</button>
                            <button data-action="rtl" title="Right to Left">RTL</button>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Alignment -->
                            <button data-align="left" title="Align Left">‚¨Ö</button>
                            <button data-align="center" title="Align Center">‚¨å</button>
                            <button data-align="right" title="Align Right">‚û°</button>
                            <button data-align="justify" title="Justify">‚¨ç</button>
                            <span class="toolbar-separator"></span>
                            
                            <!-- Indentation -->
                            <button data-action="outdent" title="Decrease Indent">‚ü®‚ò∞</button>
                            <button data-action="indent" title="Increase Indent">‚ò∞‚ü©</button>
                        </div>
                        <div class="rich-text-editor" id="questionInput-editor" contenteditable="true"></div>
                    </div>
                </div>
                
                <!-- Table Insert Modal -->
                <div id="table-modal" class="table-modal" onclick="if(event.target === this) window.richTextManager?.closeTableModal()">
                    <div class="table-modal-content" onclick="event.stopPropagation()">
                        <h3>Insert Table</h3>
                        <div class="table-modal-form-group">
                            <label for="table-rows">Number of Rows:</label>
                            <input type="number" id="table-rows" min="1" max="20" value="3">
                        </div>
                        <div class="table-modal-form-group">
                            <label for="table-cols">Number of Columns:</label>
                            <input type="number" id="table-cols" min="1" max="20" value="3">
                        </div>
                        <div class="table-modal-form-group">
                            <label>
                                <input type="checkbox" id="table-header-row">
                                Include Header Row
                            </label>
                        </div>
                        <div class="table-modal-actions">
                            <button class="btn-cancel" onclick="window.richTextManager?.closeTableModal()">Cancel</button>
                            <button class="btn-insert" onclick="window.richTextManager?.insertTable()">Insert</button>
                        </div>
                    </div>
                </div>
                
                <!-- Table Context Menu -->
                <div id="table-context-menu" class="table-context-menu">
                    <div class="table-context-menu-item" data-action="insert-row-above">Insert Row Above</div>
                    <div class="table-context-menu-item" data-action="insert-row-below">Insert Row Below</div>
                    <div class="table-context-menu-separator"></div>
                    <div class="table-context-menu-item" data-action="insert-col-left">Insert Column Left</div>
                    <div class="table-context-menu-item" data-action="insert-col-right">Insert Column Right</div>
                    <div class="table-context-menu-separator"></div>
                    <div class="table-context-menu-item" data-action="delete-row">Delete Row</div>
                    <div class="table-context-menu-item" data-action="delete-col">Delete Column</div>
                    <div class="table-context-menu-item danger" data-action="delete-table">Delete Table</div>
                    <div class="table-context-menu-separator"></div>
                    <div class="table-context-menu-item" data-action="toggle-header">Toggle Header Row</div>
                </div>
                
                <div class="api-key-section">
                    <select id="aiProviderSelect">
                        <option value="gemini" selected>Google Gemini</option>
                        <option value="openai">OpenAI</option>
                    </select>
                    <div id="gemini-key-container">
                        <input type="password" id="geminiApiKey" placeholder="üîë ÿ£ÿØÿÆŸÑ ŸÖŸÅÿ™ÿßÿ≠ Gemini API ŸáŸÜÿß">
                    </div>
                    <div id="openai-key-container" style="display: none;">
                        <input type="password" id="openaiApiKey" placeholder="üîë ÿ£ÿØÿÆŸÑ ŸÖŸÅÿ™ÿßÿ≠ OpenAI API ŸáŸÜÿß">
                    </div>
                </div>
                <div class="controls">
                    <button id="generate-questions-btn" class="btn btn-primary">üöÄ ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≥ÿ¶ŸÑÿ©</button>
                    <button id="smart-analyze-btn" class="btn btn-primary">üëÅÔ∏è ÿπÿ±ÿ∂</button>
                </div>
                <div class="controls">
                    <button id="aiEnhanceBtn" class="btn btn-ai">üíé ÿ™ÿ≠ÿ≥ŸäŸÜ ÿ®ÿßŸÑŸÄ AI</button>
                </div>
                <div class="controls">
                    <button id="convert-json-btn" class="btn btn-success">üîÑ ÿ™ÿ≠ŸàŸäŸÑ ŸÑŸÄ JSON</button>
                    <button id="customizeBtn" class="btn btn-secondary">‚öôÔ∏è ÿ™ÿÆÿµŸäÿµ</button>
                    <button id="tagsBtn" class="btn btn-secondary">üè∑Ô∏è Tags</button>
                    <button id="clear-all-btn" class="btn btn-secondary">üóëÔ∏è ŸÖÿ≥ÿ≠ ÿßŸÑŸÉŸÑ</button>
                    <button id="langSwitchBtn" class="btn btn-warning">üåê English</button>
                </div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p id="loading-text">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ...</p>
                </div>
            </div>
            <!-- Statistics Panel -->
            <div class="panel">
                <h3 id="stats-title">üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©</h3>
                <div class="stats-section" id="statsSection">
                    <div class="stat-item">
                        <span class="stat-label">ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©:</span>
                        <span class="stat-value" id="totalQuestions">0</span>
                    </div>
                    <div class="question-types-stats" id="questionTypesStats">
                        <!-- ÿ≥Ÿäÿ™ŸÖ ŸÖŸÑÿ§Ÿáÿß ÿØŸäŸÜÿßŸÖŸäŸÉŸäÿßŸã -->
                    </div>
                </div>
                <div class="json-output" id="jsonOutput" style="display: none;"></div>
                <div class="controls" style="margin-top: auto;">
                    <button id="copyBtn" class="btn btn-secondary" disabled>üìã ŸÜÿ≥ÿÆ JSON</button>
                    <button id="downloadBtn" class="btn btn-warning" disabled>üíæ ÿ™ÿ≠ŸÖŸäŸÑ</button>
                    <button id="downloadZipBtn" class="btn btn-warning" disabled>üóúÔ∏è ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÄ ZIP</button>
                    <button id="csvBtn" class="btn btn-secondary" disabled>üìÑ CSV</button>
                </div>
            </div>
            <!-- Preview Panel -->
            <div class="panel">
                <h3 id="panel-title-4">üëÅÔ∏è ŸÖÿπÿßŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©</h3>
                <div id="questionsPreview">
                    <div id="preview-placeholder"
                        style="text-align: center; color: #6b7280; padding: 40px; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                        <div style="font-size: 3em; margin-bottom: 20px;">üìã</div>
                        <p>ÿ≥ÿ™ÿ∏Ÿáÿ± ŸÖÿπÿßŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸáŸÜÿß ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Customize Modal -->
    <div id="customizeModal"
        style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.25); z-index:2000; align-items:center; justify-content:center;"
        role="dialog" aria-modal="true" aria-labelledby="customize-title">
        <div
            style="background:white; border-radius:16px; max-width:400px; width:90vw; padding:32px 24px; box-shadow:0 8px 32px rgba(0,0,0,0.15); position:relative;">
            <button id="customize-modal-close-btn"
                style="position:absolute; top:12px; left:12px; background:none; border:none; font-size:1.5em; cursor:pointer;">√ó</button>
            <h2 id="customize-title" style="text-align:center; margin-bottom:24px; color:#4f46e5;">ÿ™ÿÆÿµŸäÿµ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</h2>
            <div style="margin-bottom:18px;">
                <label for="categorySelect" style="font-weight:bold;">Category</label>
                <select id="categorySelect"
                    style="width:100%; padding:10px; border-radius:8px; border:1px solid #e5e7eb; margin-top:6px;">
                    <option value="lesson" selected>lesson</option>
                    <option value="exam">exam</option>
                </select>
            </div>
            <div style="margin-bottom:18px;">
                <label for="langSelect" style="font-weight:bold;">Lang</label>
                <select id="langSelect"
                    style="width:100%; padding:10px; border-radius:8px; border:1px solid #e5e7eb; margin-top:6px;">
                    <option value="ar" selected>ar</option>
                    <option value="en">en</option>
                </select>
            </div>
            <div style="margin-bottom:18px;">
                <label for="countrySelect" style="font-weight:bold;">Country</label>
                <select id="countrySelect"
                    style="width:100%; padding:10px; border-radius:8px; border:1px solid #e5e7eb; margin-top:6px;">
                    <option value="eg" selected>eg</option>
                    <option value="sa">sa</option>
                    <option value="ae">ae</option>
                    <option value="kw">kw</option>
                    <option value="qa">qa</option>
                    <option value="bh">bh</option>
                    <option value="om">om</option>
                </select>
            </div>
            <div style="margin-bottom:18px;">
                <label for="sourceIdSelect" style="font-weight:bold;">Source ID (Name)</label>
                <div id="sourceIdContainer" style="position: relative; width: 100%; margin-top: 6px;">
                    <input type="text" id="sourceIdInput" placeholder="ÿßÿ®ÿ≠ÿ´ ÿ®ÿßŸÑÿßÿ≥ŸÖ ÿ£Ÿà ID..."
                        style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #e5e7eb; box-sizing: border-box;">
                    <div id="sourceIdDropdown"
                        style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #e5e7eb; border-radius: 8px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <!-- Options will be populated dynamically -->
                    </div>
                </div>
                <input type="hidden" id="sourceIdSelect" value="">
            </div>
            <div style="margin-bottom:24px;">
                <label for="dialectSelect" style="font-weight:bold;">Dialect</label>
                <select id="dialectSelect"
                    style="width:100%; padding:10px; border-radius:8px; border:1px solid #e5e7eb; margin-top:6px;">
                    <option value="Modern_standard" selected>Modern_standard</option>
                </select>
            </div>
            <button id="subjectTemplateBtn" class="btn btn-secondary" style="width:100%; margin-top: 10px;">Subject
                Template ID</button>
            <button id="customize-save-btn" class="btn btn-primary" style="width:100%; margin-top: 10px;">ÿ≠ŸÅÿ∏</button>
        </div>
    </div>
    <!-- Tags Modal -->
    <div id="tagsModal" role="dialog" aria-modal="true" aria-labelledby="tagsModalHeader">
        <div id="tagsModalHeader">
            <span>ÿ•ÿØÿ±ÿßÿ¨ Ÿàÿ≥ŸÖ (Tag)</span>
            <button id="tags-modal-close-btn">√ó</button>
        </div>
        <div id="tagsModalBody">
            <div class="tags-section" id="templates-section">
                <h4>ÿ•ÿØÿ±ÿßÿ¨ ŸÇÿßŸÑÿ® ÿ¨ÿßŸáÿ≤</h4>
                <div class="tags-grid"></div>
            </div>
            <div class="tags-section" id="tags-section">
                <h4>ÿ•ÿØÿ±ÿßÿ¨ Ÿàÿ≥ŸÖ</h4>
                <div class="tags-grid"></div>
            </div>
        </div>
    </div>
    <!-- Generation Modal -->
    <div id="generationModalBg" role="dialog" aria-modal="true" aria-labelledby="generation-title">
        <div id="generationModal">
            <div class="generation-header">
                <h2 id="generation-title">üöÄ ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä</h2>
            </div>
            <div class="generation-content">
                <div class="generation-column">
                    <h4>‚ë† ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ</h4>
                    <textarea id="gen-text-input" placeholder="ÿßŸÑÿµŸÇ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿØÿ±ÿ≥ ŸáŸÜÿß..."
                        style="width:100%; height: 200px; border-radius: 8px; border: 1px solid #d1d5db; padding: 10px; margin-bottom: 1rem;"></textarea>
                    <input type="file" id="gen-image-input" accept="image/*" style="display:none;">
                    <div id="gen-image-drop-zone">
                        <p>ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ÿµŸàÿ±ÿ© ŸáŸÜÿßÿå ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±</p>
                        <img id="gen-image-preview" style="display:none;">
                    </div>
                </div>
                <div class="generation-column">
                    <h4>‚ë° ÿ≠ÿØÿØ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</h4>
                    <div id="gen-q-types-container"></div>
                    <hr style="margin: 1rem 0;">
                    <div class="gen-q-type-row">
                        <label for="gen-multi-part-count">ÿ≥ÿ§ÿßŸÑ ŸÖÿ™ÿπÿØÿØ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°</label>
                        <input type="number" id="gen-multi-part-count" min="0" value="0">
                    </div>
                    <input type="text" id="gen-multi-part-types" placeholder="ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° (ŸÖÿ´ÿßŸÑ: mcq, string)">
                    <hr style="margin: 1rem 0;">
                    <h4>‚ë¢ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä) ÿ£ÿ∂ŸÅ ÿ™Ÿàÿ¨ŸäŸáÿßÿ™ ÿÆÿßÿµÿ©</h4>
                    <textarea id="gen-custom-prompt"
                        placeholder="ŸÖÿ´ÿßŸÑ: ÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸÅÿßŸáŸäŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©ÿå ÿßÿ¨ÿπŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ•ÿπÿØÿßÿØŸäÿ©..."
                        style="width:100%; height: 100px; border-radius: 8px; border: 1px solid #d1d5db; padding: 10px;"></textarea>
                </div>
            </div>
            <div class="generation-footer">
                <button id="modal-generate-btn" class="btn btn-primary">ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©</button>
                <button id="modal-cancel-btn" class="btn btn-secondary">ÿ•ŸÑÿ∫ÿßÿ°</button>
            </div>
        </div>
    </div>
    <!-- Handsontable CSV Modal -->
    <div id="csvModalBg" role="dialog" aria-modal="true" aria-labelledby="csv-title">
        <div id="csvModal">
            <button id="csv-modal-close-btn"
                style="position:absolute; top:12px; left:12px; background:none; border:none; font-size:1.5em; cursor:pointer;">√ó</button>
            <h2 id="csv-title" style="text-align:center; margin-bottom:18px; color:#4f46e5;">CSV Editor</h2>
            <div class="csv-warning" id="csvWarning" style="display:none;"></div>
            <div id="hotTable" class="hot-container"></div>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:18px;">
                <button id="csv-save-btn" class="btn btn-success">üíæ ÿ≠ŸÅÿ∏</button>
                <button id="csv-close-btn" class="btn btn-secondary">‚ùå ÿ•ÿ∫ŸÑÿßŸÇ</button>
            </div>
        </div>
    </div>
    <!-- Subject Template ID Modal -->
    <div id="subjectTemplateModalBg" role="dialog" aria-modal="true" aria-labelledby="subject-template-title">
        <div id="subjectTemplateModal">
            <button id="subject-template-modal-close-btn"
                style="position:absolute; top:12px; left:12px; background:none; border:none; font-size:1.5em; cursor:pointer;">√ó</button>
            <h2 id="subject-template-title" style="text-align:center; margin-bottom:18px; color:#4f46e5;">ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿßÿØÿ©
                ŸÑÿ™ÿ∑ÿ®ŸäŸÇ Template ID</h2>
            <div style="margin-bottom: 20px;">
                <label for="subjectSelect" style="font-weight:bold; display:block; margin-bottom:10px;">ÿßŸÑŸÖÿßÿØÿ© /
                    Subject:</label>
                <select id="subjectSelect"
                    style="width:100%; padding:12px; border-radius:8px; border:2px solid #e5e7eb; font-size:14px;">
                    <option value="">-- ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿßÿØÿ© --</option>
                    <option value="ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°">ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°</option>
                    <option value="ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™">ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™</option>
                    <option value="ÿßŸÑÿπŸÑŸàŸÖ">ÿßŸÑÿπŸÑŸàŸÖ</option>
                    <option value="ÿßŸÑÿπŸÑŸàŸÖ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©">ÿßŸÑÿπŸÑŸàŸÖ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©</option>
                    <option value="ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ°">ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ°</option>
                    <option value="ÿßŸÑŸÉŸäŸÖŸäÿßÿ°">ÿßŸÑŸÉŸäŸÖŸäÿßÿ°</option>
                    <option value="ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©">ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                    <option value="ÿßŸÉÿ™ÿ¥ŸÅ">ÿßŸÉÿ™ÿ¥ŸÅ</option>
                    <option value="ÿßŸÑÿ™ÿßÿ±ŸäÿÆ">ÿßŸÑÿ™ÿßÿ±ŸäÿÆ</option>
                    <option value="ÿßŸÑÿ¨ÿ∫ÿ±ÿßŸÅŸäÿß">ÿßŸÑÿ¨ÿ∫ÿ±ÿßŸÅŸäÿß</option>
                    <option value="ÿßŸÑÿØÿ±ÿßÿ≥ÿßÿ™ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿ©">ÿßŸÑÿØÿ±ÿßÿ≥ÿßÿ™ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿ©</option>
                    <option value="ÿßŸÑŸÅŸÑÿ≥ŸÅÿ© ŸàÿßŸÑŸÖŸÜÿ∑ŸÇ">ÿßŸÑŸÅŸÑÿ≥ŸÅÿ© ŸàÿßŸÑŸÖŸÜÿ∑ŸÇ</option>
                    <option value="ÿπŸÑŸÖ ÿßŸÑŸÜŸÅÿ≥ ŸàÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ">ÿπŸÑŸÖ ÿßŸÑŸÜŸÅÿ≥ ŸàÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ</option>
                    <option value="Biologie">Biologie</option>
                    <option value="Biology">Biology</option>
                    <option value="Chemistry">Chemistry</option>
                    <option value="Connect Plus">Connect Plus</option>
                    <option value="Discover">Discover</option>
                    <option value="English">English</option>
                    <option value="Integrated Science">Integrated Science</option>
                    <option value="Mathematics">Mathematics</option>
                    <option value="Physics">Physics</option>
                    <option value="Science">Science</option>
                    <option value="Sciences">Sciences</option>
                    <option value="German">German</option>
                    <option value="Espa√±ol">Espa√±ol</option>
                    <option value="Italiano">Italiano</option>
                    <option value="Fran√ßais">Fran√ßais</option>
                </select>
            </div>

            <!-- English Stage Selection -->
            <div id="englishOptionsContainer" style="display:none; margin-bottom: 20px;">
                <div style="margin-bottom: 15px;">
                    <label for="englishStageSelect" style="font-weight:bold; display:block; margin-bottom:10px;">ÿßŸÑÿµŸÅ /
                        Grade:</label>
                    <select id="englishStageSelect"
                        style="width:100%; padding:12px; border-radius:8px; border:2px solid #e5e7eb; font-size:14px;">
                        <option value="">-- ÿßÿÆÿ™ÿ± ÿßŸÑÿµŸÅ --</option>
                        <option value="1">Grade 1</option>
                        <option value="2">Grade 2</option>
                        <option value="3">Grade 3</option>
                        <option value="4">Grade 4</option>
                        <option value="5">Grade 5</option>
                        <option value="6">Grade 6</option>
                        <option value="7">Grade 7</option>
                        <option value="8">Grade 8</option>
                        <option value="9">Grade 9</option>
                        <option value="10">Grade 10</option>
                        <option value="11">Grade 11</option>
                        <option value="12">Grade 12</option>
                    </select>
                </div>

                <div style="padding:12px; background:#e0e7ff; border-radius:8px; border:1px solid #6366f1;">
                    <p style="margin:0; color:#4338ca; font-size:14px;">
                        üí° <strong>ŸÖŸÑÿßÿ≠ÿ∏ÿ©:</strong> ÿ®ÿπÿØ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµŸÅÿå ÿ≥Ÿäÿ™ŸÖ ÿ™ÿπÿ®ÿ¶ÿ© Feedback Dialect Ÿà Language Level
                        ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã. ÿ≥ÿ™ÿ∏Ÿáÿ± ŸÇÿßÿ¶ŸÖÿ© ŸÖŸÜÿ≥ÿØŸÑÿ© ŸÅŸàŸÇ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ frq_ai ŸÅŸä ÿßŸÑŸÖÿπÿßŸäŸÜÿ© ŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸÜŸàÿπ Template ID ÿßŸÑŸÖŸÜÿßÿ≥ÿ®.
                        (ÿ£ÿ≥ÿ¶ŸÑÿ© String ÿ™ÿ≥ÿ™ÿÆÿØŸÖ Template ID ÿ´ÿßÿ®ÿ™: 593158513739)
                    </p>
                </div>
            </div>

            <div id="subjectQuestionsPreview"
                style="margin-bottom:20px; max-height:300px; overflow-y:auto; border:1px solid #e2e8f0; border-radius:8px; padding:15px; background:#f8fafc;">
                <p style="text-align:center; color:#6b7280;">ÿ≥ÿ™ÿ∏Ÿáÿ± ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ§ŸáŸÑÿ© ŸáŸÜÿß ÿ®ÿπÿØ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖÿßÿØÿ©</p>
            </div>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:18px;">
                <button id="subject-template-save-btn" class="btn btn-success">üíæ ÿ™ÿ∑ÿ®ŸäŸÇ</button>
                <button id="subject-template-close-btn" class="btn btn-secondary">‚ùå ÿ•ÿ∫ŸÑÿßŸÇ</button>
            </div>
        </div>
    </div>
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/handsontable@14.3.0/dist/handsontable.min.js"></script>
    <script src="https://unpkg.com/@nagwa-limited/mathlive" defer></script>
    <script src="https://unpkg.com/@nagwa-limited/kashida-engine/dist/kashida-engine.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
    <script>
        /**
         * RichTextManager Class
         * Comprehensive WYSIWYG Rich Text Editor with full toolbar support
         * Bridges visual HTML editing with plain text parser requirements
         */
        class RichTextManager {
            constructor(editorElement, toolbarElement) {
                this.editor = editorElement;
                this.toolbar = toolbarElement;
                this.toolbarButtons = {};
                this.colorPalette = [
                    '#000000', '#444444', '#666666', '#999999',
                    '#cccccc', '#eeeeee', '#f3f4f6', '#ffffff',
                    '#ff0000', '#ff9900', '#ffff00', '#00ff00',
                    '#00ffff', '#0000ff', '#9900ff', '#ff00ff',
                    '#ffb6c1', '#ffd700', '#98fb98', '#87cefa'
                ];
                this.defaultTextColor = '#d946ef';
                this.currentTextColor = this.defaultTextColor;
                this.syncTimeout = null;
                this.validationTimeout = null;
                this.setupToolbar();
                this.setupEditor();
            }

            setupToolbar() {
                // Setup all toolbar buttons and controls
                const buttons = this.toolbar.querySelectorAll('button');
                
                buttons.forEach(button => {
                    const format = button.dataset.format;
                    const action = button.dataset.action;
                    const align = button.dataset.align;
                    
                    if (format) {
                        this.toolbarButtons[format] = button;
                        button.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.toggleFormat(format);
                        });
                    } else if (action) {
                        button.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.handleAction(action);
                        });
                    } else if (align) {
                        button.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.setAlignment(align);
                        });
                    }
                });
                
                // Setup dropdowns
                const headingSelect = document.getElementById('heading-select');
                if (headingSelect) {
                    headingSelect.addEventListener('change', (e) => {
                        this.setHeading(e.target.value);
                    });
                }
                
                const fontSelect = document.getElementById('font-family-select');
                if (fontSelect) {
                    fontSelect.addEventListener('change', (e) => {
                        this.setFontFamily(e.target.value);
                    });
                }
                
                // Setup list style dropdown
                const listStyleSelect = document.getElementById('list-style-select');
                if (listStyleSelect) {
                    listStyleSelect.addEventListener('change', (e) => {
                        this.setListStyle(e.target.value);
                    });
                }

                this.setupColorPicker();
                
                // Setup table context menu
                const contextMenu = document.getElementById('table-context-menu');
                if (contextMenu) {
                    const menuItems = contextMenu.querySelectorAll('.table-context-menu-item');
                    menuItems.forEach(item => {
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const action = item.getAttribute('data-action');
                            if (action) {
                                this.handleTableContextAction(action);
                            }
                        });
                    });
                }
            }
            
            handleAction(action) {
                switch(action) {
                    case 'undo':
                        document.execCommand('undo', false, null);
                        break;
                    case 'redo':
                        document.execCommand('redo', false, null);
                        break;
                    case 'inline-math':
                        this.insertMath('inline');
                        break;
                    case 'block-math':
                        this.insertMath('block');
                        break;
                    case 'table':
                        this.openTableModal();
                        break;
                    case 'separator':
                        this.insertSeparator();
                        break;
                    case 'ltr':
                        this.setDirection('ltr');
                        break;
                    case 'rtl':
                        this.setDirection('rtl');
                        break;
                    case 'indent':
                        document.execCommand('indent', false, null);
                        break;
                    case 'outdent':
                        document.execCommand('outdent', false, null);
                        break;
                }
                this.editor.focus();
            }
            
            /**
             * insertMath(mode) - Inserts a math-field element at cursor position
             * @param {string} mode - 'inline' or 'block'
             */
            insertMath(mode) {
                const selection = window.getSelection();
                let range;
                
                if (selection.rangeCount === 0) {
                    // No selection, create range at end of editor
                    range = document.createRange();
                    const lastChild = this.editor.lastElementChild || this.editor;
                    if (lastChild.tagName === 'P' || lastChild.tagName === 'DIV') {
                        range.setStart(lastChild, lastChild.childNodes.length);
                    } else {
                        range.setStart(this.editor, this.editor.childNodes.length);
                    }
                    range.collapse(true);
                } else {
                    range = selection.getRangeAt(0);
                    // Delete any selected content
                    range.deleteContents();
                }
                
                // Ensure we're not inside a math-field (if so, move outside)
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentNode;
                }
                while (container && container !== this.editor) {
                    if (container.tagName === 'MATH-FIELD') {
                        // Move range to after the math-field
                        range.setStartAfter(container);
                        range.collapse(true);
                        break;
                    }
                    container = container.parentNode;
                }
                
                if (mode === 'inline') {
                    // Create inline math field
                    const mathField = this.createMathField('inline');
                    
                    // Insert math field at cursor position
                    range.insertNode(mathField);
                    
                    // Insert a space after math field for continued typing
                    const spaceNode = document.createTextNode('\u00A0'); // Non-breaking space
                    range.setStartAfter(mathField);
                    range.insertNode(spaceNode);
                    
                    // Move cursor after the space (but focus math field first)
                    range.setStartAfter(spaceNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // Focus the math field so user can type immediately
                    setTimeout(() => {
                        mathField.focus();
                    }, 10);
                } else if (mode === 'block') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'math-block-wrapper';
                    wrapper.setAttribute('contenteditable', 'false');
                    const mathField = this.createMathField('block');
                    wrapper.appendChild(mathField);

                    // Find parent block (e.g., P, DIV) directly under editor
                    let parentBlock = range.commonAncestorContainer;
                    if (parentBlock.nodeType === Node.TEXT_NODE) {
                        parentBlock = parentBlock.parentNode;
                    }
                    while (parentBlock && parentBlock !== this.editor && parentBlock.parentNode !== this.editor) {
                        parentBlock = parentBlock.parentNode;
                    }

                    const newParagraph = document.createElement('p');
                    newParagraph.innerHTML = '<br>';

                    if (parentBlock && parentBlock !== this.editor && this.editor.contains(parentBlock)) {
                        const insertAfter = parentBlock.nextSibling;
                        if (insertAfter) {
                            this.editor.insertBefore(wrapper, insertAfter);
                        } else {
                            this.editor.appendChild(wrapper);
                        }
                        if (wrapper.nextSibling) {
                            this.editor.insertBefore(newParagraph, wrapper.nextSibling);
                        } else {
                            this.editor.appendChild(newParagraph);
                        }
                    } else {
                        range.insertNode(wrapper);
                        if (wrapper.nextSibling) {
                            this.editor.insertBefore(newParagraph, wrapper.nextSibling);
                        } else {
                            this.editor.appendChild(newParagraph);
                        }
                    }

                    // Move cursor to the new paragraph
                    const newRange = document.createRange();
                    newRange.setStart(newParagraph, 0);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);

                    // Focus the math field so user can type immediately
                    setTimeout(() => {
                        mathField.focus();
                    }, 10);
                }
            }
            
            /**
             * createMathField(mode) - Creates a new math-field element with proper attributes
             * @param {string} mode - 'inline' or 'block'
             */
            createMathField(mode = 'inline') {
                const mathField = document.createElement('math-field');
                mathField.setAttribute('default-mode', mode === 'block' ? 'math' : 'inline-math');
                mathField.setAttribute('display', mode);
                mathField.setAttribute('contenteditable', 'true');
                mathField.value = '';
                
                // Listen to input events from math field to sync
                mathField.addEventListener('input', () => {
                    this.handleEditorInput();
                });
                
                // Listen to blur to sync when user leaves math field
                mathField.addEventListener('blur', () => {
                    this.handleEditorInput();
                });
                
                // Handle arrow keys to exit math field (only for inline)
                if (mode === 'inline') {
                    mathField.addEventListener('keydown', (e) => {
                        // Right arrow at end of math field should move to next text node
                        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                            const value = mathField.value || '';
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                // Check if cursor is at end (right) or start (left) of math field
                                const isAtEnd = range.startOffset >= value.length;
                                const isAtStart = range.startOffset === 0;
                                
                                if ((e.key === 'ArrowRight' && isAtEnd) || (e.key === 'ArrowLeft' && isAtStart)) {
                                    e.preventDefault();
                                    // Move selection to adjacent text node
                                    const nextNode = e.key === 'ArrowRight' ? mathField.nextSibling : mathField.previousSibling;
                                    if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
                                        const newRange = document.createRange();
                                        const offset = e.key === 'ArrowRight' ? 0 : nextNode.textContent.length;
                                        newRange.setStart(nextNode, offset);
                                        newRange.collapse(true);
                                        selection.removeAllRanges();
                                        selection.addRange(newRange);
                                    } else {
                                        // Create text node if doesn't exist
                                        const textNode = document.createTextNode('');
                                        if (e.key === 'ArrowRight') {
                                            mathField.parentNode.insertBefore(textNode, mathField.nextSibling);
                                        } else {
                                            mathField.parentNode.insertBefore(textNode, mathField);
                                        }
                                        const newRange = document.createRange();
                                        newRange.setStart(textNode, 0);
                                        newRange.collapse(true);
                                        selection.removeAllRanges();
                                        selection.addRange(newRange);
                                    }
                                }
                            }
                        }
                    });
                }
                
                return mathField;
            }
            
            insertSeparator() {
                this.insertTextAtCursor('\n---\n');
            }
            
            /**
             * Table Modal Methods
             */
            openTableModal() {
                const tableModal = document.getElementById('table-modal');
                if (tableModal) {
                    tableModal.classList.add('active');
                    // Reset form
                    document.getElementById('table-rows').value = 3;
                    document.getElementById('table-cols').value = 3;
                    document.getElementById('table-header-row').checked = false;
                }
            }
            
            closeTableModal() {
                const tableModal = document.getElementById('table-modal');
                if (tableModal) {
                    tableModal.classList.remove('active');
                }
            }
            
            insertTable() {
                const rows = parseInt(document.getElementById('table-rows').value) || 3;
                const cols = parseInt(document.getElementById('table-cols').value) || 3;
                const hasHeader = document.getElementById('table-header-row').checked;
                
                const table = this.createTable(rows, cols, hasHeader);
                this.insertTableAtCursor(table);
                this.closeTableModal();
            }
            
            createTable(rows, cols, hasHeader) {
                const table = document.createElement('table');
                table.className = 'LexicalTheme__table';
                table.setAttribute('dir', this.editor.style.direction || 'rtl');
                
                if (hasHeader) {
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    for (let i = 0; i < cols; i++) {
                        const th = document.createElement('th');
                        th.setAttribute('contenteditable', 'true');
                        th.textContent = '';
                        headerRow.appendChild(th);
                    }
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                }
                
                const tbody = document.createElement('tbody');
                const totalRows = hasHeader ? rows - 1 : rows;
                
                for (let i = 0; i < totalRows; i++) {
                    const tr = document.createElement('tr');
                    for (let j = 0; j < cols; j++) {
                        const td = document.createElement('td');
                        td.setAttribute('contenteditable', 'true');
                        td.textContent = '';
                        tr.appendChild(td);
                    }
                    tbody.appendChild(tr);
                }
                table.appendChild(tbody);
                
                this.attachTableEventListeners(table);
                return table;
            }
            
            insertTableAtCursor(table) {
                const selection = window.getSelection();
                let range;
                
                if (selection.rangeCount === 0) {
                    range = document.createRange();
                    const lastChild = this.editor.lastElementChild || this.editor;
                    if (lastChild.tagName === 'P' || lastChild.tagName === 'DIV') {
                        range.setStart(lastChild, lastChild.childNodes.length);
                    } else {
                        range.setStart(this.editor, this.editor.childNodes.length);
                    }
                    range.collapse(true);
                } else {
                    range = selection.getRangeAt(0);
                    range.deleteContents();
                }
                
                range.insertNode(table);
                range.setStartAfter(table);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                
                const firstCell = table.querySelector('td, th');
                if (firstCell) {
                    setTimeout(() => firstCell.focus(), 10);
                }
            }
            
            attachTableEventListeners(table) {
                const cells = table.querySelectorAll('td, th');
                cells.forEach(cell => {
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        this.showTableContextMenu(e, cell);
                    });
                    cell.addEventListener('click', () => {
                        this.activeTableCell = cell;
                    });
                });
            }
            
            showTableContextMenu(e, cell) {
                this.activeTableCell = cell;
                const contextMenu = document.getElementById('table-context-menu');
                if (!contextMenu) return;
                
                const rect = cell.getBoundingClientRect();
                contextMenu.style.top = (rect.bottom + window.scrollY + 5) + 'px';
                contextMenu.style.left = (rect.left + window.scrollX) + 'px';
                contextMenu.classList.add('active');
                
                const closeMenu = (event) => {
                    if (!contextMenu.contains(event.target) && event.target !== cell) {
                        contextMenu.classList.remove('active');
                        document.removeEventListener('click', closeMenu);
                    }
                };
                setTimeout(() => document.addEventListener('click', closeMenu), 100);
            }
            
            handleTableContextAction(action) {
                if (!this.activeTableCell) return;
                const cell = this.activeTableCell;
                const table = cell.closest('table');
                if (!table) return;
                
                const row = cell.parentElement;
                const tbody = table.querySelector('tbody') || table;
                const thead = table.querySelector('thead');
                const allRows = Array.from(tbody.querySelectorAll('tr'));
                if (thead) allRows.unshift(thead.querySelector('tr'));
                const rowIndex = allRows.indexOf(row);
                const colIndex = Array.from(row.children).indexOf(cell);
                
                switch(action) {
                    case 'insert-row-above': this.insertTableRow(table, rowIndex, 'above'); break;
                    case 'insert-row-below': this.insertTableRow(table, rowIndex, 'below'); break;
                    case 'insert-col-left': this.insertTableColumn(table, colIndex, 'left'); break;
                    case 'insert-col-right': this.insertTableColumn(table, colIndex, 'right'); break;
                    case 'delete-row': this.deleteTableRow(table, rowIndex); break;
                    case 'delete-col': this.deleteTableColumn(table, colIndex); break;
                    case 'delete-table': table.remove(); this.handleEditorInput(); break;
                    case 'toggle-header': this.toggleTableHeader(table); break;
                }
                
                document.getElementById('table-context-menu')?.classList.remove('active');
                this.handleEditorInput();
            }
            
            insertTableRow(table, rowIndex, position) {
                const tbody = table.querySelector('tbody') || table;
                const thead = table.querySelector('thead');
                let rows = Array.from(tbody.querySelectorAll('tr'));
                
                if (thead && rowIndex === 0 && position === 'above') {
                    const headerRow = thead.querySelector('tr');
                    const newRow = headerRow.cloneNode(true);
                    newRow.querySelectorAll('th').forEach(th => th.textContent = '');
                    thead.insertBefore(newRow, headerRow);
                    this.attachTableEventListeners(table);
                    return;
                }
                
                const adjustedIndex = thead ? rowIndex - 1 : rowIndex;
                const targetRow = rows[adjustedIndex];
                if (!targetRow) return;
                
                const newRow = targetRow.cloneNode(true);
                newRow.querySelectorAll('td, th').forEach(cell => {
                    cell.textContent = '';
                    cell.setAttribute('contenteditable', 'true');
                });
                
                if (position === 'above') {
                    tbody.insertBefore(newRow, targetRow);
                } else {
                    tbody.insertBefore(newRow, targetRow.nextSibling);
                }
                this.attachTableEventListeners(table);
            }
            
            insertTableColumn(table, colIndex, position) {
                table.querySelectorAll('tr').forEach(row => {
                    const cells = row.querySelectorAll('td, th');
                    const targetCell = cells[colIndex];
                    if (!targetCell) return;
                    const newCell = targetCell.cloneNode(true);
                    newCell.textContent = '';
                    newCell.setAttribute('contenteditable', 'true');
                    if (position === 'left') {
                        row.insertBefore(newCell, targetCell);
                    } else {
                        row.insertBefore(newCell, targetCell.nextSibling);
                    }
                });
                this.attachTableEventListeners(table);
            }
            
            deleteTableRow(table, rowIndex) {
                const tbody = table.querySelector('tbody') || table;
                const thead = table.querySelector('thead');
                let rows = Array.from(tbody.querySelectorAll('tr'));
                
                if (thead && rowIndex === 0) {
                    thead.remove();
                    return;
                }
                
                const adjustedIndex = thead ? rowIndex - 1 : rowIndex;
                if (rows.length <= 1) return;
                const targetRow = rows[adjustedIndex];
                if (targetRow) targetRow.remove();
            }
            
            deleteTableColumn(table, colIndex) {
                table.querySelectorAll('tr').forEach(row => {
                    const cells = row.querySelectorAll('td, th');
                    if (cells.length <= 1) return;
                    const targetCell = cells[colIndex];
                    if (targetCell) targetCell.remove();
                });
            }
            
            toggleTableHeader(table) {
                const thead = table.querySelector('thead');
                const tbody = table.querySelector('tbody') || table;
                const firstRow = tbody.querySelector('tr');
                
                if (thead) {
                    const headerRow = thead.querySelector('tr');
                    if (headerRow) {
                        headerRow.querySelectorAll('th').forEach(th => {
                            const td = document.createElement('td');
                            td.setAttribute('contenteditable', 'true');
                            td.textContent = th.textContent;
                            th.parentNode.replaceChild(td, th);
                        });
                        tbody.insertBefore(headerRow, firstRow);
                    }
                    thead.remove();
                } else if (firstRow) {
                    const newThead = document.createElement('thead');
                    const newHeaderRow = firstRow.cloneNode(true);
                    newHeaderRow.querySelectorAll('td').forEach(td => {
                        const th = document.createElement('th');
                        th.setAttribute('contenteditable', 'true');
                        th.textContent = td.textContent;
                        td.parentNode.replaceChild(th, td);
                    });
                    newThead.appendChild(newHeaderRow);
                    table.insertBefore(newThead, tbody);
                    firstRow.remove();
                }
                this.attachTableEventListeners(table);
            }
            
            insertTextAtCursor(text) {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    range.deleteContents();
                    const textNode = document.createTextNode(text);
                    range.insertNode(textNode);
                    range.setStartAfter(textNode);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    // Fallback: append at end
                    const textNode = document.createTextNode(text);
                    this.editor.appendChild(textNode);
                }
                this.editor.focus();
            }
            
            setHeading(tag) {
                document.execCommand('formatBlock', false, tag === 'p' ? '<p>' : `<${tag}>`);
                this.editor.focus();
            }
            
            setFontFamily(font) {
                document.execCommand('fontName', false, font);
                this.editor.focus();
            }
            
            setTextColor(color) {
                document.execCommand('foreColor', false, color);
                this.editor.focus();
            }
            
            setAlignment(align) {
                document.execCommand('justify' + align.charAt(0).toUpperCase() + align.slice(1), false, null);
                this.editor.focus();
            }
            
            setDirection(dir) {
                this.editor.style.direction = dir;
                this.editor.style.textAlign = dir === 'rtl' ? 'right' : 'left';
            }

            setupEditor() {
                // Ensure editor has at least one paragraph
                if (!this.editor.innerHTML.trim()) {
                    this.editor.innerHTML = '<p><br></p>';
                }

                // Handle keyboard shortcuts
                this.editor.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'b') {
                            e.preventDefault();
                            this.toggleFormat('bold');
                        } else if (e.key === 'i') {
                            e.preventDefault();
                            this.toggleFormat('italic');
                        } else if (e.key === 'u') {
                            e.preventDefault();
                            this.toggleFormat('underline');
                        } else if (e.key === 'z' && !e.shiftKey) {
                            e.preventDefault();
                            document.execCommand('undo', false, null);
                        } else if ((e.key === 'y') || (e.key === 'z' && e.shiftKey)) {
                            e.preventDefault();
                            document.execCommand('redo', false, null);
                        }
                    }
                });

                // Update toolbar button states on selection change
                this.editor.addEventListener('mouseup', () => this.updateToolbar());
                this.editor.addEventListener('keyup', () => this.updateToolbar());
                
                // Handle Enter key to create new paragraphs and exit lists
                this.editor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        // Check if we're inside a list
                        const isUnorderedList = document.queryCommandState('insertUnorderedList');
                        const isOrderedList = document.queryCommandState('insertOrderedList');
                        
                        if (isUnorderedList || isOrderedList) {
                            // Get the current selection
                            const selection = window.getSelection();
                            if (selection.rangeCount > 0) {
                                const range = selection.getRangeAt(0);
                                const container = range.commonAncestorContainer;
                                
                                // Find the list item (li) element
                                let listItem = container;
                                if (container.nodeType === Node.TEXT_NODE) {
                                    listItem = container.parentNode;
                                }
                                
                                // Traverse up to find the <li> element
                                while (listItem && listItem !== this.editor && listItem.tagName !== 'LI') {
                                    listItem = listItem.parentNode;
                                }
                                
                                if (listItem && listItem.tagName === 'LI') {
                                    // Get the text content of the list item
                                    const itemText = listItem.textContent || '';
                                    const trimmedText = itemText.trim();
                                    
                                    // If the list item is empty (or just whitespace), exit the list
                                    if (trimmedText === '' || trimmedText.length === 0) {
                                        e.preventDefault();
                                        document.execCommand('outdent', false, null);
                                        // Update toolbar after exiting list
                                        setTimeout(() => this.updateToolbar(), 10);
                                        return;
                                    }
                                }
                            }
                        }
                        
                        // Update toolbar for normal Enter key behavior
                        setTimeout(() => this.updateToolbar(), 0);
                    }
                });

                // Update toolbar on selection change
                document.addEventListener('selectionchange', () => {
                    const selection = document.getSelection();
                    if (selection.rangeCount > 0 && this.editor.contains(selection.anchorNode)) {
                        this.updateToolbar();
                    }
                });

                // Handle smart paste to preserve formatting and keywords
                this.editor.addEventListener('paste', (e) => this.handlePaste(e));
                
                // CRITICAL: Sync with AIQuestionConverter on input
                // This ensures getInputText() always returns the latest cleaned value
                // Listen to input events from both editor and math fields
                this.editor.addEventListener('input', (e) => {
                    // Only sync if the event didn't come from a math-field (to avoid double syncing)
                    if (e.target.tagName !== 'MATH-FIELD') {
                        this.handleEditorInput();
                    }
                }, true); // Use capture phase to catch all events
                
                // Also listen to math-field input events
                this.editor.addEventListener('input', (e) => {
                    if (e.target.tagName === 'MATH-FIELD') {
                        this.handleEditorInput();
                    }
                }, true);
            }
            
            handleEditorInput() {
                // Sync to hidden textarea for legacy parser
                this.syncToHiddenTextarea();
                
                // Trigger auto-save if converter exists
                if (window.app && typeof window.app.autoSaveContent === 'function') {
                    clearTimeout(this.syncTimeout);
                    this.syncTimeout = setTimeout(() => {
                        window.app.autoSaveContent();
                    }, 300);
                }
                
                // Trigger validation if converter exists
                if (window.app && typeof window.app.runLiveValidation === 'function') {
                    clearTimeout(this.validationTimeout);
                    this.validationTimeout = setTimeout(() => {
                        window.app.runLiveValidation();
                    }, 500);
                }
            }

            toggleFormat(format) {
                // Handle special formats
                if (format === 'subscript') {
                    document.execCommand('subscript', false, null);
                } else if (format === 'superscript') {
                    document.execCommand('superscript', false, null);
                } else if (format === 'strikethrough') {
                    document.execCommand('strikeThrough', false, null);
                } else if (format === 'blockquote') {
                    document.execCommand('formatBlock', false, '<blockquote>');
                } else {
                    document.execCommand(format, false, null);
                }
                this.updateToolbar();
                this.editor.focus();
            }

            updateToolbar() {
                try {
                    const isBold = document.queryCommandState('bold');
                    const isItalic = document.queryCommandState('italic');
                    const isUnderline = document.queryCommandState('underline');
                    const isStrikethrough = document.queryCommandState('strikeThrough');
                    const isSubscript = document.queryCommandState('subscript');
                    const isSuperscript = document.queryCommandState('superscript');

                    if (this.toolbarButtons.bold) {
                        this.toolbarButtons.bold.classList.toggle('active', isBold);
                    }
                    if (this.toolbarButtons.italic) {
                        this.toolbarButtons.italic.classList.toggle('active', isItalic);
                    }
                    if (this.toolbarButtons.underline) {
                        this.toolbarButtons.underline.classList.toggle('active', isUnderline);
                    }
                    if (this.toolbarButtons.strikethrough) {
                        this.toolbarButtons.strikethrough.classList.toggle('active', isStrikethrough);
                    }
                    if (this.toolbarButtons.subscript) {
                        this.toolbarButtons.subscript.classList.toggle('active', isSubscript);
                    }
                    if (this.toolbarButtons.superscript) {
                        this.toolbarButtons.superscript.classList.toggle('active', isSuperscript);
                    }
                    
                    // Update list style dropdown state
                    const listStyleSelect = document.getElementById('list-style-select');
                    if (listStyleSelect) {
                        const isUnorderedList = document.queryCommandState('insertUnorderedList');
                        const isOrderedList = document.queryCommandState('insertOrderedList');
                        
                        if (isUnorderedList) {
                            listStyleSelect.value = 'bullet';
                        } else if (isOrderedList) {
                            listStyleSelect.value = 'number';
                        } else {
                            listStyleSelect.value = 'normal';
                        }
                    }
                } catch (e) {
                    // Ignore errors when selection is not in editor
                }
            }
            
            /**
             * setListStyle(style) - Sets the list style for the current selection
             * @param {string} style - 'normal', 'bullet', or 'number'
             */
            setListStyle(style) {
                if (style === 'bullet') {
                    document.execCommand('insertUnorderedList', false, null);
                } else if (style === 'number') {
                    document.execCommand('insertOrderedList', false, null);
                } else if (style === 'normal') {
                    // Check if currently in a list
                    const isUnorderedList = document.queryCommandState('insertUnorderedList');
                    const isOrderedList = document.queryCommandState('insertOrderedList');
                    
                    if (isUnorderedList) {
                        // Toggle off unordered list by executing the command again
                        document.execCommand('insertUnorderedList', false, null);
                    } else if (isOrderedList) {
                        // Toggle off ordered list by executing the command again
                        document.execCommand('insertOrderedList', false, null);
                    }
                    
                    // Strictly ensure the block format is set to paragraph
                    document.execCommand('formatBlock', false, 'p');
                }
                this.editor.focus();
                // Update toolbar state after a short delay to ensure state is synced
                setTimeout(() => this.updateToolbar(), 10);
            }

            setupColorPicker() {
                const triggerBtn = document.getElementById('color-picker-btn');
                const dropdown = document.getElementById('color-dropdown');
                const textGrid = document.getElementById('text-color-grid');
                const bgGrid = document.getElementById('bg-color-grid');
                const resetBtn = document.getElementById('reset-color-btn');
                const currentBar = document.getElementById('current-color-bar');

                if (!triggerBtn || !dropdown || !textGrid || !bgGrid || !resetBtn || !currentBar) {
                    return;
                }

                currentBar.style.background = this.currentTextColor;

                const palette = Array.isArray(this.colorPalette) && this.colorPalette.length
                    ? this.colorPalette
                    : ['#000000', '#444444', '#666666', '#999999', '#cccccc', '#eeeeee', '#f3f4f6', '#ffffff', '#ff0000', '#ff9900', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#9900ff', '#ff00ff'];

                textGrid.innerHTML = '';
                bgGrid.innerHTML = '';

                let dropdownOpen = false;

                const closeDropdown = () => {
                    dropdown.style.display = 'none';
                    dropdownOpen = false;
                };

                const openDropdown = () => {
                    dropdown.style.display = 'block';
                    dropdownOpen = true;
                };

                const createSwatch = (color, type = 'text') => {
                    const swatch = document.createElement('button');
                    swatch.type = 'button';
                    swatch.className = 'color-swatch';
                    if (type === 'background') {
                        swatch.classList.add('square-swatch');
                    }
                    swatch.style.background = color;
                    swatch.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (type === 'background') {
                            document.execCommand('hiliteColor', false, color);
                            document.execCommand('backColor', false, color);
                        } else {
                            this.setTextColor(color);
                            this.currentTextColor = color;
                            currentBar.style.background = color;
                        }
                        this.editor.focus();
                        closeDropdown();
                    });
                    return swatch;
                };

                palette.forEach(color => {
                    textGrid.appendChild(createSwatch(color, 'text'));
                });

                palette.forEach(color => {
                    bgGrid.appendChild(createSwatch(color, 'background'));
                });

                triggerBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dropdownOpen ? closeDropdown() : openDropdown();
                });

                dropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                document.addEventListener('click', (e) => {
                    if (dropdownOpen && !dropdown.contains(e.target) && !triggerBtn.contains(e.target)) {
                        closeDropdown();
                    }
                });

                resetBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.execCommand('hiliteColor', false, 'transparent');
                    document.execCommand('backColor', false, 'transparent');
                    this.setTextColor(this.defaultTextColor);
                    this.currentTextColor = this.defaultTextColor;
                    currentBar.style.background = this.defaultTextColor;
                    this.editor.focus();
                    closeDropdown();
                });
            }

            handlePaste(e) {
                if (!e) return;
                e.preventDefault();
                const clipboard = e.clipboardData || window.clipboardData;
                let text = clipboard ? clipboard.getData('text') : '';
                if (!text) return;

                // Sanitize to prevent HTML injection
                let processed = text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');

                // Highlight structural tags
                const structuralTags = [
                    '@STEM', '@CHOICES', '@ANSWER', '@GAPS', '@MATCHING_PAIRS',
                    '@GUIDELINES', '@STATEMENT', '@PART', '@TASK', '@OVERVIEW',
                    '@POEM', '@END_POEM', '@BLANK'
                ];

                structuralTags.forEach(tag => {
                    const regex = new RegExp(`(${tag.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'g');
                    processed = processed.replace(regex, '<span class="editor-keyword">$1</span>');
                });

                // Highlight type definitions (e.g., type: mcq)
                processed = processed.replace(/(type:\s*[a-z_]+)/gi, '<span class="editor-keyword">$1</span>');

                // Highlight separators (---)
                processed = processed.replace(/(^|[\s])(-{3})(?=$|[\s])/g, '$1<span class="editor-keyword">$2</span>');

                // Highlight list markers at line start (* or - followed by space)
                processed = processed.replace(/(^|\n)([\*\-])(?=\s)/g, '$1<span class="editor-keyword">$2</span>');

                // Preserve line breaks
                processed = processed.replace(/\n/g, '<br>');

                document.execCommand('insertHTML', false, processed);
            }

            /**
             * syncToHiddenTextarea() - Syncs editor content to hidden textarea
             * This ensures the legacy parser can read the value via getInputText()
             */
            syncToHiddenTextarea() {
                const hiddenInput = document.getElementById('hiddenQuestionInput');
                if (hiddenInput) {
                    const value = this.getValue();
                    hiddenInput.value = value;
                    // Dispatch input event to notify listeners
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }

            /**
             * getValue() - Serializes editor content to the required format
             * 
             * Rules:
             * - Paragraphs are separated by \n
             * - Lists (UL, OL) are preserved as HTML
             * - Styled text is wrapped in HTML tags (<b>, <i>, <u>)
             * - Structure tags like @STEM, @CHOICES are NOT wrapped in <p> tags
             * - Returns plain text with HTML formatting tags
             */
            getValue() {
                let result = '';
                const children = Array.from(this.editor.childNodes);

                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const serialized = this.serializeNode(child);
                    
                    if (serialized.trim()) {
                        result += serialized;
                        
                        // Check if current child is a block element
                        const isBlockElement = this.isBlockElement(child);
                        
                        // Add newline after block elements (except last one)
                        if (isBlockElement && i < children.length - 1) {
                            result += '\n';
                        }
                    } else if (i < children.length - 1 && result) {
                        // Add newline for empty blocks (except at the end)
                        const isBlockElement = this.isBlockElement(child);
                        if (isBlockElement) {
                            result += '\n';
                        }
                    }
                }

                return result;
            }
            
            /**
             * isBlockElement(node) - Checks if a node is a block-level element
             * @param {Node} node - The node to check
             * @returns {boolean} - True if the node is a block element
             */
            isBlockElement(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                    return false;
                }
                const tagName = node.tagName.toLowerCase();
                const blockTags = ['p', 'div', 'ul', 'ol', 'li', 'table', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'];
                return blockTags.includes(tagName);
            }

            serializeNode(node) {
                // Handle Text Nodes
                if (node.nodeType === Node.TEXT_NODE) {
                    return this.escapeHtml(node.textContent);
                }

                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();
                    
                    // Handle Block Containers (P, DIV, H1-H6, BLOCKQUOTE)
                    if (tagName === 'p' || tagName === 'div' || tagName === 'h1' || tagName === 'h2' || tagName === 'h3' || tagName === 'h4' || tagName === 'h5' || tagName === 'h6' || tagName === 'blockquote') {
                        // Exception: If div has class math-block-wrapper, preserve it as-is
                        if (tagName === 'div' && node.classList && node.classList.contains('math-block-wrapper')) {
                            return node.outerHTML;
                        }
                        
                        let content = '';
                        const childNodes = Array.from(node.childNodes);
                        
                        for (const child of childNodes) {
                            content += this.serializeNode(child);
                        }
                        
                        // Wrap in the corresponding tag
                        if (tagName === 'p') {
                            return content; // Paragraphs don't need wrapping in output
                        } else if (tagName.startsWith('h')) {
                            return `<${tagName}>${content}</${tagName}>`;
                        } else if (tagName === 'blockquote') {
                            return `<blockquote>${content}</blockquote>`;
                        } else {
                            return content; // Other divs return content only
                        }
                    }
                    
                    // Handle Lists (UL, OL, LI) - Preserve structure
                    if (tagName === 'ul' || tagName === 'ol') {
                        let content = '';
                        const childNodes = Array.from(node.childNodes);
                        
                        for (const child of childNodes) {
                            content += this.serializeNode(child);
                        }
                        
                        // Wrap in list tag
                        return `<${tagName}>${content}</${tagName}>`;
                    }
                    
                    if (tagName === 'li') {
                        let content = '';
                        const childNodes = Array.from(node.childNodes);
                        
                        for (const child of childNodes) {
                            content += this.serializeNode(child);
                        }
                        
                        // Wrap in li tag
                        return `<li>${content}</li>`;
                    }

                    // Handle formatting tags - preserve these
                    if (tagName === 'b' || tagName === 'strong') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<b>${content}</b>`;
                    }

                    if (tagName === 'i' || tagName === 'em') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<i>${content}</i>`;
                    }

                    if (tagName === 'u') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<u>${content}</u>`;
                    }

                    if (tagName === 's' || tagName === 'strike') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<s>${content}</s>`;
                    }

                    if (tagName === 'sub') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<sub>${content}</sub>`;
                    }

                    if (tagName === 'sup') {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        return `<sup>${content}</sup>`;
                    }

                    // Handle editor-keyword spans - strip the span but keep the text
                    if (tagName === 'span' && node.classList && node.classList.contains('editor-keyword')) {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        // Return just the text content without the span wrapper
                        return content;
                    }

                    // Handle color spans
                    if (tagName === 'span' && node.style && node.style.color) {
                        let content = '';
                        for (const child of node.childNodes) {
                            content += this.serializeNode(child);
                        }
                        const color = node.style.color;
                        return `<span style="color: ${color}">${content}</span>`;
                    }

                    // Handle math-field elements - convert to backtick format
                    if (tagName === 'math-field') {
                        // Get the LaTeX value from the math-field
                        // MathLive stores value in the value property, fallback to attribute
                        let latex = '';
                        if (node.value !== undefined && node.value !== null) {
                            latex = String(node.value);
                        } else {
                            latex = node.getAttribute('value') || '';
                        }
                        // Clean the latex
                        latex = latex.trim();
                        if (!latex) return '';
                        
                        // Check if it's block or inline math
                        const display = node.getAttribute('display') || 'inline';
                        if (display === 'block') {
                            // Block math uses double backticks
                            return `\`\`${latex}\`\``;
                        } else {
                            // Inline math uses single backticks
                            return `\`${latex}\``;
                        }
                    }
                    
                    // Handle math-block-wrapper - extract the math-field inside
                    if (tagName === 'div' && node.classList && node.classList.contains('math-block-wrapper')) {
                        const mathField = node.querySelector('math-field');
                        if (mathField) {
                            let latex = '';
                            if (mathField.value !== undefined && mathField.value !== null) {
                                latex = String(mathField.value);
                            } else {
                                latex = mathField.getAttribute('value') || '';
                            }
                            latex = latex.trim();
                            return latex ? `\`\`${latex}\`\`` : '';
                        }
                    }

                    // Handle Tables - preserve as complete HTML
                    if (tagName === 'table') {
                        // Clone the table to preserve structure
                        const tableClone = node.cloneNode(true);
                        // Ensure all cells are contenteditable
                        tableClone.querySelectorAll('td, th').forEach(cell => {
                            cell.setAttribute('contenteditable', 'true');
                        });
                        // Get outerHTML and clean it
                        const tableHtml = tableClone.outerHTML;
                        return tableHtml;
                    }

                    // Handle Line Breaks (BR)
                    if (tagName === 'br') {
                        return '\n';
                    }

                    // Handle nested formatting - recursively process children for unknown tags
                    let content = '';
                    for (const child of node.childNodes) {
                        content += this.serializeNode(child);
                    }
                    return content;
                }

                return '';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * highlightKeywords() - Highlights keywords in text for visual distinction
             * @param {string} text - The text to highlight
             * @returns {string} - Text with highlighted keywords wrapped in spans
             */
            highlightKeywords(text) {
                if (!text) return text;
                
                // List of structural tags to highlight
                const structuralTags = [
                    '@STEM', '@CHOICES', '@ANSWER', '@GAPS', '@MATCHING_PAIRS',
                    '@GUIDELINES', '@STATEMENT', '@PART', '@TASK', '@OVERVIEW',
                    '@POEM', '@END_POEM', '@BLANK'
                ];
                
                let highlighted = text;
                
                // Highlight structural tags (must be at word boundary or start of line)
                structuralTags.forEach(tag => {
                    const regex = new RegExp(`(${tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(?=\\s|$|\\n)`, 'g');
                    highlighted = highlighted.replace(regex, `<span class="editor-keyword">$1</span>`);
                });
                
                // Highlight type: declarations (e.g., "type: mcq")
                highlighted = highlighted.replace(/(^|\n)(type:\s*[a-z_]+)/gi, '$1<span class="editor-keyword">$2</span>');
                
                // Highlight separator lines (---)
                highlighted = highlighted.replace(/(^|\n)(---)(\n|$)/g, '$1<span class="editor-keyword">$2</span>$3');
                
                return highlighted;
            }

            /**
             * setValue() - Sets the editor content from a formatted string
             * Parses HTML tags and line breaks to restore content
             */
            setValue(value) {
                if (!value) {
                    this.editor.innerHTML = '<p><br></p>';
                    this.syncToHiddenTextarea();
                    return;
                }

                // Check if value contains table HTML
                const tableRegex = /<table[\s\S]*?<\/table>/gi;
                if (tableRegex.test(value)) {
                    // Handle tables - split by table boundaries
                    const parts = value.split(/(<table[\s\S]*?<\/table>)/gi);
                    let html = '';
                    
                    for (const part of parts) {
                        if (part.match(/^<table/i)) {
                            // It's a table - add directly
                            html += part;
                        } else if (part.trim()) {
                            // Regular content - split by lines
                            const lines = part.split('\n');
                            for (const line of lines) {
                                if (line.trim()) {
                                    const parsedLine = this.parseLine(line);
                                    html += `<p>${parsedLine}</p>`;
                                } else {
                                    html += '<p><br></p>';
                                }
                            }
                        }
                    }
                    
                    this.editor.innerHTML = html || '<p><br></p>';
                } else {
                    // No tables - regular processing
                    const lines = value.split('\n');
                    let html = '';

                    for (const line of lines) {
                        if (line.trim()) {
                            const parsedLine = this.parseLine(line);
                            html += `<p>${parsedLine}</p>`;
                        } else {
                            html += '<p><br></p>';
                        }
                    }

                    this.editor.innerHTML = html || '<p><br></p>';
                }
                
                // Initialize all math-field elements after setting HTML
                this.initializeMathFields();
                
                // Initialize all table elements after setting HTML
                this.initializeTables();
                
                // Sync to hidden textarea after setting value
                this.syncToHiddenTextarea();
            }
            
            /**
             * initializeMathFields() - Initializes math-field elements after HTML is set
             * Attaches event listeners to all math-field elements in the editor
             */
            initializeMathFields() {
                const mathFields = this.editor.querySelectorAll('math-field');
                mathFields.forEach(mathField => {
                    // Ensure proper attributes
                    const display = mathField.getAttribute('display') || 'inline';
                    if (!mathField.hasAttribute('default-mode')) {
                        mathField.setAttribute('default-mode', display === 'block' ? 'math' : 'inline-math');
                    }
                    if (!mathField.hasAttribute('display')) {
                        mathField.setAttribute('display', display);
                    }
                    if (!mathField.hasAttribute('contenteditable')) {
                        mathField.setAttribute('contenteditable', 'true');
                    }
                    
                    // Get current value before cloning
                    const currentValue = mathField.getAttribute('value') || '';
                    
                    // Remove existing listeners to avoid duplicates by cloning
                    const newMathField = mathField.cloneNode(true);
                    
                    // Restore value if it exists
                    if (currentValue) {
                        newMathField.setAttribute('value', currentValue);
                        // Also set the property for MathLive
                        if (newMathField.value !== undefined) {
                            newMathField.value = currentValue;
                        }
                    }
                    
                    mathField.parentNode.replaceChild(newMathField, mathField);
                    
                    // Add event listeners
                    newMathField.addEventListener('input', () => {
                        this.handleEditorInput();
                    });
                    
                    newMathField.addEventListener('blur', () => {
                        this.handleEditorInput();
                    });
                });
                
                // Also initialize math-block-wrapper divs
                const wrappers = this.editor.querySelectorAll('.math-block-wrapper');
                wrappers.forEach(wrapper => {
                    if (!wrapper.hasAttribute('contenteditable')) {
                        wrapper.setAttribute('contenteditable', 'false');
                    }
                });
            }

            serializeElementForSet(element) {
                let result = '';
                
                for (const node of element.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        // Check if text contains backtick-wrapped math
                        const text = node.textContent;
                        
                        // Handle double backticks (block math) first
                        const blockMathRegex = /``([^`]+)``/g;
                        let processedText = text;
                        let hasBlockMath = false;
                        let blockMatch;
                        
                        while ((blockMatch = blockMathRegex.exec(text)) !== null) {
                            hasBlockMath = true;
                            const latex = blockMatch[1].trim();
                            const escapedLatex = this.escapeHtml(latex);
                            processedText = processedText.replace(blockMatch[0], `<div class="math-block-wrapper" contenteditable="false"><math-field default-mode="math" display="block" contenteditable="true" value="${escapedLatex}"></math-field></div>`);
                        }
                        
                        // Handle single backticks (inline math) - but not part of double backticks
                        const inlineMathRegex = /(?<!`)`([^`\n]+)`(?!`)/g;
                        let hasInlineMath = false;
                        processedText = processedText.replace(inlineMathRegex, (match, latex) => {
                            hasInlineMath = true;
                            const escapedLatex = this.escapeHtml(latex.trim());
                            return `<math-field default-mode="inline-math" display="inline" contenteditable="true" value="${escapedLatex}"></math-field>`;
                        });
                        
                        if (hasBlockMath || hasInlineMath) {
                            // If we found math, return the processed text (it will be parsed as HTML)
                            result += processedText;
                        } else {
                            // No math found, just escape the text
                            result += this.escapeHtml(text);
                        }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toLowerCase();
                        
                        if (tagName === 'b' || tagName === 'strong') {
                            let content = this.serializeElementForSet(node);
                            result += `<b>${content}</b>`;
                        } else if (tagName === 'i' || tagName === 'em') {
                            let content = this.serializeElementForSet(node);
                            result += `<i>${content}</i>`;
                        } else if (tagName === 'u') {
                            let content = this.serializeElementForSet(node);
                            result += `<u>${content}</u>`;
                        } else if (tagName === 's' || tagName === 'strike') {
                            let content = this.serializeElementForSet(node);
                            result += `<s>${content}</s>`;
                        } else if (tagName === 'sub') {
                            let content = this.serializeElementForSet(node);
                            result += `<sub>${content}</sub>`;
                        } else if (tagName === 'sup') {
                            let content = this.serializeElementForSet(node);
                            result += `<sup>${content}</sup>`;
                        } else if (tagName === 'span' && node.style && node.style.color) {
                            let content = this.serializeElementForSet(node);
                            result += `<span style="color: ${node.style.color}">${content}</span>`;
                        } else if (tagName === 'math-field') {
                            // Preserve math-field elements as-is
                            let latex = '';
                            if (node.value !== undefined && node.value !== null) {
                                latex = String(node.value);
                            } else {
                                latex = node.getAttribute('value') || '';
                            }
                            const display = node.getAttribute('display') || 'inline';
                            const escapedLatex = this.escapeHtml(latex.trim());
                            if (display === 'block') {
                                result += `<div class="math-block-wrapper" contenteditable="false"><math-field default-mode="math" display="block" contenteditable="true" value="${escapedLatex}"></math-field></div>`;
                            } else {
                                result += `<math-field default-mode="inline-math" display="inline" contenteditable="true" value="${escapedLatex}"></math-field>`;
                            }
                        } else if (tagName === 'div' && node.classList && node.classList.contains('math-block-wrapper')) {
                            // Preserve math-block-wrapper as-is
                            result += node.outerHTML;
                        } else if (tagName === 'table') {
                            // Preserve table as complete HTML
                            const tableClone = node.cloneNode(true);
                            tableClone.querySelectorAll('td, th').forEach(cell => {
                                cell.setAttribute('contenteditable', 'true');
                            });
                            result += tableClone.outerHTML;
                        } else {
                            // For other tags, just serialize their content
                            result += this.serializeElementForSet(node);
                        }
                    }
                }
                
                return result;
            }
            
            parseLine(line) {
                // Check if line contains a complete table HTML
                const tableRegex = /<table[\s\S]*?<\/table>/gi;
                if (tableRegex.test(line)) {
                    // Return table as-is (it will be parsed by setValue)
                    return line;
                }
                
                // Apply syntax highlighting to keywords first
                let processedLine = this.highlightKeywords(line);
                
                // Handle double backtick-wrapped math (block math) first
                const blockMathRegex = /``([^`]+)``/g;
                processedLine = processedLine.replace(blockMathRegex, (match, latex) => {
                    // Convert double backtick math to block math-field element
                    const escapedLatex = this.escapeHtml(latex.trim());
                    return `<div class="math-block-wrapper" contenteditable="false"><math-field default-mode="math" display="block" contenteditable="true" value="${escapedLatex}"></math-field></div>`;
                });
                
                // Handle single backtick-wrapped math (inline math) - but not double backticks
                const inlineMathRegex = /(?<!`)`([^`\n]+)`(?!`)/g;
                processedLine = processedLine.replace(inlineMathRegex, (match, latex) => {
                    // Convert single backtick math to inline math-field element
                    const escapedLatex = this.escapeHtml(latex.trim());
                    return `<math-field default-mode="inline-math" display="inline" contenteditable="true" value="${escapedLatex}"></math-field>`;
                });
                
                // Parse HTML tags and convert them to DOM structure
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = processedLine;
                
                // After parsing, we need to initialize the math-field elements
                // This will be done after setting innerHTML in setValue
                
                // Serialize back, preserving formatting tags
                return this.serializeElementForSet(tempDiv);
            }
            
            /**
             * initializeTables() - Initializes table elements after HTML is set
             * Attaches event listeners to all tables in the editor
             */
            initializeTables() {
                const tables = this.editor.querySelectorAll('table');
                tables.forEach(table => {
                    // Ensure table has proper class
                    if (!table.classList.contains('LexicalTheme__table')) {
                        table.classList.add('LexicalTheme__table');
                    }
                    
                    // Ensure all cells are contenteditable
                    table.querySelectorAll('td, th').forEach(cell => {
                        cell.setAttribute('contenteditable', 'true');
                    });
                    
                    // Attach event listeners
                    this.attachTableEventListeners(table);
                });
            }
        }

        // Initialize RichTextManager first (before AIQuestionConverter)
        let questionInputRichEditor = null;
        
        function initializeRichTextEditor() {
            const editorElement = document.getElementById('questionInput-editor');
            const toolbarElement = document.getElementById('questionInput-toolbar');
            
            if (editorElement && toolbarElement && !questionInputRichEditor) {
                questionInputRichEditor = new RichTextManager(editorElement, toolbarElement);
                window.richTextManager = questionInputRichEditor; // Global access for modal handlers
                
                // Set placeholder if needed
                const placeholder = document.getElementById('questionInput')?.getAttribute('data-placeholder');
                if (placeholder && !editorElement.textContent.trim()) {
                    editorElement.setAttribute('data-placeholder', placeholder);
                }
            }
        }

        // Initialize RichTextManager when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeRichTextEditor);
        } else {
            initializeRichTextEditor();
        }

        // Export for global access
        window.RichTextManager = RichTextManager;
        window.getQuestionInputValue = function() {
            if (questionInputRichEditor) {
                return questionInputRichEditor.getValue();
            }
            // Fallback to hidden textarea
            const hiddenInput = document.getElementById('hiddenQuestionInput');
            if (hiddenInput) return hiddenInput.value || '';
            // Fallback to textarea if editor not initialized
            const textarea = document.getElementById('questionInput');
            return textarea ? textarea.value : '';
        };

        window.setQuestionInputValue = function(value) {
            if (questionInputRichEditor) {
                questionInputRichEditor.setValue(value);
            } else {
                // Fallback to hidden textarea
                const hiddenInput = document.getElementById('hiddenQuestionInput');
                if (hiddenInput) {
                    hiddenInput.value = value || '';
                    hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
                // Fallback to textarea if editor not initialized
                const textarea = document.getElementById('questionInput');
                if (textarea) textarea.value = value;
            }
        };

        window.addEventListener('load', () => {
            class AIQuestionConverter {
                // Source ID data
                sourceIdData = [];

                constructor() {
                    // --- 1. CONFIGURATION ---
                    this.config = Object.freeze({
                        api: {
                            geminiEndpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=',
                            openaiEndpoint: 'https://api.openai.com/v1/chat/completions'
                        },
                        defaults: {
                            country: 'eg',
                            category: 'lesson',
                            dialect: 'Modern_standard',
                            sourceId: '', // Start with empty value to force selection
                            lang: 'ar'
                        },
                        flags: {
                            convertArabicLatex: false
                        },
                        ARABIC_LATEX_MAP: {
                            "F(x)": "\\dotlessqaft (\\seen)", "Q'": "\\dotlessnoont \\prime", 'N': '\\tah', 'Z': '\\sadt',
                            'Q': '\\dotlessnoont', 'X': '\\seent', 'Y': '\\sadt', 'x': '\\seen', 'y': '\\sad',
                            'z': '\\ain', 'A': '\\alt{\\alef}', 'B': '\\beh', 'C': '\\jeemi', 'D': '\\dal',
                            'E': '\\hehi', 'F': '\\waw', 'M': '\\meem', 'n': '\\noon', 'K': '\\kaf',
                            'L': '\\lam', 's': '\\feh', 'O': '\\waw', 'R': '\\haht', 'r': '\\aint',
                        }
                    });
                    // --- 2. ENUMS & CONSTANTS ---
                    this.QuestionType = Object.freeze({
                        MCQ: "mcq", MRQ: "mrq", STRING: "string", OQ: "oq", GAP_TEXT: "gapText",
                        MATCHING: "matching", INPUT_BOX: "input_box", FRQ_AI: "frq_ai", UNKNOWN: "unknown"
                    });
                    this.Language = Object.freeze({ ARABIC: "ar", ENGLISH: "en" });
                    // --- 3. UTILITIES ---
                    this.logger = {
                        info: (message) => console.log(`[INFO] ‚ú®: ${message}`),
                        warn: (message) => console.warn(`[WARN] ‚ö†Ô∏è: ${message}`),
                        error: (message, errorObj = '') => console.error(`[ERROR] ‚ùå: ${message}`, errorObj)
                    };
                    // --- 4. STATE INITIALIZATION ---
                    this.questions = [];
                    this.isAIProcessing = false;
                    this.jsonForExport = '';
                    this.activeQuestionType = this.QuestionType.MCQ; // Default for simple text
                    this.userExplicitlySelectedType = false;
                    this.customization = { ...this.config.defaults };
                this.sourceIdData = [];
                    this.apiKeys = { gemini: '', openai: '' };
                    this.aiProvider = 'gemini';
                    this.csvData = [];
                    this.hotInstance = null;
                    this.aiTemplateHotInstance = null;
                    this.language = this.config.defaults.lang;
                    this.selectedIndex = -1; // For keyboard navigation in source ID dropdown
                    this.aiAbortController = null;
                    this.validationTimeout = null;
                    this.autoSaveTimeout = null;
                    this.uploadedImageBase64 = null;
                    this.subjectTemplateMap = {
                        "ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°": "352108393701",
                        "ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™": "357135867402",
                        "ÿßŸÑÿπŸÑŸàŸÖ": "352108393701",
                        "ÿßŸÑÿπŸÑŸàŸÖ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©": "352108393701",
                        "ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ°": "352108393701",
                        "ÿßŸÑŸÉŸäŸÖŸäÿßÿ°": "352108393701",
                        "ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©": "248170436092",
                        "ÿßŸÉÿ™ÿ¥ŸÅ": "248170436092",
                        "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ": "750162567617",
                        "ÿßŸÑÿ¨ÿ∫ÿ±ÿßŸÅŸäÿß": "257121690289",
                        "ÿßŸÑÿØÿ±ÿßÿ≥ÿßÿ™ ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿ©": "738178680941",
                        "ÿßŸÑŸÅŸÑÿ≥ŸÅÿ© ŸàÿßŸÑŸÖŸÜÿ∑ŸÇ": "186183541809",
                        "ÿπŸÑŸÖ ÿßŸÑŸÜŸÅÿ≥ ŸàÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ": "457197047804",
                        "Biologie": "352108393701",
                        "Biology": "352108393701",
                        "Chemistry": "352108393701",
                        "Connect Plus": "892167914601",
                        "Discover": "352108393701",
                        "Integrated Science": "352108393701",
                        "Mathematics": "357135867402",
                        "Physics": "352108393701",
                        "Science": "352108393701",
                        "Sciences": "352108393701",
                        "German": "302173902420",
                        "Espa√±ol": "705191491837",
                        "Italiano": "483102623591",
                        "Fran√ßais": "157146025321"
                    };
                    // English templates - multiple template IDs for frq_ai only (string uses fixed 593158513739)
                    this.englishTemplatesByStage = {
                        "High_School": [
                            { id: "637187696340", type: "Literature_The_Count_of_Monte_Cristo", displayName: "Literature - The Count of Monte Cristo", fullName: "English_High_School_Literature_The_Count_of_Monte_Cristo" },
                            { id: "745101529785", type: "Literature_The_Old_Man_and_the_Sea", displayName: "Literature - The Old Man and the Sea", fullName: "English_High_School_Literature_The_Old_Man_and_the_Sea" },
                            { id: "470163420236", type: "Literature_Around_the_World_in_Eighty_Days", displayName: "Literature - Around the World in Eighty Days", fullName: "English_High_School_Literature_Around_the_World_in_Eighty_Days" },
                            { id: "328173624946", type: "Full_Writing_Task", displayName: "Full Writing Task", fullName: "English_High_School_Full_Writing_Task" },
                            { id: "968102871405", type: "Simple_Sentences", displayName: "Simple Sentences", fullName: "English_High_School_Simple_Sentences" },
                            { id: "683175613968", type: "Broken_Task", displayName: "Broken Task", fullName: "English_High_School_Broken_Task" },
                            { id: "358156064976", type: "Literature", displayName: "Literature", fullName: "English_High_School_Literature" },
                            { id: "604179454327", type: "Broken_Task_Radwa", displayName: "Broken Task Radwa", fullName: "English_High_School_Broken_Task Radwa" }
                        ],
                        "Middle_School": [
                            { id: "467136580630", type: "Full_Writing_Task", displayName: "Full Writing Task", fullName: "English_Middle_School_Full_Writing_Task" },
                            { id: "547160780494", type: "Simple_Sentences", displayName: "Simple Sentences", fullName: "English_Middle_School_Simple_Sentences" },
                            { id: "152105705184", type: "Dialogue_Completion", displayName: "Dialogue Completion", fullName: "English_Middle_School_Dialogue_Completion" },
                            { id: "189103419047", type: "Reading_Comprehension", displayName: "Reading Comprehension", fullName: "English_Middle_School_Reading_Comprehension" },
                            { id: "707183083536", type: "Broken_Task", displayName: "Broken Task", fullName: "English_Middle_School_Broken_Task" }
                        ],
                        "Lower_Primary": [
                            { id: "892167914601", type: "Full_Writing_Task", displayName: "Full Writing Task", fullName: "English_Lower_Primary_Full_Writing_Task" },
                            { id: "650142506209", type: "Simple_Sentences", displayName: "Simple Sentences", fullName: "English_Lower_Primary_Simple_Sentences" },
                            { id: "232168416827", type: "Reading_Comprehension", displayName: "Reading Comprehension", fullName: "English_Lower_Primary_Reading_Comprehension" },
                            { id: "107194547831", type: "Broken_Task", displayName: "Broken Task", fullName: "English_Lower_Primary_Broken_Task" }
                        ],
                        "Upper_Primary": [
                            { id: "973160802168", type: "Simple_Sentences", displayName: "Simple Sentences", fullName: "English_Upper_Primary_Simple_Sentences" },
                            { id: "458121578659", type: "Reading_Comprehension", displayName: "Reading Comprehension", fullName: "English_Upper_Primary_Reading_Comprehension" },
                            { id: "585170852819", type: "Full_Writing_Task", displayName: "Full Writing Task", fullName: "English_Upper_Primary_Full Writing_Task" },
                            { id: "179150486393", type: "Broken_Task", displayName: "Broken Task", fullName: "English_Upper_Primary_Broken_Task" }
                        ]
                    };
                    this.selectedEnglishStage = null; // Track selected English stage
                    this.questionTemplateSelections = {}; // Store user template selections per question
                    this.questionOQDirections = {}; // Store OQ direction selections per question

                    // Function to get stage from grade
                    this.getStageFromGrade = (grade) => {
                        const gradeNum = parseInt(grade);
                        if (gradeNum >= 1 && gradeNum <= 3) return "Lower_Primary";
                        if (gradeNum >= 4 && gradeNum <= 6) return "Upper_Primary";
                        if (gradeNum >= 7 && gradeNum <= 9) return "Middle_School";
                        if (gradeNum >= 10 && gradeNum <= 12) return "High_School";
                        return null;
                    };

                    // Grade mapping with feedback dialect, language level, and age
                    this.gradeMapping = {
                        "1": { dialect: "American English", level: "A1", age: "6-7" },
                        "2": { dialect: "American English", level: "A1", age: "7-8" },
                        "3": { dialect: "American English", level: "A1", age: "8-9" },
                        "4": { dialect: "American English", level: "A2", age: "9-10" },
                        "5": { dialect: "American English", level: "A2", age: "10-11" },
                        "6": { dialect: "American English", level: "A2", age: "11-12" },
                        "7": { dialect: "American English", level: "A2", age: "12-13" },
                        "8": { dialect: "American English", level: "B1", age: "13-14" },
                        "9": { dialect: "American English", level: "B1", age: "14-15" },
                        "10": { dialect: "American English", level: "B1", age: "15-16" },
                        "11": { dialect: "American English", level: "B2", age: "16-17" },
                        "12": { dialect: "American English", level: "B2", age: "17-18" }
                    };
                    // Bootstrapping handled in async init()
                }

                async init() {
                    try {
                        this.loadSettings();
                        this.loadApiKeys();
                        this.renderQuestionTypeButtons();
                        this.loadAutoSavedContent();
                        this.populateTagsModal();
                        this.populateGenerationModal();
                        this.setActiveQuestionType(this.activeQuestionType);
                        this.updateInterfaceLanguage();
                        this.bindEvents();
                        this._updateApiProviderUI();
                        await this.loadSourceData();
                        this.populateSourceIdDropdown();
                        this.logger.info("Application initialized successfully.");
                    } catch (error) {
                        this.logger.error('Application initialization failed', error);
                    }
                }

                async loadSourceData() {
                    try {
                        const response = await fetch('data/sources.json');
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        if (Array.isArray(data)) {
                            this.sourceIdData = data;
                        } else {
                            this.sourceIdData = [];
                            console.error('Failed to load sources:', new Error('Invalid sources format'));
                        }
                    } catch (error) {
                        console.error('Failed to load sources:', error);
                        this.sourceIdData = [];
                    }
                }

                getInputText() {
                    // Get value from hidden textarea (synced by RichTextManager)
                    const hiddenInput = document.getElementById('hiddenQuestionInput');
                    if (hiddenInput) {
                        return hiddenInput.value || '';
                    }
                    // Fallback to global function
                    return getQuestionInputValue() || '';
                }
                setInputText(text) {
                    const safe = typeof text === 'string' ? text : '';
                    // Set value in RichTextManager if available
                    if (window.richTextManager) {
                        window.richTextManager.setValue(safe);
                    }
                    // Also update hidden textarea
                    const hiddenInput = document.getElementById('hiddenQuestionInput');
                    if (hiddenInput) {
                        hiddenInput.value = safe;
                        // Dispatch input event to trigger legacy handlers
                        hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    // Fallback to global function
                    setQuestionInputValue(safe);
                }
                // Safe HTML setter (global sanitizer)
                setSafeHTML(el, html) {
                    const safe = DOMPurify.sanitize(html, {
                        ALLOWED_TAGS: ['b', 'strong', 'i', 'em', 'u', 's', 'strike', 'sub', 'sup', 'span', 'p', 'div', 'br', 'h1', 'h3', 'blockquote', 'math-field', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'colgroup', 'col'],
                        ALLOWED_ATTR: ['style', 'class', 'dir', 'contenteditable', 'default-mode', 'value', 'colspan', 'rowspan'],
                        ALLOW_DATA_ATTR: true,
                        ALLOW_CUSTOM_ELEMENTS: true,
                        // ÿ•ÿ∂ÿßŸÅÿ© ÿ¨ŸÖŸäÿπ tags ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
                        ADD_TAGS: [
                            'math-field', 'span', 'p', 'div', 'strong', 'ul', 'u', 'li',
                            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'br', 'b', 'article',
                            'em', 'i', 's', 'strike', 'sub', 'sup', 'blockquote',
                            'hr', 'code', 'pre', 'mark', 'small', 'del', 'ins'
                        ],
                        ADD_ATTR: [
                            'value', 'locale', 'lang', 'class', 'dir', 'style',
                            'data-node-type', 'data-node-variation', 'title', 'aria-label',
                            'data-question-id', 'data-part-index', 'data-field-type',
                            'data-choice-index', 'data-math-index', 'default-mode',
                            'data-tag', 'data-interactive', 'color', 'background-color',
                            'text-align', 'font-family', 'font-size', 'font-weight',
                            'text-decoration', 'text-transform'
                        ]
                    });
                    el.innerHTML = safe;
                }
                setLoading(isLoading, textAr = 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ...', textEn = 'Analyzing...') {
                    const loading = document.getElementById('loading');
                    const loadingText = document.getElementById('loading-text');
                    loading.style.display = isLoading ? 'block' : 'none';
                    loadingText.textContent = this.language === this.Language.ARABIC ? textAr : textEn;
                }
                bindEvents() {
                    document.getElementById('smart-analyze-btn').addEventListener('click', () => this.smartAnalyze());
                    document.getElementById('aiEnhanceBtn').addEventListener('click', () => this.enhanceWithAI());
                    document.getElementById('convert-json-btn').addEventListener('click', () => this.convertToJSON());
                    document.getElementById('clear-all-btn').addEventListener('click', () => this.clearAll());
                    document.getElementById('langSwitchBtn').addEventListener('click', () => this.toggleLanguage());
                    document.getElementById('copyBtn').addEventListener('click', () => this.copyJSON());
                    document.getElementById('downloadBtn').addEventListener('click', () => this.downloadJSON());
                    document.getElementById('downloadZipBtn').addEventListener('click', () => this.downloadZip());
                    document.getElementById('csvBtn').addEventListener('click', () => this.openCSVModal());
                    document.getElementById('csv-modal-close-btn').addEventListener('click', () => this.closeCSVModal());
                    document.getElementById('csv-save-btn').addEventListener('click', () => this.saveCSVData());
                    document.getElementById('csv-close-btn').addEventListener('click', () => this.closeCSVModal());

                    // API Provider and Keys
                    document.getElementById('aiProviderSelect').addEventListener('change', (e) => this.setAIProvider(e.target.value));
                    document.getElementById('geminiApiKey').addEventListener('input', (e) => this.saveApiKeys('gemini', e.target.value));
                    document.getElementById('openaiApiKey').addEventListener('input', (e) => this.saveApiKeys('openai', e.target.value));

                    // Source ID change event is now handled in populateSourceIdDropdown()

                    // Customize Modal Events
                    document.getElementById('customizeBtn').addEventListener('click', () => this.openCustomizeModal());
                    document.getElementById('customize-modal-close-btn').addEventListener('click', () => this.closeCustomizeModal());
                    document.getElementById('customize-save-btn').addEventListener('click', () => this.saveCustomization());
                    document.getElementById('subjectTemplateBtn').addEventListener('click', () => this.openSubjectTemplateModal());

                    // Tags Modal Events
                    document.getElementById('tagsBtn').addEventListener('click', () => this.toggleTagsModal());
                    document.getElementById('tags-modal-close-btn').addEventListener('click', () => this.toggleTagsModal(false));
                    this.makeModalDraggable();

                    // Generation Modal Events
                    document.getElementById('generate-questions-btn').addEventListener('click', () => this.openGenerationModal());
                    document.getElementById('modal-cancel-btn').addEventListener('click', () => this.closeGenerationModal());
                    document.getElementById('modal-generate-btn').addEventListener('click', () => this.generateQuestionsWithAI());
                    this.setupImageDropZone();

                    // Auto-Save and Live Validation Event
                    // Listen to hidden textarea (synced by RichTextManager) for legacy compatibility
                    const hiddenInput = document.getElementById('hiddenQuestionInput');
                    if (hiddenInput) {
                        hiddenInput.addEventListener('input', () => {
                            clearTimeout(this.autoSaveTimeout);
                            this.autoSaveTimeout = setTimeout(() => this.autoSaveContent(), 1000);

                            clearTimeout(this.validationTimeout);
                            this.validationTimeout = setTimeout(() => this.runLiveValidation(), 500);
                        });
                    }
                    
                    // Also listen to editor directly as backup
                    const questionInputEditor = document.getElementById('questionInput-editor');
                    if (questionInputEditor) {
                        questionInputEditor.addEventListener('input', () => {
                            clearTimeout(this.autoSaveTimeout);
                            this.autoSaveTimeout = setTimeout(() => this.autoSaveContent(), 1000);

                            clearTimeout(this.validationTimeout);
                            this.validationTimeout = setTimeout(() => this.runLiveValidation(), 500);
                        });
                    }


                    // Subject Template ID Modal Events
                    document.getElementById('subject-template-modal-close-btn').addEventListener('click', () => this.closeSubjectTemplateModal());
                    document.getElementById('subject-template-save-btn').addEventListener('click', () => this.saveSubjectTemplateData());
                    document.getElementById('subject-template-close-btn').addEventListener('click', () => this.closeSubjectTemplateModal());
                    document.getElementById('subjectSelect').addEventListener('change', () => this.updateSubjectQuestionsPreview());
                    document.getElementById('englishStageSelect').addEventListener('change', (e) => {
                        const selectedGrade = e.target.value;
                        this.selectedEnglishStage = selectedGrade;

                        // Update all FRQ_AI questions with grade metadata ONLY for English subject
                        if (selectedGrade) {
                            const stage = this.getStageFromGrade(selectedGrade);
                            const gradeInfo = this.gradeMapping[selectedGrade];
                            const selectedSubject = document.getElementById('subjectSelect')?.value;

                            if (gradeInfo && selectedSubject === 'English') {
                                this.questions.forEach(question => {
                                    question.metadata.subject = 'English';
                                    question.parts.forEach(part => {
                                        if (part.type === this.QuestionType.FRQ_AI) {
                                            part.metadata.subject = 'English';
                                            part.metadata.feedback_dialect = gradeInfo.dialect;
                                            part.metadata.language_level = gradeInfo.level;
                                        }
                                    });
                                });

                                // Re-render to update preview
                                this.displayResults();

                                // Update JSON if visible
                                if (document.getElementById('jsonOutput').style.display === 'block') {
                                    this.convertToJSON();
                                }
                            }
                        }

                        this.updateSubjectQuestionsPreview();
                    });

                    // Modal ESC close
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            if (document.getElementById('csvModalBg').style.display === 'flex') this.closeCSVModal();
                            if (document.getElementById('customizeModal').style.display === 'flex') this.closeCustomizeModal();
                            if (document.getElementById('subjectTemplateModalBg').style.display === 'flex') this.closeSubjectTemplateModal();
                            if (document.getElementById('tagsModal').style.display === 'flex' || document.getElementById('tagsModal').style.display === 'block') this.toggleTagsModal(false);
                            if (document.getElementById('generationModalBg').style.display === 'flex') this.closeGenerationModal();
                        }
                    });
                    // Focus trap for open modals
                    document.addEventListener('keydown', (e) => {
                        if (e.key !== 'Tab') return;
                        const openModals = [
                            document.getElementById('generationModalBg').style.display === 'flex' && document.getElementById('generationModal'),
                            document.getElementById('csvModalBg').style.display === 'flex' && document.getElementById('csvModal'),
                            document.getElementById('aiTemplateModalBg').style.display === 'flex' && document.getElementById('aiTemplateModal'),
                            document.getElementById('subjectTemplateModalBg').style.display === 'flex' && document.getElementById('subjectTemplateModal'),
                            document.getElementById('customizeModal').style.display === 'flex' && document.getElementById('customizeModal'),
                            (document.getElementById('tagsModal').style.display === 'flex' || document.getElementById('tagsModal').style.display === 'block') && document.getElementById('tagsModal')
                        ].filter(Boolean);
                        if (openModals.length === 0) return;
                        const modal = openModals[0];
                        const focusable = modal.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])');
                        if (focusable.length === 0) return;
                        const first = focusable[0];
                        const last = focusable[focusable.length - 1];
                        const active = document.activeElement;
                        if (e.shiftKey) {
                            if (active === first) { e.preventDefault(); last.focus(); }
                        } else {
                            if (active === last) { e.preventDefault(); first.focus(); }
                        }
                    });
                    document.getElementById('questionsPreview').addEventListener('click', (event) => {
                        const actionTarget = event.target.closest('.action-btn, .btn-save-edit, .btn-cancel-edit');
                        if (actionTarget) {
                            const questionPreview = actionTarget.closest('.question-preview');
                            if (!questionPreview) return;
                            const questionId = questionPreview.dataset.id;
                            if (actionTarget.classList.contains('delete-btn')) this.deleteQuestion(questionId);
                            else if (actionTarget.classList.contains('edit-btn')) this.startEditQuestion(questionId);
                            else if (actionTarget.classList.contains('btn-save-edit')) this.saveEditQuestion(questionId);
                            else if (actionTarget.classList.contains('btn-cancel-edit')) this.cancelEditQuestion(questionId);
                            return;
                        }

                        const choiceTarget = event.target.closest('.choice-item');
                        const partPreview = event.target.closest('.part-preview');
                        if (choiceTarget && partPreview && partPreview.dataset.interactive === 'true') {
                            this.handleChoiceClick(choiceTarget);
                        }
                    });

                    document.getElementById('questionsPreview').addEventListener('input', (e) => {
                        if (e.target.tagName.toLowerCase() === 'math-field') {
                            this.handleMathFieldInput(e);
                        }
                    });
                }
                renderQuestionTypeButtons() {
                    const container = document.getElementById('questionTypeSelector');
                    if (!container) return;
                    container.innerHTML = '';
                    const configs = {
                        [this.QuestionType.MCQ]: { label: 'MCQ', jsonType: 'mcq' },
                        [this.QuestionType.MRQ]: { label: 'MRQ', jsonType: 'mrq' },
                        [this.QuestionType.MATCHING]: { label: 'Matching', jsonType: 'matching' },
                        [this.QuestionType.GAP_TEXT]: { label: 'Gapped Text', jsonType: 'gapText' },
                        [this.QuestionType.STRING]: { label: 'String', jsonType: 'string' },
                        [this.QuestionType.OQ]: { label: 'Ordering (OQ)', jsonType: 'oq' },
                        [this.QuestionType.FRQ_AI]: { label: 'FRQ (AI)', jsonType: 'frq_ai' },
                        [this.QuestionType.INPUT_BOX]: { label: 'Input Box', jsonType: 'input_box' },
                        [this.QuestionType.UNKNOWN]: { label: 'Unknown', jsonType: 'unknown' } // FIX: Added Unknown type
                    };
                    this.questionTypeConfigs = configs;
                    for (const typeKey in configs) {
                        const config = configs[typeKey];
                        if (typeKey === this.QuestionType.UNKNOWN) continue; // Don't create a button for it
                        const button = document.createElement('button');
                        button.className = 'q-type-btn';
                        button.textContent = config.label;
                        button.dataset.type = typeKey;
                        button.onclick = () => this.setActiveQuestionType(typeKey);
                        container.appendChild(button);
                    }
                }
                setActiveQuestionType(typeKey) {
                    // --- ÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ¨ÿØŸäÿØ: ŸÖŸÜÿ∑ŸÇ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ™ŸÅÿπŸäŸÑ ---
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÖÿß ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ Ÿäÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ≤ÿ± ÿßŸÑŸÜÿ¥ÿ∑ ÿ≠ÿßŸÑŸäŸãÿß ÿ®ÿßŸÑŸÅÿπŸÑ
                    if (this.activeQuestionType === typeKey && this.userExplicitlySelectedType) {

                        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ£ŸÖÿ± ŸÉÿ∞ŸÑŸÉÿå ŸÇŸÖ ÿ®ÿ•ŸÑÿ∫ÿßÿ° ÿ™ŸÜÿ¥Ÿäÿ∑Ÿá ŸàÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ Ÿàÿ∂ÿπ "ÿßŸÑŸÉÿ¥ŸÅ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä"
                        this.userExplicitlySelectedType = false;

                        // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿπŸäŸäŸÜ ÿ•ŸÑŸâ ÿßŸÑŸÜŸàÿπ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑÿßÿ™ÿ≥ÿßŸÇ
                        this.activeQuestionType = this.QuestionType.MCQ;

                        // ÿ•ÿ≤ÿßŸÑÿ© ŸÅÿ¶ÿ© 'active' ŸÖŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸäÿπŸÉÿ≥ ÿßŸÑÿ™ÿ∫ŸäŸäÿ± ÿ®ÿµÿ±ŸäŸãÿß
                        document.querySelectorAll('.q-type-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });

                        return; // ÿßŸÑÿÆÿ±Ÿàÿ¨ ŸÖŸÜ ÿßŸÑÿØÿßŸÑÿ© ŸÑÿ£ŸÜ ŸÖŸáŸÖÿ™ŸÜÿß ÿßŸÜÿ™Ÿáÿ™ ŸáŸÜÿß
                    }
                    // --- ŸÜŸáÿßŸäÿ© ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ¨ÿØŸäÿØ ---

                    // ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑŸÇÿØŸäŸÖ: ŸäÿπŸÖŸÑ ÿπŸÜÿØŸÖÿß Ÿäÿ™ŸÖ ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± ÿ¨ÿØŸäÿØ
                    this.userExplicitlySelectedType = true;
                    this.activeQuestionType = typeKey;

                    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜŸÖÿ∑ ÿßŸÑŸÖÿ±ÿ¶Ÿä ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±
                    document.querySelectorAll('.q-type-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.type === typeKey);
                    });
                }
                // ***************************************************************
                // ** ID & VALIDATION LOGIC **
                // ***************************************************************
                extractDummyIds(content) {
                    const dummyIds = [];
                    const blocks = content.split(/\n---\n/).filter(block => block.trim());
                    blocks.forEach(block => {
                        const lines = block.trim().split('\n');
                        for (const line of lines) {
                            const match = line.match(/^id:\s*(new\w+)/);
                            if (match) { dummyIds.push(match[1]); break; }
                        }
                    });
                    return [...new Set(dummyIds)];
                }
                async promptForOfficialIds(dummyIds) {
                    return new Promise((resolve) => {
                        const modal = document.createElement('div');
                        modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.7); z-index: 9999; display: flex; align-items: center; justify-content: center;`;
                        const dialog = document.createElement('div');
                        dialog.style.cssText = `background: white; padding: 30px; border-radius: 15px; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.3);`;
                        const isAr = this.language === this.Language.ARABIC;
                        dialog.innerHTML = `
                        <h3 style="margin-bottom: 20px; color: #4f46e5;">${isAr ? `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ${dummyIds.length} ŸÖÿπÿ±ŸÅ ŸàŸáŸÖŸä` : `Found ${dummyIds.length} dummy IDs`}</h3>
                        <p style="margin-bottom: 20px;">${isAr ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑÿ±ÿ≥ŸÖŸäÿ© (12 ÿ±ŸÇŸÖ ŸÑŸÉŸÑ ŸÖÿπÿ±ŸÅ):' : 'Please enter official IDs (12 digits each):'}</p>
                        <div id="idInputs" style="margin-bottom: 20px;"></div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelIds" class="btn btn-secondary">${isAr ? 'ÿ•ŸÑÿ∫ÿßÿ°' : 'Cancel'}</button>
                            <button id="confirmIds" class="btn btn-primary">${isAr ? 'ÿ™ÿ£ŸÉŸäÿØ' : 'Confirm'}</button>
                        </div>
                    `;
                        const inputsContainer = dialog.querySelector('#idInputs');
                        dummyIds.forEach((dummyId, index) => {
                            const inputDiv = document.createElement('div');
                            inputDiv.style.cssText = 'margin-bottom: 15px; display: flex; align-items: center; gap: 10px;';
                            inputDiv.innerHTML = `<label style="min-width: 100px; font-weight: bold;">${dummyId}:</label>
                            <input type="text" id="officialId_${index}" placeholder="123456789012" maxlength="12" style="flex: 1; padding: 8px; border: 2px solid #e5e7eb; border-radius: 6px;">`;
                            inputsContainer.appendChild(inputDiv);
                        });
                        modal.appendChild(dialog);
                        document.body.appendChild(modal);
                        const cleanup = () => document.body.removeChild(modal);
                        dialog.querySelector('#confirmIds').onclick = () => {
                            const mapping = {}; let valid = true; const usedIds = new Set();
                            dummyIds.forEach((dummyId, index) => {
                                const input = document.getElementById(`officialId_${index}`);
                                const value = input.value.trim();
                                if (!/^\d{12}$/.test(value)) { input.style.borderColor = '#ef4444'; valid = false; }
                                else if (usedIds.has(value)) { input.style.borderColor = '#f59e0b'; valid = false; this.showMessage(isAr ? 'ŸÖÿπÿ±ŸÅÿßÿ™ ŸÖŸÉÿ±ÿ±ÿ©!' : 'Duplicate IDs!', 'error'); }
                                else { input.style.borderColor = '#10b981'; mapping[dummyId] = value; usedIds.add(value); }
                            });
                            if (valid) { cleanup(); resolve(mapping); }
                        };
                        dialog.querySelector('#cancelIds').onclick = () => { cleanup(); resolve(null); };
                    });
                }
                // ***************************************************************
                // ** PARSING & AI LOGIC **
                // ***************************************************************
                buildAdvancedFormattingPrompt(rawText, forcedType = null) {
                    const isArabic = this.language === this.Language.ARABIC;

                    const examples = `
ŸÖÿ´ÿßŸÑ MCQ (ŸÜÿ¨ŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑):
type: mcq
@STEM
ŸÖÿß ÿπÿßÿµŸÖÿ© ŸÅÿ±ŸÜÿ≥ÿßÿü
@CHOICES
- ŸÑŸÜÿØŸÜ
* ÿ®ÿßÿ±Ÿäÿ≥
- ŸÖÿØÿ±ŸäÿØ
---
ŸÖÿ´ÿßŸÑ ÿµŸàÿßÿ® ÿ£ŸÖ ÿÆÿ∑ÿ£:
type: mcq
@STEM
ŸáŸÑ ÿ®ÿßÿ±Ÿäÿ≥ ÿπÿßÿµŸÖÿ© ŸÅÿ±ŸÜÿ≥ÿßÿü ÿµŸàÿßÿ® ÿ£ŸÖ ÿÆÿ∑ÿ£ÿü
@CHOICES
* ÿµŸàÿßÿ®
- ÿÆÿ∑ÿ£
---
ŸÖÿ´ÿßŸÑ MRQ (ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÜÿ¨ŸÖÿ©):
type: mrq
@STEM
ÿßÿÆÿ™ÿ± ŸÉŸÑ ÿßŸÑŸÑÿ∫ÿßÿ™ ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ©:
@CHOICES
* Python
- HTML
* JavaScript
---
ŸÖÿ´ÿßŸÑ Matching:
type: matching
@STEM
ÿµŸÑ ÿßŸÑÿØŸàŸÑ ÿ®ÿπŸàÿßÿµŸÖŸáÿß:
@MATCHING_PAIRS
ŸÅÿ±ŸÜÿ≥ÿß | ÿ®ÿßÿ±Ÿäÿ≥
ÿ£ŸÑŸÖÿßŸÜŸäÿß | ÿ®ÿ±ŸÑŸäŸÜ
---
ŸÖÿ´ÿßŸÑ GapText:
type: gapText
@STEM
ÿßŸÑŸÉŸàŸÉÿ® @BLANK ŸáŸà ÿßŸÑÿ£ŸÉÿ®ÿ± ŸàŸÑŸá @BLANK ŸÇŸÖÿ±ÿßŸã.
@GAPS
ÿßŸÑŸÖÿ¥ÿ™ÿ±Ÿä
79
---
ŸÖÿ´ÿßŸÑ ŸÖÿπÿßÿØŸÑÿ© ŸÖÿπŸÇÿØÿ©:
type: string
@STEM
ÿ£Ÿàÿ¨ÿØ ÿ≠ŸÑ ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿßŸÑŸä:
\`\`
\\begin{cases} x+y=5 \\\\ x-y=1 \\end{cases}
\`\`
@ANSWER
x=3, y=2
---
ŸÖÿ´ÿßŸÑ String ŸÖÿπ AI Guidelines:
type: string
ai_template_id: 593158513739
@STEM
ÿßÿ∞ŸÉÿ± ÿπÿßÿµŸÖÿ© ŸÅÿ±ŸÜÿ≥ÿß
@ANSWER
ÿ®ÿßÿ±Ÿäÿ≥
@GUIDELINES
ÿ®ÿßÿ±Ÿäÿ≤ - 1 - ŸÉÿ™ÿßÿ®ÿ© ŸÇÿ±Ÿäÿ®ÿ© ŸÖŸÜ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
Paris - 0 - ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©
---
ŸÖÿ´ÿßŸÑ OQ (ÿ™ÿ±ÿ™Ÿäÿ®):
type: oq
@STEM
ÿ±ÿ™Ÿëÿ® ÿßŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑÿ™ÿßŸÑŸäÿ© ÿ≤ŸÖŸÜŸäÿßŸã:
@CHOICES
- ÿßŸÑÿ´Ÿàÿ±ÿ© ÿßŸÑŸÅÿ±ŸÜÿ≥Ÿäÿ©
- ÿßŸÑÿ≠ÿ±ÿ® ÿßŸÑÿπÿßŸÑŸÖŸäÿ© ÿßŸÑÿ£ŸàŸÑŸâ
- ÿßŸÑÿ≠ÿ±ÿ® ÿßŸÑÿπÿßŸÑŸÖŸäÿ© ÿßŸÑÿ´ÿßŸÜŸäÿ©
---
ŸÖÿ´ÿßŸÑ Input Box (ÿ£ŸÜŸàÿßÿπ ŸÖÿÆÿ™ŸÑŸÅÿ©):
type: input_box
@STEM
ŸÖÿß ŸáŸä ŸÇŸäŸÖÿ© œÄ ÿ™ŸÇÿ±Ÿäÿ®ÿßŸãÿü
@ANSWER
3.14
// ÿ≥Ÿäÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ decimal ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã
---
ŸÖÿ´ÿßŸÑ ŸÖÿ™ÿπÿØÿØ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°:
@STATEMENT
ÿßŸÇÿ±ÿ£ ÿßŸÑŸÜÿµ ÿßŸÑÿ™ÿßŸÑŸä ÿ´ŸÖ ÿ£ÿ¨ÿ®:
[ÿßŸÑŸÜÿµ ŸáŸÜÿß]

@PART
type: mcq
@STEM
ŸÖÿß ÿßŸÑŸÅŸÉÿ±ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©ÿü
@CHOICES
* ÿßŸÑŸÅŸÉÿ±ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
- ŸÅŸÉÿ±ÿ© ÿÆÿßÿ∑ÿ¶ÿ©

@PART
type: string
@STEM
ÿßÿ∞ŸÉÿ± ÿ±ÿ£ŸäŸÉ.
@ANSWER
ÿ±ÿ£Ÿä ÿßŸÑÿ∑ÿßŸÑÿ®
---
ŸÖÿ´ÿßŸÑ @BLANK ŸÅŸä MCQ:
type: mcq
@STEM
ÿ£ŸÉŸÖŸÑ: ÿßŸÑÿπÿßÿµŸÖÿ© @BLANK ÿ™ŸÇÿπ ŸÅŸä ÿ£Ÿàÿ±Ÿàÿ®ÿß.
@CHOICES
* ÿ®ÿßÿ±Ÿäÿ≥
- ÿßŸÑŸÇÿßŸáÿ±ÿ©
---
ŸÖÿ´ÿßŸÑ ÿ¥ÿπÿ±:
type: string
@STEM
ÿ≠ŸÑŸÑ ÿßŸÑÿ£ÿ®Ÿäÿßÿ™:
@POEM
ÿ£ÿ±ÿßŸÉ ÿπÿµŸä ÿßŸÑÿØŸÖÿπ ÿ¥ŸäŸÖÿ™ŸÉ ÿßŸÑÿµÿ®ÿ±
ÿ£ŸÖÿß ŸÑŸÑŸáŸàŸâ ŸÜŸáŸä ÿπŸÑŸäŸÉ ŸàŸÑÿß ÿ£ŸÖÿ±
@END_POEM
@ANSWER
ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ ŸáŸÜÿß
---
`;
                    let typeInstruction = '1.  **ÿ≠ÿØÿØ ŸÜŸàÿπ** ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ŸÖÿ≠ÿ™ŸàÿßŸá.'; // ÿØŸä ÿßŸÑÿ¨ŸÖŸÑÿ© ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©
                    if (forcedType && forcedType !== 'unknown') {
                        typeInstruction = `ŸÖŸáŸÖÿ™ŸÉ ŸáŸä ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜÿµ ÿßŸÑÿ™ÿßŸÑŸä **ŸÉŸÜŸàÿπ ÿ≥ÿ§ÿßŸÑ ${forcedType}** ÿ®ÿ¥ŸÉŸÑ ÿ•ŸÑÿ≤ÿßŸÖŸä. ŸÑÿß ÿ™ÿ≠ÿßŸàŸÑ ÿ™ÿÆŸÖŸäŸÜ ÿ£Ÿà ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿ£Ÿä ŸÜŸàÿπ ÿ¢ÿÆÿ±.`;
                    }

                    const basePromptAr = `
ÿ£ŸÜÿ™ ÿ£ÿØÿßÿ© ÿØŸÇŸäŸÇÿ© ŸÑÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑŸÜÿµŸàÿµ ÿ•ŸÑŸâ ÿ™ŸÜÿ≥ŸäŸÇ ŸÖÿ≠ÿØÿØ. ŸÖŸáŸÖÿ™ŸÉ ÿßŸÑŸàÿ≠ŸäÿØÿ© ŸáŸä ÿ™ÿ≠ÿØŸäÿØ ÿ£ÿ¨ÿ≤ÿßÿ° ÿßŸÑŸÜÿµ (ÿßŸÑÿ≥ÿ§ÿßŸÑÿå ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ÿå ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©.. ÿ•ŸÑÿÆ) ŸàŸàÿ∂ÿπ ÿßŸÑŸàÿ≥ŸàŸÖ (Tags) ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© ÿ≠ŸàŸÑŸáÿß.

**ŸÖŸáŸÖ ÿ¨ÿØŸãÿß: ŸÑÿß ÿ™ŸÇŸÖ ÿ®ÿ™ÿ∫ŸäŸäÿ±ÿå ÿ£Ÿà ÿ™ÿµÿ≠Ÿäÿ≠ÿå ÿ£Ÿà ÿ•ÿ∂ÿßŸÅÿ©ÿå ÿ£Ÿà ÿ≠ÿ∞ŸÅ ÿ£Ÿä ÿ¨ÿ≤ÿ° ŸÖŸÜ ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä ÿ•ÿ∑ŸÑÿßŸÇŸãÿß.** ÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸàÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ£ÿµŸÑŸä ÿ™ŸÖÿßŸÖŸãÿß ŸÉŸÖÿß ŸáŸà. Ÿàÿ∏ŸäŸÅÿ™ŸÉ ŸáŸä ŸÅŸÇÿ∑ ÿ™ÿ∑ÿ®ŸäŸÇ ŸáŸäŸÉŸÑ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.

**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©:**
${typeInstruction}

2.  **ÿ£ÿÆÿ±ÿ¨ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ ÿ®ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿ™ÿßŸÑŸä ÿØŸàŸÜ ÿ£Ÿä ÿ™ÿ∫ŸäŸäÿ± ŸÅŸä ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ:**
    -   ÿ≥ÿ∑ÿ± ÿ®ŸäÿßŸÜÿßÿ™ ŸàÿµŸÅŸäÿ© ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâÿå ŸÖÿ´ÿßŸÑ: \`type: mcq\` ÿ£Ÿà \`ai_template_id: 593158513739\`
    -   Ÿàÿ≥ŸÖ \`@STEM\` ŸÑŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä.
    -   Ÿàÿ≥ŸàŸÖ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ≠ÿ≥ÿ® ŸÜŸàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ (\`@CHOICES\`, \`@MATCHING_PAIRS\`, \`@GAPS\`, \`@ANSWER\`, \`@GUIDELINES\`).
    -   **ŸÖŸáŸÖ ÿ¨ÿØÿßŸã:** ÿ•ÿ∞ÿß Ÿàÿ¨ÿØÿ™ Ÿàÿ≥ŸÖ \`@GUIDELINES\` ŸÅŸä ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸäÿå Ÿäÿ¨ÿ® ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸäŸá ÿ™ŸÖÿßŸÖÿßŸã ŸÉŸÖÿß ŸáŸà ÿØŸàŸÜ ÿ£Ÿä ÿ™ÿ∫ŸäŸäÿ±.
    -   ÿßÿ≥ÿ™ÿÆÿØŸÖ \`---\` ŸÑŸÑŸÅÿµŸÑ ÿ®ŸäŸÜ ŸÉŸÑ ÿ≥ÿ§ÿßŸÑ Ÿàÿ¢ÿÆÿ±.

**ŸÇŸàÿßÿπÿØ ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© (ŸÖŸáŸÖ):**
-   **MCQ/MRQ:** ÿßÿ≥ÿ™ÿÆÿØŸÖ \`*\` ŸÇÿ®ŸÑ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© Ÿà \`-\` ŸÇÿ®ŸÑ ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ©. **MCQ** Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÜÿ¨ŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑ÿå ÿ®ŸäŸÜŸÖÿß **MRQ** ŸäŸÖŸÉŸÜ ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÜÿ¨ŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ÿ£Ÿà ÿ£ŸÉÿ´ÿ±.
-   **ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿµŸàÿßÿ® ŸàÿßŸÑÿÆÿ∑ÿ£:** ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ "ÿµŸàÿßÿ® ÿ£ŸÖ ÿÆÿ∑ÿ£"ÿå "ÿÆÿ∑ÿ£ ÿ£ŸÖ ÿµŸàÿßÿ®"ÿå "true or false"ÿå "false or true" Ÿäÿ¨ÿ® ÿ™ŸÜÿ≥ŸäŸÇŸáÿß ŸÉŸÄ MCQ ŸÖÿπ Ÿàÿ∂ÿπ "ÿµŸàÿßÿ®" ÿ£Ÿà "True" ŸÉÿ£ŸàŸÑ ÿßÿÆÿ™Ÿäÿßÿ±.
-   **OQ (ÿ™ÿ±ÿ™Ÿäÿ®):** ÿ¨ŸÖŸäÿπ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ \`-\` (ÿ®ÿØŸàŸÜ ŸÜÿ¨ŸàŸÖ). ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸáŸà ÿ™ÿ±ÿ™Ÿäÿ® ÿ∏ŸáŸàÿ± ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä \`@CHOICES\`.
-   **Matching:** Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿßŸÑÿ£ÿ≤Ÿàÿßÿ¨ ŸÅŸä \`@MATCHING_PAIRS\` ŸÖŸÅÿµŸàŸÑÿ© ÿ®ŸÄ \`|\`.
-   **GapText:** ÿßÿ≥ÿ™ÿÆÿØŸÖ \`@BLANK\` ŸÅŸä ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÑŸÉŸÑ ŸÅÿ¨Ÿàÿ©ÿå Ÿàÿ∂ÿπ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® ŸÅŸä \`@GAPS\`.
-   **Input Box:** ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÅŸä \`@ANSWER\` ÿ®ÿµŸäÿ∫ÿ© \`ÿßŸÑŸÇŸäŸÖÿ© | ÿßŸÑŸàÿ≠ÿØÿ©\` ÿ£Ÿà \`ÿßŸÑŸÇŸäŸÖÿ©\` ŸÅŸÇÿ∑. ÿßŸÑŸÜÿ∏ÿßŸÖ ŸäŸÉÿ™ÿ¥ŸÅ ÿßŸÑŸÜŸàÿπ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã (integer: 42ÿå decimal: 3.14ÿå fraction: 1/2).
-   **String ŸÖÿπ AI Guidelines:** ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÖŸÜ ŸÜŸàÿπ string ŸàŸäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ \`@GUIDELINES\`ÿå ŸÅŸäÿ¨ÿ® ÿßŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ Ÿàÿ≥ŸÖ \`@GUIDELINES\` ŸàŸÉŸÑ ŸÖÿ≠ÿ™ŸàÿßŸá. ŸÉŸÑ ÿ≥ÿ∑ÿ± ŸÅŸä @GUIDELINES Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ÿßŸÑÿµŸäÿ∫ÿ©: \`ÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ® - ÿßŸÑÿØÿ±ÿ¨ÿ© - ÿßŸÑÿ™ÿπŸÑŸäŸÇ\` ÿ≠Ÿäÿ´ ÿßŸÑÿØÿ±ÿ¨ÿ© ÿ•ŸÖÿß 0 ÿ£Ÿà 1.
-   **@BLANK (ŸÇÿßÿπÿØÿ© ÿπÿßŸÖÿ©):** ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ \`@BLANK\` ŸÅŸä ÿ¨ŸÖŸäÿπ ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© - ŸÅŸä GapText ŸÑŸÑŸÅÿ±ÿßÿ∫ÿßÿ™ ÿßŸÑŸÇÿßÿ®ŸÑÿ© ŸÑŸÑŸÖŸÑÿ°ÿå ŸàŸÅŸä ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿÆÿ±Ÿâ ŸÉÿÆÿ∑ ŸÅÿ±ÿßÿ∫. ŸäŸÖŸÉŸÜ ÿ£Ÿäÿ∂ÿßŸã ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ \`____\` (4 ÿÆÿ∑Ÿàÿ∑ ÿ≥ŸÅŸÑŸäÿ© ÿ£Ÿà ÿ£ŸÉÿ´ÿ±) ŸÉÿ®ÿØŸäŸÑ.
-   **ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿπÿØÿØÿ© ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°:** ÿßÿ≥ÿ™ÿÆÿØŸÖ \`@STATEMENT\` ŸÑŸÑŸÖŸÇÿØŸÖÿ© ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉÿ©ÿå ÿ´ŸÖ \`@PART\` ŸÑŸÉŸÑ ÿ¨ÿ≤ÿ° ŸÖÿπ \`type:\` ÿÆÿßÿµ ÿ®Ÿá.
-   **ÿßŸÑÿ¥ÿπÿ±:** ÿßÿ≥ÿ™ÿÆÿØŸÖ \`@POEM\` ŸÑÿ®ÿØÿßŸäÿ© ÿßŸÑÿ¥ÿπÿ± Ÿà \`@END_POEM\` ŸÑŸÑŸÜŸáÿßŸäÿ©. ŸÉŸÑ ÿ®Ÿäÿ™ ŸÅŸä ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑ.
-   **ÿßŸÑÿ™ÿ≥ÿ∑Ÿäÿ±:** ÿßÿ≥ÿ™ÿÆÿØŸÖ \`[U]ÿßŸÑŸÜÿµ[/U]\` ŸÑÿ™ÿ≥ÿ∑Ÿäÿ± ÿßŸÑŸÜÿµŸàÿµ.

**ŸÇŸàÿßÿπÿØ ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ (ŸÖŸáŸÖÿ© ŸÑŸÑÿ∫ÿßŸäÿ© ŸàŸäÿ¨ÿ® ÿßÿ™ÿ®ÿßÿπŸáÿß ÿ®ÿØŸÇÿ©):**
-   **ŸÑÿß ÿ™ŸÇŸÖ ÿ£ÿ®ÿØŸãÿß ÿ®ÿ™ÿπÿØŸäŸÑ** ŸÖÿ≠ÿ™ŸàŸâ ÿ£Ÿà ÿµŸäÿ∫ÿ© ÿ£Ÿä ŸÉŸàÿØ LaTeX.
-   **ÿ≠ŸàŸëŸÑ ÿßŸÑŸÖÿ≠ÿØÿØÿßÿ™ ÿßŸÑÿ≥ÿ∑ÿ±Ÿäÿ© (inline):** ÿ£Ÿä ŸÜÿµ ŸÖÿ≠ÿßÿ∑ ÿ®ŸÄ \`\$...\$\` ÿ£Ÿà \`\\(...\\)\` Ÿäÿ¨ÿ® ŸÑŸÅŸá ÿ®ŸÄ \`...\` (backtick ŸÅÿ±ÿØŸäÿ©).
-   **ÿ≠ŸàŸëŸÑ ÿßŸÑŸÖÿ≠ÿØÿØÿßÿ™ ÿßŸÑÿπÿ±ÿ∂ (display):** ÿ£Ÿä ŸÜÿµ ŸÖÿ≠ÿßÿ∑ ÿ®ŸÄ \`\$\$...\$\$\` ÿ£Ÿà \`\\[...\\]\` Ÿäÿ¨ÿ® ŸÑŸÅŸá ÿ®ŸÄ \`\`...\`\` (backticks ŸÖÿ≤ÿØŸàÿ¨ÿ©).
-   **ÿ≠ŸàŸëŸÑ ÿßŸÑÿ®Ÿäÿ¶ÿßÿ™ ÿßŸÑŸÖÿπŸÇÿØÿ©:** ÿ£Ÿä ŸÉÿ™ŸÑÿ© LaTeX ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ \`\\begin{...}\` Ÿàÿ™ŸÜÿ™ŸáŸä ÿ®ŸÄ \`\\end{...}\` Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸèÿπÿßŸÖŸÑ **ÿØÿßÿ¶ŸÖŸãÿß** ŸÉŸÖÿπÿßÿØŸÑÿ© ÿπÿ±ÿ∂ Ÿàÿ™ŸèŸÑŸÅ ÿ®ŸÄ \`\`...\`\` (backticks ŸÖÿ≤ÿØŸàÿ¨ÿ©).

ŸÑÿß ÿ™ÿÆÿ™ÿ±ÿπ ÿ£Ÿä ŸÖÿ≠ÿ™ŸàŸâ. ÿßÿ™ÿ®ÿπ ÿßŸÑŸÇŸàÿßÿπÿØ ÿ®ÿØŸÇÿ©.


**ŸÜŸÖÿßÿ∞ÿ¨:**
${examples}

**ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿ≠ŸàŸäŸÑŸá:**
${rawText}

**ÿßŸÑŸÜÿßÿ™ÿ¨ ÿßŸÑŸÖŸÜÿ≥ŸÇ:**
`;
                    const basePromptEn = `
You are an expert question formatter and a meticulous academic assistant. Your task is to convert unstructured text into a standardized, structured format.

**Core Instructions:**
1.  **Detect** every question in the text.
2.  **Auto-detect** the type for each question from: mcq, mrq, oq, gapText, matching, string, frq_ai, input_box.
3.  **Format each question as follows:**
    -   A metadata line at the top, e.g., \`type: mcq\` or \`ai_template_id: 593158513739\`
    -   A \`@STEM\` tag for the main question text.
    -   Content tags based on the question type (\`@CHOICES\`, \`@MATCHING_PAIRS\`, \`@GAPS\`, \`@ANSWER\`, \`@GUIDELINES\`).
    -   **Very Important:** If you find a \`@GUIDELINES\` tag in the original text, you MUST preserve it exactly as is without any modification.
    -   Use \`---\` to separate each question.

**Question Type Rules (Important):**
-   **MCQ/MRQ:** Use \`*\` before a correct answer and \`-\` before an incorrect one. **MCQ** must have exactly one star, while **MRQ** can have one or more.
-   **True/False Questions:** Questions containing "true or false", "false or true", "ÿµŸàÿßÿ® ÿ£ŸÖ ÿÆÿ∑ÿ£", "ÿÆÿ∑ÿ£ ÿ£ŸÖ ÿµŸàÿßÿ®" should be formatted as MCQ with "True" or "ÿµŸàÿßÿ®" as the first choice.
-   **OQ (Ordering):** All choices start with \`-\` (no stars). The correct order is the order of appearance in \`@CHOICES\`.
-   **Matching:** Pairs under \`@MATCHING_PAIRS\` must be separated by \`|\`.
-   **GapText:** Use \`@BLANK\` in the stem for each gap, and place the ordered answers under \`@GAPS\`.
-   **Input Box:** Answer in \`@ANSWER\` as \`value | unit\` or just \`value\`. System auto-detects type (integer: 42, decimal: 3.14, fraction: 1/2).
-   **String with AI Guidelines:** If the question is of type string and contains \`@GUIDELINES\`, you MUST preserve the \`@GUIDELINES\` tag and all its content. Each line in @GUIDELINES should follow the format: \`student answer - mark - comment\` where mark is either 0 or 1.
-   **@BLANK (General Rule):** \`@BLANK\` can be used in all question types - in GapText for fillable gaps, in other types as blank lines. Alternative: use \`____\` (4 or more underscores).
-   **Multi-Part Questions:** Use \`@STATEMENT\` for shared introduction, then \`@PART\` for each part with its own \`type:\`.
-   **Poetry:** Use \`@POEM\` to start poetry and \`@END_POEM\` to end. Each verse on a separate line.
-   **Underline:** Use \`[U]text[/U]\` to underline text.

**Mathematics Rules (Crucial and must be followed precisely):**
-   **Never modify** the content or syntax of any LaTeX code.
-   **Convert inline delimiters:** Any text surrounded by \`\$...\$\` or \`\\(...\\)\` must be wrapped with \`...\` (single backticks).
-   **Convert display delimiters:** Any text surrounded by \`\$\$...\$\$\` or \`\\[...\\]\` must be wrapped with \`\`...\`\` (double backticks).
-   **Convert complex environments:** Any LaTeX block that starts with \`\\begin{...}\` and ends with \`\\end{...}\` must **always** be treated as display math and wrapped with \`\`...\`\` (double backticks).

Do not invent any content. Follow the rules precisely.

**Examples:**
${examples}

**Input Text to Convert:**
${rawText}

**Formatted Output:**
`;
                    return isArabic ? basePromptAr : basePromptEn;
                }
                cleanFormattedText(t) {
                    if (!t) return '';
                    let s = t.trim();
                    const fence = s.match(/```[a-zA-Z0-9]*\s*\n([\s\S]*?)\n```/);
                    if (fence) s = fence[1].trim();
                    s = s.replace(/^\s*(Here's the formatted text:|ÿ•ŸÑŸäŸÉ ÿßŸÑŸÜÿµ ÿßŸÑŸÖŸèŸÜÿ≥ŸÇ:|The formatted text is:)\s*/gmi, '');
                    s = s.replace(/\n{3,}/g, '\n\n');
                    return s.trim();
                }

                convertDollarMathToBackticks(text) {
                    if (!text) return text;
                    return text
                        .replace(/\$\$([\s\S]*?)\$\$/g, '``$1``')
                        .replace(/\$([^\$\n]+?)\$/g, '`$1`')
                        .replace(/```math\s*\n([\s\S]*?)\n```/g, '``$1``')
                        .replace(/\\\(([\s\S]*?)\\\)/g, '`$1`');
                }

                autoDetectTypeFromContent(block) {
                    const hasChoices = /@CHOICES/i.test(block);
                    const hasAnswer = /@ANSWER/i.test(block);
                    const hasGaps = /@GAPS/i.test(block) || /@BLANK/i.test(block);
                    const hasMatching = /@MATCHING_PAIRS/i.test(block) || /^\s*.+\s*\|\s*.+$/m.test(block);
                    const starCount = (block.match(/^\s*\*/gm) || []).length;

                    // Check for True/False questions
                    const isTrueFalse = this.isTrueFalseQuestion(block);
                    if (isTrueFalse) return this.QuestionType.MCQ;

                    if (hasMatching) return this.QuestionType.MATCHING;
                    if (hasGaps) return this.QuestionType.GAP_TEXT;
                    if (hasChoices && starCount > 1) return this.QuestionType.MRQ;
                    if (hasChoices && starCount === 1) return this.QuestionType.MCQ;
                    if (hasChoices && starCount === 0) return this.QuestionType.OQ;
                    if (hasAnswer) {
                        const ans = (block.match(/@ANSWER([\s\S]*)$/i) || [, ''])[1].trim();
                        if (/\|/.test(ans)) return this.QuestionType.INPUT_BOX;
                        return ans.split(/\s+/).length > 12 ? this.QuestionType.FRQ_AI : this.QuestionType.STRING;
                    }
                    return this.QuestionType.STRING;
                }

                isTrueFalseQuestion(block) {
                    const stem = (block.match(/@STEM([\s\S]*?)(?=@|$)/i) || [, ''])[1].trim();
                    const trueFalsePatterns = [
                        /^.*ÿµŸàÿßÿ®\s+ÿ£ŸÖ\s+ÿÆÿ∑ÿ£.*$/i,
                        /^.*ÿÆÿ∑ÿ£\s+ÿ£ŸÖ\s+ÿµŸàÿßÿ®.*$/i,
                        /^.*true\s+or\s+false.*$/i,
                        /^.*false\s+or\s+true.*$/i,
                        /^.*ÿµÿ≠Ÿäÿ≠\s+ÿ£ŸÖ\s+ÿÆÿ∑ÿ£.*$/i,
                        /^.*ÿÆÿ∑ÿ£\s+ÿ£ŸÖ\s+ÿµÿ≠Ÿäÿ≠.*$/i
                    ];
                    return trueFalsePatterns.some(pattern => pattern.test(stem));
                }

                organizeTrueFalseChoices(choices, originalAnswers) {
                    // FIX: Removed the '$' from the regex to allow for trailing punctuation like periods.
                    const trueChoices = choices.filter(choice => /^(ÿµŸàÿßÿ®|true|ÿµÿ≠Ÿäÿ≠)/i.test(choice.trim()));
                    const falseChoices = choices.filter(choice => /^(ÿÆÿ∑ÿ£|false|ÿ∫ŸÑÿ∑)/i.test(choice.trim()));

                    // Always put True/ÿµŸàÿßÿ® first, then False/ÿÆÿ∑ÿ£
                    return [...trueChoices, ...falseChoices];
                }

                normalizeOneBlock(block) {
                    // Ensure @STEM
                    if (!/@STEM/i.test(block)) {
                        const lines = block.split('\n').filter(l => l.trim() !== '');
                        const first = lines.shift() || '';
                        block = `@STEM\n${first}\n` + (lines.length ? lines.join('\n') : '');
                    }
                    // Ensure type header
                    if (!/^type:\s*/im.test(block)) {
                        const detected = this.autoDetectTypeFromContent(block);
                        block = `type: ${detected}\n` + block;
                    }
                    return block.trim();
                }

                postProcessAIFormatted(text) {
                    let s = this.cleanFormattedText(text || '');
                    s = this.convertDollarMathToBackticks(s);
                    s = s.replace(/\n---\n(?:\n---\n)+/g, '\n---\n');
                    let blocks = s.split(/\n---\n/).map(b => b.trim()).filter(Boolean);
                    blocks = blocks.map(b => this.normalizeOneBlock(b));
                    return blocks.join('\n---\n');
                }

                async smartAnalyze() {
                    this.logger.info("Starting smart analysis...");
                    const rawText = getQuestionInputValue();
                    if (!rawText.trim()) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÜÿµ ŸÑŸÑÿ™ÿ≠ŸÑŸäŸÑ' : 'Please enter text to analyze', 'warning');
                        return;
                    }
                    this.setLoading(true);
                    try {
                        let textToParse = this.convertDollarMathToBackticks(rawText);

                        const dummyIds = this.extractDummyIds(textToParse);
                        let idMapping = {};
                        if (dummyIds.length > 0) {
                            idMapping = await this.promptForOfficialIds(dummyIds);
                            if (!idMapping) {
                                this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©' : 'Operation cancelled', 'warning');
                                this.setLoading(false);
                                return;
                            }
                        }

                        const questionBlocks = textToParse.trim().split(/\n---\n/);

                        this.questions = questionBlocks.filter(block => block.trim()).map((block, index) => {
                            const q = this._parseQuestionBlock(block, index);
                            if (idMapping[q.metadata.id]) q.metadata.id = idMapping[q.metadata.id];
                            return q;
                        });

                        this.updateUIAfterChange(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ±ŸÅÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠.' : 'Questions uploaded successfully.');
                        this.logger.info(`Analysis complete. Found ${this.questions.length} questions.`);

                    } catch (error) {
                        this.logger.error("Smart Analysis Error:", error);
                        this.showMessage(`${this.language === this.Language.ARABIC ? 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ±ŸÅÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©: ' : 'Error during upload: '}${error.message}`, 'error');
                    } finally {
                        this.setLoading(false);
                    }
                }
                _parseQuestionBlock(block, index) {
                    const lines = block.trim().split('\n');
                    const metadata = {};
                    let contentStartIndex = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        const metaMatch = line.match(/^([a-z_]+):\s*(.*)/i);
                        if (metaMatch && !line.startsWith('[')) {
                            metadata[metaMatch[1].trim().toLowerCase()] = metaMatch[2].trim();
                        } else {
                            contentStartIndex = i;
                            break;
                        }
                    }
                    if (contentStartIndex === lines.length && Object.keys(metadata).length > 0) {
                        contentStartIndex = 0;
                        for (const key in metadata) { delete metadata[key]; }
                    }
                    const contentStr = lines.slice(contentStartIndex).join('\n').trim();
                    const metaHeader = lines.slice(0, contentStartIndex).join('\n') + (contentStartIndex > 0 ? '\n' : '');
                    metadata.id = metadata.id || `temp_${Date.now()}_${index}`;
                    const questionData = {
                        metadata: metadata,
                        statement: null,
                        parts: [],
                        _metaHeader: metaHeader,
                        _contentBlock: contentStr,
                        _editing: false
                    };
                    if (/@STATEMENT/i.test(contentStr) && /@PART/i.test(contentStr)) {
                        const statementMatch = contentStr.match(/@STATEMENT([\s\S]*?)(?=@PART)/i);
                        if (statementMatch) { questionData.statement = statementMatch[1].trim(); }
                        const partRegex = /@PART([\s\S]*?)(?=@PART|$)/gi;
                        const partMatches = contentStr.match(partRegex);
                        if (partMatches) {
                            questionData.parts = partMatches.map(partMatch => {
                                const partContent = partMatch.replace(/^@PART/i, '').trim();
                                return this._parsePartWithTags(partContent, metadata);
                            });
                        }
                        return questionData;
                    }
                    const hasTags = /@(STEM|CHOICES|ANSWER|GAPS|MATCHING_PAIRS)/i.test(contentStr);
                    if (hasTags) {
                        questionData.parts.push(this._parsePartWithTags(contentStr, metadata));
                        return questionData;
                    }
                    questionData.parts.push(this._parsePartSimple(contentStr, metadata));
                    return questionData;
                }
                _parsePartWithTags(partBlock, globalMetadata) {
                    const partMetadata = { ...globalMetadata };
                    const content = {};
                    const mainTags = ['TASK', 'OVERVIEW', 'STEM', 'CHOICES', 'ANSWER', 'GAPS', 'MATCHING_PAIRS', 'GUIDELINES', 'TASK_TARGET', 'OVERALL_TASK_INSTRUCTIONS'];
                    let remainingBlock = partBlock.trim();
                    const lines = remainingBlock.split('\n');
                    let contentStartIndex = 0;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        const metaMatch = line.match(/^([a-z_]+):\s*(.*)/i);
                        if (metaMatch && !line.startsWith('[')) {
                            partMetadata[metaMatch[1].trim().toLowerCase()] = metaMatch[2].trim();
                            contentStartIndex = i + 1;
                        } else {
                            break;
                        }
                    }
                    remainingBlock = lines.slice(contentStartIndex).join('\n');
                    const tagPositions = [];
                    mainTags.forEach(tag => {
                        const regex = new RegExp(`@${tag}`, 'gi');
                        let match;
                        while ((match = regex.exec(remainingBlock)) != null) {
                            tagPositions.push({ tag: tag, index: match.index });
                        }
                    });
                    tagPositions.sort((a, b) => a.index - b.index);
                    for (let i = 0; i < tagPositions.length; i++) {
                        const currentTag = tagPositions[i];
                        const nextTag = tagPositions[i + 1];
                        const start = currentTag.index + `@${currentTag.tag}`.length;
                        const end = nextTag ? nextTag.index : remainingBlock.length;
                        const tagContent = remainingBlock.substring(start, end).trim();
                        content[currentTag.tag] = tagContent;
                    }
                    const part = {
                        type: (partMetadata.type || globalMetadata.type || this.QuestionType.UNKNOWN),
                        stem: content.STEM || '',
                        metadata: partMetadata
                    };
                    this._processTaggedContent(part, content);
                    return part;
                }
                _processTaggedContent(part, content) {
                    const stripBullet = (s) => s.replace(/^\s*(?:\d+[.)]|[A-Za-z\u0621-\u064A][.)]|[-‚Ä¢])\s+/, '');
                    switch (part.type) {
                        case this.QuestionType.OQ:
                        case this.QuestionType.MCQ:
                        case this.QuestionType.MRQ: {
                            const lines = (content.CHOICES || '').split('\n');
                            part.choices = [];
                            const answers = [];
                            lines.forEach((rawLine) => {
                                let line = rawLine.trim();
                                if (!line) return;
                                const isCorrect = line.startsWith('*');
                                if (isCorrect || line.startsWith('-')) line = line.slice(1).trim();
                                line = stripBullet(line);
                                const idx = part.choices.length;
                                part.choices.push(line);
                                if (isCorrect) answers.push(idx);
                            });

                            if (this.isTrueFalseQuestion(`@STEM\n${part.stem}`)) {
                                part.choices = this.organizeTrueFalseChoices(part.choices, answers);
                                if (part.type !== this.QuestionType.OQ) {
                                    const trueIndex = part.choices.findIndex(choice =>
                                        /^(ÿµŸàÿßÿ®|true|ÿµÿ≠Ÿäÿ≠)/i.test(choice.trim()) // FIX 1a: Made regex flexible
                                    );
                                    const falseIndex = part.choices.findIndex(choice =>
                                        /^(ÿÆÿ∑ÿ£|false|ÿ∫ŸÑÿ∑)/i.test(choice.trim()) // FIX 1b: Made regex flexible
                                    );

                                    if (trueIndex !== -1 && falseIndex !== -1) {
                                        const originalTrueAnswer = answers.find(idx =>
                                            /^(ÿµŸàÿßÿ®|true|ÿµÿ≠Ÿäÿ≠)/i.test(lines[idx]?.replace(/^[*-]\s*/, '').trim()) // FIX 2: Made regex flexible
                                        );
                                        part.answer = part.type === this.QuestionType.MCQ ?
                                            (originalTrueAnswer !== undefined ? trueIndex : falseIndex) :
                                            [originalTrueAnswer !== undefined ? trueIndex : falseIndex];
                                    }
                                }
                            } else {
                                if (part.type !== this.QuestionType.OQ) {
                                    part.answer = part.type === this.QuestionType.MCQ ? answers[0] : answers;
                                }
                            }
                            break;
                        }
                        case this.QuestionType.MATCHING: {
                            const pairs = (content.MATCHING_PAIRS || '').split('\n')
                                .map(line => line.trim())
                                .filter(Boolean)
                                .map(line => line.split('|').map(item => item.trim()))
                                .filter(arr => arr.length === 2 && arr[0] && arr[1]);
                            part.pairs = pairs;
                            part.group1 = pairs.map(p => p[0]);
                            part.group2 = pairs.map(p => p[1]);
                            part.answer = pairs.map((_, i) => [i, i]);
                            break;
                        }
                        case this.QuestionType.GAP_TEXT: {
                            const gapAnswers = (content.GAPS || '').split('\n').map(v => v.trim()).filter(Boolean);
                            part.answers = gapAnswers.map((val, i) => {
                                const isCorrect = val.startsWith('*');
                                const cleanValue = isCorrect ? val.substring(1).trim() : val;
                                return {
                                    value: cleanValue,
                                    order: i + 1,
                                    isCorrect: isCorrect
                                };
                            });
                            break;
                        }
                        case this.QuestionType.STRING:
                            part.answer = (content.ANSWER || '').trim();
                            // Process guidelines if present
                            if (content.GUIDELINES) {
                                try {
                                    // Parse guidelines lines into an array of objects
                                    const guidelinesLines = content.GUIDELINES.split('\n')
                                        .map(line => line.trim())
                                        .filter(Boolean);

                                    const guidelines = [];
                                    for (let i = 0; i < guidelinesLines.length; i++) {
                                        // First try the new format: "ÿ¢ÿ¨ÿßÿ®Ÿá ÿßŸÑÿ∑ÿßŸÑÿ® - 1 - ÿ™ÿπŸÑŸäŸÇ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©"
                                        const newFormatParts = guidelinesLines[i].split(' - ').map(p => p.trim());

                                        // If split by " - " gives us exactly 3 parts, process as new format
                                        if (newFormatParts.length === 3) {
                                            const [studentAnswer, mark, comment] = newFormatParts;
                                            if (studentAnswer && mark && comment) {
                                                guidelines.push({
                                                    student_answer: studentAnswer,
                                                    mark: mark,
                                                    comment: comment
                                                });
                                                continue; // Skip to next line after processing
                                            }
                                        }

                                        // Fall back to old format: "student_answer: value | mark: value | comment: value"
                                        const oldFormatParts = guidelinesLines[i].split('|').map(p => p.trim());
                                        const guideline = {};

                                        for (const part of oldFormatParts) {
                                            const [key, value] = part.split(':').map(p => p.trim());
                                            if (key && value) {
                                                guideline[key] = value;
                                            }
                                        }

                                        // Only add if it has the required fields
                                        if (guideline.student_answer && guideline.mark && guideline.comment) {
                                            guidelines.push(guideline);
                                        }
                                    }

                                    if (guidelines.length > 0) {
                                        part.guidelines = guidelines;
                                    }
                                } catch (e) {
                                    console.error('Error parsing guidelines:', e);
                                }
                            }
                            break;
                        case this.QuestionType.FRQ_AI:
                            part.answer = (content.ANSWER || '').trim();
                            // Process task_target and overall_task_instructions if present
                            if (content.TASK_TARGET) {
                                part.metadata.task_target = content.TASK_TARGET.trim();
                            }
                            if (content.OVERALL_TASK_INSTRUCTIONS) {
                                part.metadata.overall_task_instructions = content.OVERALL_TASK_INSTRUCTIONS.trim();
                            }
                            break;
                        case this.QuestionType.INPUT_BOX: {
                            const answerParts = (content.ANSWER || '|').split('|');
                            part.answer = { value: (answerParts[0] || '').trim(), unit: (answerParts[1] || '').trim() };
                            break;
                        }
                    }
                }
                _parsePartSimple(text, metadata) {
                    const stripBullet = (s) => s.replace(/^\s*(?:\d+[.)]|[A-Za-z\u0621-\u064A][.)]|[-‚Ä¢])\s+/, '');
                    const type = (metadata.type || this.activeQuestionType).toLowerCase();
                    let part = { type: type, confidence: 0.85, metadata: metadata };
                    const lines = text.split('\n').map(l => l.trim()).filter(l => l !== '');
                    if (lines.length === 0) {
                        part.stem = text;
                        part.confidence = 0.1;
                        part.choices = [];
                        part.answer = '';
                        part.answers = [];
                        part.group1 = [];
                        part.group2 = [];
                        return part;
                    }
                    part.stem = lines[0].trim();
                    const remainingLines = lines.slice(1);
                    switch (type) {
                        case this.QuestionType.OQ:
                        case this.QuestionType.MCQ:
                        case this.QuestionType.MRQ: {
                            part.choices = [];
                            const answers = [];
                            remainingLines.forEach((line) => {
                                let choiceText = line.trim();
                                if (!choiceText) return;
                                const isCorrect = choiceText.startsWith('*');
                                if (isCorrect || choiceText.startsWith('-')) choiceText = choiceText.slice(1).trim();
                                choiceText = stripBullet(choiceText);
                                const idx = part.choices.length;
                                part.choices.push(choiceText);
                                if (isCorrect) answers.push(idx);
                            });

                            if (this.isTrueFalseQuestion(`@STEM\n${part.stem}`)) {
                                part.choices = this.organizeTrueFalseChoices(part.choices, answers);
                                const trueIndex = part.choices.findIndex(choice =>
                                    /^(ÿµŸàÿßÿ®|true|ÿµÿ≠Ÿäÿ≠)/i.test(choice.trim()) // FIX 1a: Made regex flexible
                                );
                                const falseIndex = part.choices.findIndex(choice =>
                                    /^(ÿÆÿ∑ÿ£|false|ÿ∫ŸÑÿ∑)/i.test(choice.trim()) // FIX 1b: Made regex flexible
                                );

                                if (trueIndex !== -1 && falseIndex !== -1) {
                                    const originalTrueAnswer = answers.find(idx =>
                                        /^(ÿµŸàÿßÿ®|true|ÿµÿ≠Ÿäÿ≠)/i.test(remainingLines[idx]?.replace(/^[*-]\s*/, '').trim()) // FIX 2: Made regex flexible
                                    );
                                    if (type === this.QuestionType.MCQ) {
                                        part.answer = originalTrueAnswer !== undefined ? trueIndex : falseIndex;
                                    } else if (type === this.QuestionType.MRQ) {
                                        part.answer = [originalTrueAnswer !== undefined ? trueIndex : falseIndex];
                                    }
                                }
                            } else {
                                if (type === this.QuestionType.MCQ) part.answer = answers[0];
                                else if (type === this.QuestionType.MRQ) part.answer = answers;
                            }
                            break;
                        }
                        case this.QuestionType.STRING:
                        case this.QuestionType.FRQ_AI:
                            part.answer = remainingLines.join('\n').trim();
                            break;
                        case this.QuestionType.GAP_TEXT: {
                            part.answers = remainingLines.map((val, i) => {
                                const isCorrect = val.startsWith('*');
                                const cleanValue = isCorrect ? val.substring(1).trim() : val;
                                return {
                                    value: cleanValue,
                                    order: i + 1,
                                    isCorrect: isCorrect
                                };
                            });
                            break;
                        }
                        case this.QuestionType.INPUT_BOX: {
                            const answerLine = remainingLines.join(' ').trim();
                            const answerParts = answerLine.split('|');
                            part.answer = { value: (answerParts[0] || '').trim(), unit: (answerParts[1] || '').trim() };
                            break;
                        }
                        case this.QuestionType.MATCHING: {
                            const pairs = remainingLines
                                .map(line => line.split('|').map(item => item.trim()))
                                .filter(arr => arr.length === 2 && arr[0] && arr[1]);
                            part.pairs = pairs;
                            part.group1 = pairs.map(p => p[0]);
                            part.group2 = pairs.map(p => p[1]);
                            part.answer = pairs.map((_, i) => [i, i]);
                            break;
                        }
                    }
                    return part;
                }
                async enhanceWithAI() {
                    const apiKey = this._getApiKey();
                    if (!apiKey) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÖŸÅÿ™ÿßÿ≠ API ÿ£ŸàŸÑÿßŸã' : 'Please enter an API key first', 'warning');
                        return;
                    }
                    const rawText = this.getInputText().trim();
                    if (!rawText) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸÜÿµ ÿ£ŸàŸÑÿßŸã' : 'Please enter text first', 'warning');
                        return;
                    }
                    if (this.isAIProcessing) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä...' : 'AI processing in progress...', 'warning');
                        return;
                    }
                    this.isAIProcessing = true;
                    const enhanceBtn = document.getElementById('aiEnhanceBtn');
                    const originalText = enhanceBtn.innerHTML;
                    enhanceBtn.innerHTML = `<div class="spinner"></div> ${this.language === this.Language.ARABIC ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ...' : 'Formatting...'}`;
                    enhanceBtn.disabled = true;
                    try {
                        let forcedType = null;
                        if (this.userExplicitlySelectedType) {
                            forcedType = this.activeQuestionType;
                        }
                        const prompt = this.buildAdvancedFormattingPrompt(rawText, forcedType);
                        const aiText = await this._callAI(prompt, apiKey);
                        const finalFormatted = this.postProcessAIFormatted(aiText || rawText);
                        if (finalFormatted) {
                            this.setInputText(finalFormatted);
                            this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜÿµ ÿ®ŸÜÿ¨ÿßÿ≠! ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ™ÿ≠ŸÑŸäŸÑŸá.' : 'Text formatted successfully! You can now analyze it.', 'success');
                        } else {
                            this.showMessage(this.language === this.Language.ARABIC ? 'ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜÿµ. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.' : 'Failed to format text. Please try again.', 'error');
                        }
                    } catch (error) {
                        this.logger.error('AI Formatting Error:', error);
                        this.showMessage(`${this.language === this.Language.ARABIC ? 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ: ' : 'Formatting error: '}${error.message}`, 'error');
                    } finally {
                        this.isAIProcessing = false;
                        enhanceBtn.innerHTML = originalText;
                        enhanceBtn.disabled = false;
                    }
                }
                // ***************************************************************
                // ** HTML & JSON TRANSFORMATION LOGIC **
                // ***************************************************************
                convertToJSON() {
                    if (this.questions.length === 0) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑÿ™ÿ≠ŸàŸäŸÑŸáÿß.' : 'No questions to convert.', 'warning');
                        return;
                    }

                    // Check if Source ID is selected
                    const sourceIdSelect = document.getElementById('sourceIdSelect');
                    if (!sourceIdSelect || !sourceIdSelect.value || sourceIdSelect.value.trim() === '' || sourceIdSelect.value === 'none') {
                        this.showMessage(this.language === this.Language.ARABIC ? 'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ•ŸÑŸâ JSON.' : 'Please select a valid Source ID before converting questions to JSON.', 'error');
                        return;
                    }

                    // Comprehensive validation check - must be 100% valid before allowing JSON export
                    // First, validate Source ID
                    const sourceIdValue = sourceIdSelect.value;
                    if (!sourceIdValue || sourceIdValue === 'none') {
                        this.showMessage(this.language === this.Language.ARABIC ? 'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿµÿØŸäÿ±.' : 'Please select a valid Source ID before export.', 'error');
                        return;
                    }

                    // Then, get valid question types
                    const validTypes = Object.values(this.QuestionType).filter(t => t !== this.QuestionType.UNKNOWN);

                    // üÜï Check for duplicate IDs across all questions
                    const questionIds = this.questions.map(q => q.metadata.id);
                    const duplicateIds = questionIds.filter((id, index) => questionIds.indexOf(id) !== index);
                    if (duplicateIds.length > 0) {
                        const errorMsg = `Duplicate question IDs found: ${duplicateIds.join(', ')}`;
                        const errorMsgAr = `ÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿπÿ±ŸÅÿßÿ™ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖŸÉÿ±ÿ±ÿ©: ${duplicateIds.join(', ')}`;
                        this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                        return;
                    }

                    for (let i = 0; i < this.questions.length; i++) {
                        const q = this.questions[i];

                        // üÜï Check ID format (should be 12 digits if not temporary)
                        const id = q.metadata.id;
                        if (id && !id.toString().startsWith('temp_')) {
                            const idStr = id.toString();
                            if (!/^\d{12}$/.test(idStr)) {
                                const errorMsg = `Question ${i + 1}: Invalid ID format "${id}". ID must be exactly 12 digits.`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}: ÿµŸäÿ∫ÿ© ÿßŸÑŸÖÿπÿ±ŸÅ "${id}" ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. ÿßŸÑŸÖÿπÿ±ŸÅ Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 12 ÿ±ŸÇŸÖ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑.`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }
                        }

                        // Check for validation warnings
                        if (q.validationWarning) {
                            const errorMsg = `Question ${i + 1}: ${q.validationWarning}`;
                            const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}: ${q.validationWarning}`;
                            this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                            return;
                        }

                        // Check each part
                        for (let j = 0; j < q.parts.length; j++) {
                            const p = q.parts[j];

                            // Check if type is valid
                            if (!p.type || p.type === this.QuestionType.UNKNOWN || !validTypes.includes(p.type)) {
                                const validTypesStr = validTypes.join(', ');
                                const errorMsg = `Question ${i + 1}, Part ${j + 1}: Invalid question type "${p.type}". Valid types are: ${validTypesStr}`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1}: ŸÜŸàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ "${p.type}" ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠. ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: ${validTypesStr}`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }

                            // Check that stem exists
                            if (!p.stem || p.stem.trim() === '') {
                                const errorMsg = `Question ${i + 1}, Part ${j + 1}: Missing question stem/text.`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1}: ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸÖŸÅŸÇŸàÿØ.`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }

                            // Check choices for types that need them
                            const needsChoices = [this.QuestionType.OQ, this.QuestionType.MCQ, this.QuestionType.MRQ].includes(p.type);
                            if (needsChoices && (!p.choices || p.choices.length === 0)) {
                                const errorMsg = `Question ${i + 1}, Part ${j + 1} (${p.type}): Must have choices.`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (${p.type}): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™.`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }

                            // üÜï Check minimum number of choices (at least 2)
                            if (needsChoices && p.choices && p.choices.length < 2) {
                                const errorMsg = `Question ${i + 1}, Part ${j + 1} (${p.type}): Must have at least 2 choices.`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (${p.type}): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ.`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }

                            // üÜï Check for empty choices
                            if (needsChoices && p.choices) {
                                const emptyChoices = p.choices.filter(c => !c || c.trim() === '');
                                if (emptyChoices.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (${p.type}): Contains empty choices.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (${p.type}): Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÅÿßÿ±ÿ∫ÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // üÜï Check for duplicate choices (exact match)
                            if (needsChoices && p.choices) {
                                const trimmedChoices = p.choices.map(c => c.trim().toLowerCase());
                                const duplicates = trimmedChoices.filter((item, index) => trimmedChoices.indexOf(item) !== index);
                                if (duplicates.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (${p.type}): Contains duplicate choices.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (${p.type}): Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check MCQ has exactly one answer selected
                            if (p.type === this.QuestionType.MCQ) {
                                if (p.answer === undefined || p.answer === null) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MCQ): No correct answer selected.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ŸÖÿ™ÿπÿØÿØ): ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© (*).`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that answer index is within choices range
                                if (p.answer < 0 || p.answer >= p.choices.length) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MCQ): Answer index ${p.answer} is out of range (0-${p.choices.length - 1}).`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ŸÖÿ™ÿπÿØÿØ): ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ${p.answer} ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check MRQ has at least one answer
                            if (p.type === this.QuestionType.MRQ) {
                                if (!Array.isArray(p.answer) || p.answer.length === 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MRQ): Must have at least one correct answer.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ (*).`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that MRQ has more than one correct answer (otherwise should be MCQ)
                                if (p.answer.length === 1) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MRQ): Has only one correct answer. Consider using MCQ instead.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©): Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑. ŸäŸÅÿ∂ŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ MCQ ÿ®ÿØŸÑÿßŸã ŸÖŸÜŸá.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that all answer indices are within choices range
                                const invalidIndices = p.answer.filter(idx => idx < 0 || idx >= p.choices.length);
                                if (invalidIndices.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MRQ): Some answer indices are out of range.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©): ÿ®ÿπÿ∂ ÿ£ÿ±ŸÇÿßŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // üÜï Check OQ (Ordering Questions) - all choices should have no stars
                            if (p.type === this.QuestionType.OQ) {
                                if (!p.choices || p.choices.length < 2) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (OQ): Must have at least 2 items to order.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ÿ±ÿ™Ÿäÿ®): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿπŸÜÿµÿ±ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÑÿ™ÿ±ÿ™Ÿäÿ®.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check STRING has answer
                            if (p.type === this.QuestionType.STRING) {
                                if (!p.answer || p.answer.trim() === '') {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (STRING): Missing answer.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÜÿµ ŸÇÿµŸäÿ±): ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸÅŸÇŸàÿØÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // Check guidelines - REQUIRED for STRING questions
                                if (!p.guidelines || !Array.isArray(p.guidelines) || p.guidelines.length === 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (STRING): Guidelines are required. Add @GUIDELINES with examples.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÜÿµ ŸÇÿµŸäÿ±): ÿßŸÑÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ŸÖÿ∑ŸÑŸàÿ®ÿ©. ÿ£ÿ∂ŸÅ @GUIDELINES ŸÖÿπ ÿ£ŸÖÿ´ŸÑÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                const invalidGuidelines = p.guidelines.filter(g =>
                                    !g.student_answer || g.mark === undefined || !g.comment
                                );
                                if (invalidGuidelines.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (STRING): Invalid guidelines format.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÜÿµ ŸÇÿµŸäÿ±): ÿµŸäÿ∫ÿ© ÿßŸÑÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check FRQ_AI have answers
                            if (p.type === this.QuestionType.FRQ_AI) {
                                if (!p.answer || p.answer.trim() === '') {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (${p.type}): Missing answer.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (${p.type}): ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸÅŸÇŸàÿØÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check FRQ_AI has AI template ID
                            if (p.type === this.QuestionType.FRQ_AI && !p.metadata.ai_template_id) {
                                const errorMsg = `Question ${i + 1}, Part ${j + 1} (frq_ai): Requires an AI Template ID.`;
                                const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (frq_ai): Ÿäÿ™ÿ∑ŸÑÿ® ŸÖÿπÿ±ŸÅ ŸÇÿßŸÑÿ® AI.`;
                                this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                return;
                            }

                            // Check FRQ_AI with Simple_Sentences templates has task_target
                            if (p.type === this.QuestionType.FRQ_AI && p.metadata.ai_template_id) {
                                const simpleSentencesTemplates = ["547160780494", "968102871405", "650142506209", "973160802168"];
                                if (simpleSentencesTemplates.includes(String(p.metadata.ai_template_id))) {
                                    if (!p.metadata.task_target) {
                                        const errorMsg = `Question ${i + 1}, Part ${j + 1} (frq_ai): Simple Sentences templates require task_target.`;
                                        const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (frq_ai): ŸÇŸàÿßŸÑÿ® Simple Sentences ÿ™ÿ™ÿ∑ŸÑÿ® task_target.`;
                                        this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                        return;
                                    }
                                }
                            }

                            // Check MATCHING has valid pairs
                            if (p.type === this.QuestionType.MATCHING) {
                                if (!p.pairs || p.pairs.length === 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MATCHING): No pairs found.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ŸàÿµŸäŸÑ): ŸÑÿß ŸäŸàÿ¨ÿØ ÿ£ÿ≤Ÿàÿßÿ¨.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                                if (p.pairs.some(pair => !Array.isArray(pair) || pair.length !== 2 || !pair[0] || !pair[1])) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MATCHING): Invalid pairs format. Each line must have two items separated by |`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ŸàÿµŸäŸÑ): ÿµŸäÿ∫ÿ© ÿßŸÑÿ£ÿ≤Ÿàÿßÿ¨ ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. ŸÉŸÑ ÿ≥ÿ∑ÿ± Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿπŸÜÿµÿ±ŸäŸÜ ŸÖŸÅÿµŸàŸÑŸäŸÜ ÿ®ŸÄ |`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check for duplicate items in left side
                                const leftItems = p.pairs.map(pair => pair[0].trim().toLowerCase());
                                const duplicateLeft = leftItems.filter((item, index) => leftItems.indexOf(item) !== index);
                                if (duplicateLeft.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MATCHING): Duplicate items found on left side.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ŸàÿµŸäŸÑ): ÿπŸÜÿßÿµÿ± ŸÖŸÉÿ±ÿ±ÿ© ŸÅŸä ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£Ÿäÿ≥ÿ±.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check for duplicate items in right side
                                const rightItems = p.pairs.map(pair => pair[1].trim().toLowerCase());
                                const duplicateRight = rightItems.filter((item, index) => rightItems.indexOf(item) !== index);
                                if (duplicateRight.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MATCHING): Duplicate items found on right side.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ŸàÿµŸäŸÑ): ÿπŸÜÿßÿµÿ± ŸÖŸÉÿ±ÿ±ÿ© ŸÅŸä ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ŸäŸÖŸÜ.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that each pair is unique
                                const pairStrings = p.pairs.map(pair => `${pair[0].trim().toLowerCase()}|${pair[1].trim().toLowerCase()}`);
                                const duplicatePairs = pairStrings.filter((item, index) => pairStrings.indexOf(item) !== index);
                                if (duplicatePairs.length > 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (MATCHING): Duplicate pairs found.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿ™ŸàÿµŸäŸÑ): ÿ£ÿ≤Ÿàÿßÿ¨ ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ© ÿ™ŸÖÿßŸÖÿßŸã.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check GAP_TEXT has gaps
                            if (p.type === this.QuestionType.GAP_TEXT) {
                                if (!p.answers || p.answers.length === 0) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (GAP_TEXT): No gaps/answers found.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÖŸÑÿ° ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™): ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÅÿ±ÿßÿ∫ÿßÿ™/ÿ•ÿ¨ÿßÿ®ÿßÿ™.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that @BLANK exists in the stem
                                if (!p.stem || !p.stem.includes('@BLANK')) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (GAP_TEXT): Missing @BLANK in stem.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÖŸÑÿ° ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™): @BLANK ŸÖŸÅŸÇŸàÿØ ŸÅŸä ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }

                                // üÜï Check that number of @BLANK matches number of correct answers
                                const blankCount = (p.stem.match(/@BLANK/g) || []).length;
                                const correctAnswersCount = (p.answers || []).filter(ans => ans.isCorrect).length;

                                if (blankCount !== correctAnswersCount) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (GAP_TEXT): Number of @BLANK (${blankCount}) doesn't match number of correct answers (${correctAnswersCount}).`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ŸÖŸÑÿ° ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™): ÿπÿØÿØ @BLANK (${blankCount}) ŸÑÿß Ÿäÿ∑ÿßÿ®ŸÇ ÿπÿØÿØ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© (${correctAnswersCount}).`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }

                            // Check INPUT_BOX has answer
                            if (p.type === this.QuestionType.INPUT_BOX) {
                                if (!p.answer || (!p.answer.value && p.answer.value !== 0)) {
                                    const errorMsg = `Question ${i + 1}, Part ${j + 1} (INPUT_BOX): Missing answer value.`;
                                    const errorMsgAr = `ÿßŸÑÿ≥ÿ§ÿßŸÑ ${i + 1}, ÿßŸÑÿ¨ÿ≤ÿ° ${j + 1} (ÿµŸÜÿØŸàŸÇ ÿ•ÿØÿÆÿßŸÑ): ŸÇŸäŸÖÿ© ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸÅŸÇŸàÿØÿ©.`;
                                    this.showMessage(this.language === this.Language.ARABIC ? errorMsgAr : errorMsg, 'error');
                                    return;
                                }
                            }
                        }
                    }

                    // All validation passed - proceed with conversion

                    const advancedFormatQuestions = this.questions.map((q, index) => this.transformToAdvancedFormat(q, index));
                    const jsonOutput = document.getElementById('jsonOutput');
                    this.jsonForExport = JSON.stringify(advancedFormatQuestions.length === 1 ? advancedFormatQuestions[0] : advancedFormatQuestions, null, 2);
                    this.setSafeHTML(jsonOutput, this.syntaxHighlight(this.jsonForExport));
                    jsonOutput.style.display = 'block';
                    document.getElementById('copyBtn').disabled = false;
                    document.getElementById('downloadBtn').disabled = this.questions.length > 1;
                    document.getElementById('downloadZipBtn').disabled = this.questions.length === 0;
                    document.getElementById('csvBtn').disabled = false;
                    this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ•ŸÑŸâ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠' : 'Successfully converted to advanced format', 'success');
                }
                transformToAdvancedFormat(question, index) {
                    const meta = question.metadata;
                    const csvRow = this.csvData[index];
                    const lang = meta.language || this.customization.lang;

                    const csvId = (csvRow && csvRow['Question Id']) ? parseInt(csvRow['Question Id'], 10) : NaN;

                    const finalId = !isNaN(csvId) ? csvId : (parseInt(meta.id, 10) || (Date.now() + index));

                    const finalMetadata = {
                        id: finalId,
                        ...(!isNaN(finalId) && { mapped_id: finalId }),
                        category: this.customization.category,
                        language: this.customization.lang,
                        country: this.customization.country,
                        dialect: this.language === this.Language.ARABIC ? ['Modern_standard'] : ["american", "british"],
                        source_id: { value: meta.source_id || this.customization.sourceId || this.config.defaults.sourceId, page_number: null },
                        description: (question.parts[0]?.stem || question.statement || '').substring(0, 150),
                        example_id: null,
                        has_example: false,
                        parts_count: question.parts.length,
                        instances_count: 1,
                        publication_date: new Date().toISOString(),
                        schema_version: "1.0.0"
                    };

                    return {
                        parts: question.parts.map((p, partIndex) => this._transformPart(p, meta, partIndex)),
                        statement: question.statement ? this.processTextForHtml(question.statement, lang, null, -1, 'statement', -1, null) : null,
                        instance_number: 1,
                        metadata: finalMetadata
                    };
                }
                _transformPart(part, globalMetadata, index) {
                    const lang = globalMetadata.language || this.customization.lang;

                    // No need to pre-process @BLANK here anymore
                    // processTextForHtml will handle @BLANK based on question type
                    const partJson = {
                        n: index + 1,
                        type: this.questionTypeConfigs[part.type]?.jsonType || part.type,
                        subtype: null,
                        standalone: false,
                        stem: this.processTextForHtml(part.stem, lang, null, index, 'stem', -1, part.type)
                    };
                    switch (part.type) {
                        case this.QuestionType.MCQ:
                        case this.QuestionType.MRQ:
                            Object.assign(partJson, this._transformMCQ_MRQ_Part(part, lang));
                            break;
                        case this.QuestionType.OQ:
                            Object.assign(partJson, this._transformOQPart(part, lang));
                            break;
                        case this.QuestionType.MATCHING:
                            Object.assign(partJson, this._transformMatchingPart(part, lang));
                            break;
                        case this.QuestionType.GAP_TEXT:
                            Object.assign(partJson, this._transformGapTextPart(part, lang));
                            break;
                        case this.QuestionType.STRING:
                            Object.assign(partJson, this._transformStringPart(part, globalMetadata, lang));
                            break;
                        case this.QuestionType.FRQ_AI:
                            Object.assign(partJson, this._transformFRQ_AIPart(part, globalMetadata, lang));
                            break;
                        case this.QuestionType.INPUT_BOX:
                            Object.assign(partJson, this._transformInputBoxPart(part));
                            break;
                        default:
                            partJson.choices = [];
                    }
                    return partJson;
                }
                _transformMCQ_MRQ_Part(part, lang) {
                    const correctAnswers = new Set(Array.isArray(part.answer) ? part.answer : [part.answer]);
                    return {
                        choices: (part.choices || []).map((choice, i) => ({
                            type: correctAnswers.has(i) ? 'key' : 'distractor',
                            html_content: this.processTextForHtml(choice, lang, null, -1, 'choice', i, part.type),
                            values: [],
                            unit: null,
                            index: i,
                            fixed_order: i + 1,
                            last_order: false
                        }))
                    };
                }
                _transformOQPart(part, lang) {
                    const itemsToShuffle = (part.choices || []).map((choice, i) => ({
                        text: choice,
                        originalIndex: i
                    }));

                    const shuffledItems = this._shuffleArray(itemsToShuffle);

                    return {
                        direction: part.direction || 'vertical', // Use part-specific direction or default to vertical
                        choices: shuffledItems.map((item, i) => ({
                            type: 'distractor',
                            html_content: this.processTextForHtml(item.text, lang, null, -1, 'choice', i, part.type),
                            correct_order: item.originalIndex + 1,
                            values: [],
                            unit: null,
                            index: i,
                            fixed_order: i + 1,
                            last_order: false
                        }))
                    };
                }
                _transformMatchingPart(part, lang) {
                    const choices = [];
                    const group1Items = (part.group1 || []);
                    const group1Length = group1Items.length;

                    group1Items.forEach((item, i) => {
                        choices.push({
                            type: 'distractor',
                            html_content: this.processTextForHtml(item, lang, null, -1, 'group1', i, part.type),
                            group: 1,
                            correct_order: i + 1,
                            values: [],
                            unit: null,
                            index: i,
                            fixed_order: i + 1,
                            last_order: false
                        });
                    });

                    const group2ItemsToShuffle = (part.group2 || []).map((item, i) => ({
                        text: item,
                        originalIndex: i
                    }));

                    const shuffledGroup2Items = this._shuffleArray(group2ItemsToShuffle);

                    shuffledGroup2Items.forEach((item, i) => {
                        choices.push({
                            type: 'distractor',
                            html_content: this.processTextForHtml(item.text, lang, null, -1, 'group2', i, part.type),
                            group: 2,
                            correct_order: item.originalIndex + 1,
                            values: [],
                            unit: null,
                            index: i + group1Length,
                            fixed_order: i + 1 + group1Length,
                            last_order: false
                        });
                    });

                    return { choices };
                }
                _transformGapTextPart(part, lang) {
                    const stem_html_gap = '<span data-node-type="blank-line" data-node-variation="gap"> </span>';
                    const processedStem = (part.stem || '').replace(/@BLANK|_{3,}/g, stem_html_gap);

                    // Separate correct answers (with *) from distractors (without *)
                    const correctAnswers = (part.answers || []).filter(ans => ans.isCorrect);
                    const distractors = (part.answers || []).filter(ans => !ans.isCorrect);

                    // Shuffle all answers (correct + distractors) for Gap Text questions
                    const allAnswersToShuffle = (part.answers || []).map((ans, i) => ({
                        value: ans.value,
                        originalOrder: ans.order,
                        isCorrect: ans.isCorrect,
                        originalIndex: i
                    }));

                    const shuffledAllAnswers = this._shuffleArray(allAnswersToShuffle);

                    // Create gap_text_keys with all answers, correct_order only for correct ones
                    const gap_text_keys = shuffledAllAnswers.map((ans, i) => {
                        const result = { value: ans.value };
                        if (ans.isCorrect) {
                            result.correct_order = ans.originalOrder;
                        }
                        return result;
                    });

                    return {
                        gap_text_keys: gap_text_keys,
                        stem: this.processTextForHtml(processedStem, lang, null, -1, 'stem', -1, 'gapText'),
                        choices: []
                    };
                }
                _transformStringPart(part, globalMetadata, lang) {
                    // Always use fixed AI template ID for String questions
                    const aiTemplateId = 593158513739;

                    const result = {
                        choices: null,
                        answer: [part.answer],
                        ai: {
                            "ai_template_id": Number(aiTemplateId),
                            "guidelines": []
                        }
                    };

                    // Check if we have guidelines tag in the part
                    if (part.guidelines && Array.isArray(part.guidelines)) {
                        result.ai.guidelines = part.guidelines;
                    }

                    return result;
                }




                _transformFRQ_AIPart(part, globalMetadata, lang) {
                    const result = {
                        choices: [],
                        answer: this._formatAnswerHtml(part.answer, lang, part.type)
                    };
                    const aiTemplateId = part.metadata.ai_template_id || globalMetadata.ai_template_id;
                    if (aiTemplateId) {
                        result.ai = { "ai_template_id": Number(aiTemplateId) };

                        // Add task_target for Simple_Sentences templates
                        const simpleSentencesTemplates = ["547160780494", "968102871405", "650142506209", "973160802168"];
                        if (simpleSentencesTemplates.includes(String(aiTemplateId))) {
                            if (part.metadata.task_target) {
                                result.ai.task_target = part.metadata.task_target;
                            }
                        }

                        // Add overall_task_instructions for Middle_School and High_School templates with Simple_Sentences
                        const overallTaskTemplates = ["707183083536"]; // English_Middle_School_Broken_Task
                        if (overallTaskTemplates.includes(String(aiTemplateId))) {
                            if (part.metadata.overall_task_instructions) {
                                result.ai.overall_task_instructions = part.metadata.overall_task_instructions;
                            }
                        }

                        // Add feedback_dialect, language_level, and feedback_language for English subject only
                        // Check if this is an English subject question (regardless of language)
                        const isEnglishSubject = globalMetadata.subject === 'English' || part.metadata.subject === 'English';
                        if (isEnglishSubject) {
                            // Add feedback_dialect if present
                            if (part.metadata.feedback_dialect) {
                                result.ai.feedback_dialect = part.metadata.feedback_dialect;
                            }

                            // Always add language_level for English FRQ_AI questions (even if empty)
                            result.ai.language_level = part.metadata.language_level || "";

                            // Add feedback_language for English FRQ_AI questions
                            result.ai.feedback_language = "Arabic, English";
                        }
                    }
                    return result;
                }
                _formatAnswerHtml(answerText, lang, questionType = null) {
                    if (!answerText) return '';
                    const isAr = lang === this.Language.ARABIC;
                    const dirAttr = isAr ? ' dir="rtl"' : '';
                    const lines = String(answerText).split(/\n/).map(l => l.trim()).filter(Boolean);
                    const isList = lines.length > 1 && lines.every(l => /^([¬ß\-\*\d]+[\).:]?|‚Ä¢)\s+/.test(l));
                    if (isList) {
                        const items = lines.map(l => l.replace(/^([¬ß\-\*\d]+[\).:]?|‚Ä¢)\s+/, '')).map(item => `<li class="LexicalTheme__listItem" style="text-align: justify;"><span style="white-space: pre-wrap;">${DOMPurify.sanitize(item)}</span></li>`).join('');
                        return `<ul class="LexicalTheme__list"${dirAttr}>${items}</ul>`;
                    }
                    return this.processTextForHtml(answerText, lang, null, -1, 'answer', -1, questionType);
                }
                _transformInputBoxPart(part) {
                    // Detect the type based on the value
                    let answerType = "integer"; // default
                    const value = part.answer.value;

                    if (typeof value === 'string') {
                        // Check if it's a fraction (e.g., "1/2", "3/4")
                        if (/^\d+\/\d+$/.test(value.trim())) {
                            answerType = "fraction";
                        }
                        // Check if it's a decimal (e.g., "3.14", "0.5")
                        else if (/^\d+\.\d+$/.test(value.trim())) {
                            answerType = "decimal";
                        }
                        // Check if it's an integer (e.g., "42", "100")
                        else if (/^\d+$/.test(value.trim())) {
                            answerType = "integer";
                        }
                    }

                    const answer = {
                        value: part.answer.value,
                        constrains: { type: answerType }
                    };

                    // Only add the unit key if it's a non-empty string.
                    if (part.answer.unit) {
                        answer.unit = part.answer.unit;
                    }
                    return { choices: [], answer };
                }
                // ***************************************************************
                // ** UI, ACTIONS & UTILITIES **
                // ***************************************************************

                _shuffleArray(array) {
                    let currentIndex = array.length, randomIndex;
                    while (currentIndex > 0) {
                        randomIndex = Math.floor(Math.random() * currentIndex);
                        currentIndex--;
                        [array[currentIndex], array[randomIndex]] = [
                            array[randomIndex], array[currentIndex]];
                    }
                    return array;
                }

                clearAll() {
                    this.setInputText('');
                    this.questions = []; this.jsonForExport = ''; this.csvData = [];
                    localStorage.removeItem('aiq_autosave_content');
                    localStorage.removeItem('aiq_csv_data');
                    this.updateUIAfterChange();
                    const jsonOutput = document.getElementById('jsonOutput');
                    jsonOutput.style.display = 'none'; jsonOutput.innerHTML = '';
                    document.getElementById('copyBtn').disabled = true;
                    document.getElementById('downloadBtn').disabled = true;
                    document.getElementById('downloadZipBtn').disabled = true;
                    document.getElementById('csvBtn').disabled = true;
                    this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ŸÖÿ≥ÿ≠ ŸÉŸÑ ÿ¥Ÿäÿ°' : 'Everything cleared', 'success');
                    this.logger.info("All data has been cleared.");
                }

                processTextForHtml(text, language, questionId, partIndex, fieldType, choiceIndex = -1, questionType = null) {
                    if (!text) return '';
                    const direction = language === this.Language.ARABIC ? ' dir="rtl"' : '';

                    // FIX: Changed from 5 or more underscores to 4 or more, per user request.
                    // Underscores (____) are replaced with "space" variation for blank lines in all question types
                    let processedText = text.replace(/_{4,}/g, '<span data-node-type="blank-line" data-node-variation="space">&nbsp;</span>');

                    // Replace @BLANK based on question type:
                    // - GapText questions ‚Üí "gap" variation (for fillable gaps)
                    // - Other question types ‚Üí "space" variation (for blank lines)
                    if (processedText.includes('@BLANK')) {
                        if (questionType === this.QuestionType.GAP_TEXT || questionType === 'gapText') {
                            processedText = processedText.replace(/@BLANK/g, '<span data-node-type="blank-line" data-node-variation="gap"> </span>');
                        } else {
                            processedText = processedText.replace(/@BLANK/g, '<span data-node-type="blank-line" data-node-variation="space">&nbsp;</span>');
                        }
                    }

                    // If the text contains a poem block, split into pre/poem/post segments and render exactly as required
                    const poemRegex = /@POEM[\t ]*\n([\s\S]*?)\n@END_POEM/;
                    if (poemRegex.test(processedText)) {
                        const match = processedText.match(poemRegex);
                        const preText = processedText.slice(0, match.index).trim();
                        const poemBody = match[1] || '';
                        const postText = processedText.slice(match.index + match[0].length).trim();

                        const renderParagraph = (plainText) => {
                            if (!plainText) return '';
                            // split into math/plain chunks like below
                            const chunks = plainText.split(/(``[\s\S]*?``|`[\s\S]*?`|<span data-node-type="blank-line" data-node-variation="gap"> <\/span>|<span data-node-type="blank-line" data-node-variation="space">&nbsp;<\/span>)/);
                            let html = '';
                            let mfIndex = 0;
                            for (const chunk of chunks) {
                                if (!chunk) continue;
                                if (chunk.startsWith('``') && chunk.endsWith('``')) {
                                    html += this.createMathField(chunk.slice(2, -2), language, true, questionId, partIndex, fieldType, choiceIndex, mfIndex++);
                                } else if (chunk.startsWith('`') && chunk.endsWith('`')) {
                                    html += this.createMathField(chunk.slice(1, -1), language, false, questionId, partIndex, fieldType, choiceIndex, mfIndex++);
                                } else if (chunk.includes('data-node-type="blank-line"')) {
                                    html += chunk;
                                } else {
                                    let t = chunk;
                                    t = t.replace(/\[U\]([\s\S]+?)\[\/U\]/g, '<u>$1</u>');
                                    t = t.replace(/(^|\n)\s*-\s+/g, `$1¬ß `);
                                    html += `<span style="white-space: pre-line;">${DOMPurify.sanitize(t.replace(/\n/g, '<br>'))}</span>`;
                                }
                            }
                            return `<p class="LexicalTheme__paragraph" style="text-align: justify;"${direction}>${html}</p>`;
                        };

                        // ÿ™ŸÇÿ≥ŸäŸÖ ÿßŸÑÿ¥ÿπÿ± ŸÑÿ£ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑÿ©
                        const verses = poemBody
                            .split(/\n+/)
                            .map(line => line.trim())
                            .filter(Boolean);

                        // ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÉÿ¥ŸäÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ŸÇÿ®ŸÑ ÿ™ÿ≠ŸàŸäŸÑŸáÿß ŸÑŸÄ HTML
                        let processedVerses = verses;
                        if (typeof KashidaEngine !== 'undefined' && KashidaEngine.unifyTextsWidths) {
                            try {
                                const font = '16px "Noto Naskh Arabic", "Amiri", serif';
                                processedVerses = KashidaEngine.unifyTextsWidths(verses, font);
                                console.log('‚úÖ Kashida applied to poem in JSON:', processedVerses.length);
                            } catch (err) {
                                console.warn('‚ö†Ô∏è Kashida application failed in JSON:', err);
                                processedVerses = verses;
                            }
                        }

                        // ÿ™ÿ≠ŸàŸäŸÑ ŸÑŸÑŸÄ HTML ŸÖÿπ ÿßŸÑŸÉÿ¥ŸäÿØÿ© ÿßŸÑŸÖÿ∑ÿ®ŸÇÿ©
                        const versesHtml = processedVerses
                            .map(line => `<p>${DOMPurify.sanitize(line)}</p>`)
                            .join('');

                        // ÿ•ŸÜÿ¥ÿßÿ° HTML ÿßŸÑŸÜŸáÿßÿ¶Ÿä (ÿ®ÿØŸàŸÜ data-kashida-pending ŸÑÿ£ŸÜ ÿßŸÑŸÉÿ¥ŸäÿØÿ© ÿßÿ™ÿ®ŸÑŸÇÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ)
                        const localeAttr = language === this.Language.ARABIC ? ' lang="ar"' : '';
                        const poemHtml = `<div class="PoemContainer"${direction}${localeAttr}><article class="Poem vertical-split" style="font-family: 'Noto Naskh Arabic', 'Amiri', serif;">${versesHtml}</article></div>`;
                        return `${renderParagraph(preText)}${poemHtml}${renderParagraph(postText)}`;
                    }

                    // Otherwise, render as a single justified paragraph
                    const parts = processedText.split(/(``[\s\S]*?``|`[\s\S]*?`|<span data-node-type="blank-line" data-node-variation="gap"> <\/span>|<span data-node-type="blank-line" data-node-variation="space">&nbsp;<\/span>)/);
                    let finalHtmlContent = "";
                    let mathFieldIndex = 0;
                    for (const part of parts) {
                        if (!part) continue;
                        if (part.startsWith('``') && part.endsWith('``')) {
                            finalHtmlContent += this.createMathField(part.slice(2, -2), language, true, questionId, partIndex, fieldType, choiceIndex, mathFieldIndex++);
                        } else if (part.startsWith('`') && part.endsWith('`')) {
                            finalHtmlContent += this.createMathField(part.slice(1, -1), language, false, questionId, partIndex, fieldType, choiceIndex, mathFieldIndex++);
                        } else if (part.includes('data-node-type="blank-line"')) {
                            finalHtmlContent += part;
                        } else {
                            let textPart = part;
                            textPart = textPart.replace(/\[U\]([\s\S]+?)\[\/U\]/g, '<u>$1</u>');
                            textPart = textPart.replace(/(^|\n)\s*-\s+/g, `$1¬ß `);
                            finalHtmlContent += `<span style="white-space: pre-line;">${DOMPurify.sanitize(textPart.replace(/\n/g, '<br>'))}</span>`;
                        }
                    }
                    return `<p class="LexicalTheme__paragraph" style="text-align: justify;"${direction}>${finalHtmlContent}</p>`;
                }

                createMathField(equation, language, forceEn = false, questionId, partIndex, fieldType, choiceIndex, mathFieldIndex) {
                    const isArabic = language === this.Language.ARABIC && !forceEn;
                    // Handle @BLANK in math equations - use a visible blank space
                    let latexValue = equation.replace(/@BLANK/g, '\\text{____}');
                    if (isArabic && this.config.flags.convertArabicLatex) {
                        latexValue = this.convertToArabicLatex(latexValue);
                    }
                    const localeAttrs = isArabic ? ' locale="ar" lang="ar"' : ' locale="en"';
                    const processedValue = latexValue.replace(/"/g, '&quot;');

                    const dataAttrs = `data-question-id="${questionId}" 
                                     data-part-index="${partIndex}" 
                                     data-field-type="${fieldType}" 
                                     data-choice-index="${choiceIndex}"
                                     data-math-index="${mathFieldIndex}"`;

                    return `<span class="LexicalTheme__math--inline" data-node-type="math" data-node-variation="inline"><math-field ${dataAttrs} default-mode="inline-math" value="${processedValue}"${localeAttrs}></math-field></span>`;
                }

                handleMathFieldInput(event) {
                    const mathField = event.target;
                    const questionId = mathField.dataset.questionId;
                    const partIndex = parseInt(mathField.dataset.partIndex, 10);
                    const fieldType = mathField.dataset.fieldType;
                    const choiceIndex = parseInt(mathField.dataset.choiceIndex, 10);
                    const mathFieldIndex = parseInt(mathField.dataset.mathIndex, 10);
                    const newLatexValue = mathField.value;

                    const question = this.questions.find(q => q.metadata.id === questionId);
                    if (!question) return;

                    let partToUpdate;
                    if (partIndex === -1) {
                        partToUpdate = question;
                    } else {
                        partToUpdate = question.parts[partIndex];
                    }

                    if (!partToUpdate) return;

                    const updateRawText = (originalText) => {
                        if (isNaN(mathFieldIndex) || !originalText) return originalText;

                        const regex = /(``[\s\S]*?``|`[\s\S]*?`)/g;
                        let currentMathIndex = 0;

                        const newText = originalText.replace(regex, (match) => {
                            if (currentMathIndex === mathFieldIndex) {
                                currentMathIndex++;
                                const delimiter = match.startsWith('``') ? '``' : '`';
                                return `${delimiter}${newLatexValue}${delimiter}`;
                            }
                            currentMathIndex++;
                            return match;
                        });

                        return newText;
                    };

                    switch (fieldType) {
                        case 'statement':
                            partToUpdate.statement = updateRawText(partToUpdate.statement);
                            break;
                        case 'stem':
                            partToUpdate.stem = updateRawText(partToUpdate.stem);
                            break;
                        case 'choice':
                            if (choiceIndex > -1 && Array.isArray(partToUpdate.choices) && partToUpdate.choices[choiceIndex]) {
                                partToUpdate.choices[choiceIndex] = updateRawText(partToUpdate.choices[choiceIndex]);
                            }
                            break;
                        case 'answer':
                            partToUpdate.answer = updateRawText(partToUpdate.answer);
                            break;
                    }

                    this._regenerateQuestionContent(question);
                    this.updateTextareaFromQuestions();
                    if (document.getElementById('jsonOutput').style.display === 'block') {
                        this.convertToJSON();
                    }

                    this.logger.info(`Updated math field for Q:${questionId}, Part:${partIndex}, Type:${fieldType}`);
                }

                convertToArabicLatex(equation) {
                    const commands = equation.match(/\\\w+/g) || [];
                    commands.forEach((command, i) => { equation = equation.replace(command, `__CMD_PLACEHOLDER_${i}__`); });
                    const parts = equation.split(' ');
                    const processedParts = parts.map(part => this.config.ARABIC_LATEX_MAP[part] || part);
                    equation = processedParts.join(' ');
                    commands.forEach((command, i) => { equation = equation.replace(`__CMD_PLACEHOLDER_${i}__`, command); });
                    return equation;
                }
                displayResults() {
                    const previewContainer = document.getElementById('questionsPreview');
                    previewContainer.innerHTML = '';
                    const placeholder = document.getElementById('preview-placeholder');
                    if (this.questions.length === 0) {
                        if (!placeholder) {
                            const newPlaceholder = document.createElement('div');
                            newPlaceholder.id = 'preview-placeholder';
                            newPlaceholder.style.cssText = "text-align: center; color: #6b7280; padding: 40px; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;";
                            previewContainer.appendChild(newPlaceholder);
                        }
                        const visiblePlaceholder = document.getElementById('preview-placeholder');
                        visiblePlaceholder.style.display = 'flex';
                        const msg = this.language === this.Language.ARABIC ? 'ÿ≥ÿ™ÿ∏Ÿáÿ± ŸÖÿπÿßŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸáŸÜÿß ÿ®ÿπÿØ ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ' : 'Questions preview will appear here after analysis';
                        this.setSafeHTML(visiblePlaceholder, `<div style="font-size: 3em; margin-bottom: 20px;">üìã</div><p>${msg}</p>`);
                        return;
                    }
                    if (placeholder) placeholder.style.display = 'none';
                    this.questions.forEach((q, index) => {
                        const questionDiv = document.createElement('div');
                        questionDiv.className = 'question-preview';
                        questionDiv.dataset.id = q.metadata.id;
                        const html = q._editing ? this._renderEditView(q) : this._renderReadOnlyView(q, index);
                        this.setSafeHTML(questionDiv, html);
                        previewContainer.appendChild(questionDiv);
                    });

                    // üéØ Add event listeners for English template selectors
                    document.querySelectorAll('.english-template-selector').forEach(select => {
                        select.addEventListener('change', (e) => {
                            const questionId = e.target.dataset.questionId;
                            const selectedTemplateId = e.target.value;

                            // Store selection
                            this.questionTemplateSelections[questionId] = selectedTemplateId;

                            // Apply to question metadata - ONLY for frq_ai parts
                            const question = this.questions.find(q => q.metadata.id === questionId);
                            if (question) {
                                question.parts.forEach(part => {
                                    if (part.type === this.QuestionType.FRQ_AI) {
                                        part.metadata.ai_template_id = selectedTemplateId;
                                    }
                                    // String keeps its fixed template ID (593158513739)
                                });

                                // Set question-level metadata if there's at least one frq_ai
                                if (question.parts.some(part => part.type === this.QuestionType.FRQ_AI)) {
                                    question.metadata.ai_template_id = selectedTemplateId;
                                }
                            }

                            // Re-render to show confirmation
                            this.displayResults();

                            // Update JSON if visible
                            if (document.getElementById('jsonOutput').style.display === 'block') {
                                this.convertToJSON();
                            }
                        });
                    });

                    // üéØ Add event listeners for task_target inputs
                    document.querySelectorAll('.task-target-input').forEach(input => {
                        input.addEventListener('blur', (e) => {
                            const questionId = e.target.dataset.questionId;
                            const taskTarget = e.target.value.trim();

                            const question = this.questions.find(q => q.metadata.id === questionId);
                            if (question) {
                                question.parts.forEach(part => {
                                    if (part.type === this.QuestionType.FRQ_AI) {
                                        if (taskTarget) {
                                            part.metadata.task_target = taskTarget;
                                        } else {
                                            delete part.metadata.task_target;
                                        }
                                    }
                                });
                            }

                            // Update JSON if visible
                            if (document.getElementById('jsonOutput').style.display === 'block') {
                                this.convertToJSON();
                            }
                        });
                    });

                    // üéØ Add event listeners for overall_task_instructions inputs
                    document.querySelectorAll('.overall-task-instructions-input').forEach(textarea => {
                        textarea.addEventListener('blur', (e) => {
                            const questionId = e.target.dataset.questionId;
                            const overallTaskInstructions = e.target.value.trim();

                            const question = this.questions.find(q => q.metadata.id === questionId);
                            if (question) {
                                question.parts.forEach(part => {
                                    if (part.type === this.QuestionType.FRQ_AI) {
                                        if (overallTaskInstructions) {
                                            part.metadata.overall_task_instructions = overallTaskInstructions;
                                        } else {
                                            delete part.metadata.overall_task_instructions;
                                        }
                                    }
                                });
                            }

                            // Update JSON if visible
                            if (document.getElementById('jsonOutput').style.display === 'block') {
                                this.convertToJSON();
                            }
                        });
                    });

                    // üéØ Add event listeners for OQ direction selectors
                    document.querySelectorAll('.oq-direction-selector').forEach(select => {
                        select.addEventListener('change', (e) => {
                            const questionId = e.target.dataset.questionId;
                            const selectedDirection = e.target.value;

                            // Store selection
                            this.questionOQDirections[questionId] = selectedDirection;

                            // Apply to question metadata - ONLY for OQ parts
                            const question = this.questions.find(q => q.metadata.id === questionId);
                            if (question) {
                                question.parts.forEach(part => {
                                    if (part.type === this.QuestionType.OQ) {
                                        part.direction = selectedDirection;
                                    }
                                });
                            }

                            // Re-render to show changes
                            this.displayResults();

                            // Update JSON if visible
                            if (document.getElementById('jsonOutput').style.display === 'block') {
                                this.convertToJSON();
                            }
                        });
                    });
                }

                _renderReadOnlyView(q, index) {
                    const lang = q.metadata.language || this.customization.lang || 'ar';
                    const csvRow = this.csvData[index];
                    const questionIdText = (csvRow && csvRow['Question Id']) ? csvRow['Question Id'] : q.metadata.id;
                    let html = `<div class="question-actions">
                    <button class="action-btn edit-btn" title="${this.language === this.Language.ARABIC ? 'ÿ™ÿπÿØŸäŸÑ' : 'Edit'}" aria-label="Edit">‚úèÔ∏è</button>
                    <button class="action-btn delete-btn" title="${this.language === this.Language.ARABIC ? 'ÿ≠ÿ∞ŸÅ' : 'Delete'}" aria-label="Delete">üóëÔ∏è</button>
                </div>`;

                    if (q.validationWarning) {
                        html += `<div class="validation-warning" title="${q.validationWarning}">‚ö†Ô∏è</div>`;
                    }

                    // üéØ Add English Template ID dropdown for frq_ai questions ONLY
                    const hasFRQAIQuestion = q.parts.some(part => part.type === this.QuestionType.FRQ_AI);

                    if (this.selectedEnglishStage && hasFRQAIQuestion) {
                        const stage = this.getStageFromGrade(this.selectedEnglishStage);
                        const templates = this.englishTemplatesByStage[stage] || [];
                        const currentSelection = this.questionTemplateSelections[q.metadata.id] || '';

                        html += `<div style="margin-bottom:15px;">
                        <select 
                            class="english-template-selector" 
                            data-question-id="${q.metadata.id}" 
                            style="width:100%; padding:8px; border-radius:6px; border:1px solid #3b82f6; font-size:14px; background:white;"
                        >
                            <option value="">-- ÿßÿÆÿ™ÿ± ŸÜŸàÿπ Template ID --</option>
                            ${templates.map(t => `
                                <option value="${t.id}" ${currentSelection === t.id ? 'selected' : ''}>
                                    ${t.displayName}
                                </option>
                            `).join('')}
                        </select>
                    </div>`;

                        // Add task_target and overall_task_instructions inputs if Simple_Sentences or Broken_Task template is selected
                        const simpleSentencesTemplates = ["547160780494", "968102871405", "650142506209", "973160802168"];
                        const overallTaskTemplates = ["707183083536"];

                        if (simpleSentencesTemplates.includes(currentSelection)) {
                            const taskTarget = q.parts.find(p => p.type === this.QuestionType.FRQ_AI)?.metadata?.task_target || '';
                            html += `<div style="margin-bottom:15px;">
                            <label style="display:block; margin-bottom:5px; font-weight:bold; color:#6b7280;">Task Target (Ÿàÿßÿ¨ÿ® ÿßŸÑÿ∑ÿßŸÑÿ®):</label>
                            <input 
                                type="text" 
                                class="task-target-input" 
                                data-question-id="${q.metadata.id}"
                                value="${taskTarget}"
                                placeholder="ŸÖÿ´ÿßŸÑ: To use appropriate structures to write the beginning of a story"
                                style="width:100%; padding:8px; border-radius:6px; border:1px solid #e5e7eb; font-size:14px; background:white;"
                            />
                        </div>`;
                        }

                        if (overallTaskTemplates.includes(currentSelection)) {
                            const overallTaskInstructions = q.parts.find(p => p.type === this.QuestionType.FRQ_AI)?.metadata?.overall_task_instructions || '';
                            html += `<div style="margin-bottom:15px;">
                            <label style="display:block; margin-bottom:5px; font-weight:bold; color:#6b7280;">Overall Task Instructions (ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑÿπÿßŸÖÿ© ŸÑŸÑŸÖŸáŸÖÿ©):</label>
                            <textarea 
                                class="overall-task-instructions-input" 
                                data-question-id="${q.metadata.id}"
                                placeholder="ŸÖÿ´ÿßŸÑ: Write an email on this topic: 'A Trip to a Historical Site'"
                                style="width:100%; min-height:80px; padding:8px; border-radius:6px; border:1px solid #e5e7eb; font-size:14px; background:white; resize:vertical;"
                            >${overallTaskInstructions}</textarea>
                        </div>`;
                        }
                    }

                    // üéØ Add OQ Direction dropdown for OQ questions ONLY
                    const hasOQQuestion = q.parts.some(part => part.type === this.QuestionType.OQ);

                    if (hasOQQuestion) {
                        const currentDirection = this.questionOQDirections[q.metadata.id] || 'vertical';

                        html += `<div style="margin-bottom:15px;">
                        <select 
                            class="oq-direction-selector" 
                            data-question-id="${q.metadata.id}" 
                            style="width:100%; padding:8px; border-radius:6px; border:1px solid #10b981; font-size:14px; background:white;"
                        >
                            <option value="vertical" ${currentDirection === 'vertical' ? 'selected' : ''}>Vertical (ÿπŸÖŸàÿØŸä)</option>
                            <option value="horizontal" ${currentDirection === 'horizontal' ? 'selected' : ''}>Horizontal (ÿ£ŸÅŸÇŸä)</option>
                        </select>
                    </div>`;
                    }

                    if (q.statement) {
                        html += `<div class="statement-preview">${this.processTextForHtml(q.statement, lang, q.metadata.id, -1, 'statement', -1, null)}</div>`;
                    }
                    q.parts.forEach((p, pIndex) => {
                        const isInteractive = p.type === this.QuestionType.MCQ || p.type === this.QuestionType.MRQ;
                        html += `<div class="part-preview" data-interactive="${isInteractive}" data-part-index="${pIndex}">`;
                        html += `<div class="question-type-badge type-${p.type}">${this.questionTypeConfigs[p.type]?.label || p.type} | ID: ${questionIdText}</div>`;
                        // No need to manually replace @BLANK anymore - processTextForHtml will handle it based on question type
                        html += `<div>${this.processTextForHtml(p.stem, lang, q.metadata.id, pIndex, 'stem', -1, p.type)}</div>`;

                        if (p.type === 'oq' || p.type === 'mcq' || p.type === 'mrq') {
                            const correctAnswers = new Set(Array.isArray(p.answer) ? p.answer : [p.answer]);
                            html += (p.choices || []).map((choice, cIndex) =>
                                `<div class="choice-item ${correctAnswers.has(cIndex) ? 'correct' : ''}" data-question-id="${q.metadata.id}" data-choice-index="${cIndex}">${this.processTextForHtml(choice, lang, q.metadata.id, pIndex, 'choice', cIndex, p.type)}</div>`
                            ).join('');
                        } else if (p.type === 'matching') {
                            let g1Html = (p.group1 || []).map((item, i) => `<div class="matching-item">${i + 1}. ${this.processTextForHtml(item, lang, q.metadata.id, pIndex, 'group1', i, p.type)}</div>`).join('');
                            let g2Html = (p.group2 || []).map((item, i) => `<div class="matching-item">${String.fromCharCode(65 + i)}. ${this.processTextForHtml(item, lang, q.metadata.id, pIndex, 'group2', i, p.type)}</div>`).join('');
                            html += `<div class="matching-preview"><div class="matching-column"><strong>${this.language === this.Language.ARABIC ? 'ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ£' : 'List A'}</strong>${g1Html}</div><div class="matching-column"><strong>${this.language === this.Language.ARABIC ? 'ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿ®' : 'List B'}</strong>${g2Html}</div></div>`;
                        } else if (p.type === 'string' || p.type === 'frq_ai') {
                            html += `<div class="choice-item correct"><strong>${this.language === this.Language.ARABIC ? 'ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©:' : 'Answer:'}</strong> ${this.processTextForHtml(p.answer, lang, q.metadata.id, pIndex, 'answer', -1, p.type)}</div>`;

                            // Display guidelines for string questions if available
                            if (p.type === 'string' && p.guidelines && Array.isArray(p.guidelines) && p.guidelines.length > 0) {
                                html += `<div class="guidelines-container">
                                <h4 style="margin-top: 12px; color: #4338ca;">${this.language === this.Language.ARABIC ? 'ÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä:' : 'AI Guidelines:'}</h4>
                                <table class="guidelines-table" style="width:100%; border-collapse: collapse; margin-top:8px;">
                                    <thead>
                                        <tr>
                                            <th style="text-align:left; padding:6px; border:1px solid #e5e7eb;">${this.language === this.Language.ARABIC ? 'ÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ®' : 'Student Answer'}</th>
                                            <th style="text-align:center; padding:6px; border:1px solid #e5e7eb; width:80px;">${this.language === this.Language.ARABIC ? 'ÿßŸÑÿØÿ±ÿ¨ÿ©' : 'Mark'}</th>
                                            <th style="text-align:left; padding:6px; border:1px solid #e5e7eb;">${this.language === this.Language.ARABIC ? 'ÿßŸÑÿ™ÿπŸÑŸäŸÇ' : 'Comment'}</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${p.guidelines.map(g => `
                                            <tr>
                                                <td style="text-align:left; padding:6px; border:1px solid #e5e7eb;">${g.student_answer}</td>
                                                <td style="text-align:center; padding:6px; border:1px solid #e5e7eb;">${g.mark}</td>
                                                <td style="text-align:left; padding:6px; border:1px solid #e5e7eb;">${g.comment}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>`;
                            }
                        } else if (p.type === 'gapText') {
                            html += `<div class="gapped-text-answers"><strong>${this.language === this.Language.ARABIC ? 'ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿ®ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ®:' : 'Answers in order:'}</strong><ul>${(p.answers || []).map((ans, aIndex) => (ans && ans.value) ? `<li>${this.processTextForHtml(ans.value, lang, q.metadata.id, pIndex, 'gap', aIndex, p.type)}</li>` : '').join('')}</ul></div>`;
                        } else if (p.type === 'input_box') {
                            if (p.answer && typeof p.answer.value !== 'undefined') {
                                html += `<div class="choice-item correct"><strong>${this.language === this.Language.ARABIC ? 'ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©:' : 'Answer:'}</strong> ${p.answer.value} ${p.answer.unit || ''}</div>`;
                            }
                        }
                        html += `</div>`;
                    });
                    return html;
                }

                _renderEditView(q) {
                    const contentToEdit = q._contentBlock || '';
                    let html = `<textarea class="edit-textarea" id="edit-q-text-${q.metadata.id}">${contentToEdit}</textarea>`;
                    html += `<div style="margin-top:10px;display:flex;gap:10px;">
                    <button class="btn btn-success btn-save-edit">üíæ ${this.language === this.Language.ARABIC ? 'ÿ≠ŸÅÿ∏' : 'Save'}</button>
                    <button class="btn btn-secondary btn-cancel-edit">‚ùå ${this.language === this.Language.ARABIC ? 'ÿ•ŸÑÿ∫ÿßÿ°' : 'Cancel'}</button>
                </div>`;
                    return html;
                }
                startEditQuestion(id) {
                    const qIndex = this.questions.findIndex(q => q.metadata.id === id);
                    if (qIndex > -1) { this.questions[qIndex]._editing = true; this.displayResults(); }
                }
                saveEditQuestion(id) {
                    const qIndex = this.questions.findIndex(q => q.metadata.id === id);
                    if (qIndex > -1) {
                        const originalQuestion = this.questions[qIndex];
                        const newContent = document.getElementById(`edit-q-text-${id}`).value;
                        const newFullBlock = (originalQuestion._metaHeader || '') + newContent;
                        const newQuestionObject = this._parseQuestionBlock(newFullBlock, qIndex);
                        this.questions[qIndex] = newQuestionObject;
                        this.updateUIAfterChange(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿπÿØŸäŸÑÿßÿ™.' : 'Changes saved.');
                    }
                }
                cancelEditQuestion(id) {
                    const q = this.questions.find(q => q.metadata.id === id);
                    if (q) { q._editing = false; this.displayResults(); }
                }
                deleteQuestion(id) {
                    const qIndex = this.questions.findIndex(q => q.metadata.id === id);
                    if (qIndex > -1) {
                        this.questions.splice(qIndex, 1);
                        this.updateUIAfterChange(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ≥ÿ§ÿßŸÑ.' : 'Question deleted.');
                    }
                }
                updateUIAfterChange(message) {
                    this.runLiveValidation();
                    this.updateStatistics();
                    this.displayResults();
                    const jsonOutput = document.getElementById('jsonOutput');
                    if (jsonOutput.style.display === 'block') { this.convertToJSON(); }
                    document.getElementById('downloadZipBtn').disabled = this.questions.length === 0;
                    if (message) { this.showMessage(message, 'success'); }
                }
                updateStatistics() {
                    const total = this.questions.length;

                    // Update total questions count
                    document.getElementById('totalQuestions').textContent = total;

                    // Count questions by type
                    const typeCounts = {};
                    this.questions.forEach(question => {
                        question.parts.forEach(part => {
                            const type = this.questionTypeConfigs[part.type]?.label || part.type;
                            typeCounts[type] = (typeCounts[type] || 0) + 1;
                        });
                    });

                    // Update question types stats
                    const statsContainer = document.getElementById('questionTypesStats');
                    if (total === 0) {
                        statsContainer.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ©</div>';
                    } else {
                        const statsHtml = Object.entries(typeCounts)
                            .sort(([, a], [, b]) => b - a) // Sort by count descending
                            .map(([type, count]) => `
                            <div class="type-stat">
                                <span class="type-name">${type}</span>
                                <span class="type-count">${count}</span>
                            </div>
                        `).join('');
                        statsContainer.innerHTML = statsHtml;
                    }
                }
                showMessage(text, type = 'success') {
                    const container = document.getElementById('messageContainer');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${type}`;
                    this.setSafeHTML(messageDiv, `<span class="close-x" aria-label="Close">√ó</span>${text}`);
                    messageDiv.querySelector('.close-x').onclick = () => messageDiv.remove();
                    container.appendChild(messageDiv);
                    setTimeout(() => { messageDiv.remove(); }, 4000);
                }
                async copyJSON() {
                    // Check if Source ID is selected
                    const sourceIdSelect = document.getElementById('sourceIdSelect');
                    if (!sourceIdSelect || !sourceIdSelect.value || sourceIdSelect.value.trim() === '' || sourceIdSelect.value === 'none') {
                        this.showMessage(this.language === this.Language.ARABIC ? 'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ŸÜÿ≥ÿÆ JSON.' : 'Please select a valid Source ID before copying JSON.', 'error');
                        return;
                    }

                    if (!this.jsonForExport) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ŸÑÿß ŸäŸàÿ¨ÿØ ÿ¥Ÿäÿ° ŸÑŸÜÿ≥ÿÆŸá' : 'Nothing to copy', 'warning');
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(this.jsonForExport);
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ŸÜÿ≥ÿÆ JSON ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©' : 'JSON copied to clipboard', 'success');
                    } catch (err) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ≥ÿÆ' : 'Copy failed', 'error');
                    }
                }
                downloadJSON() {
                    // Check if Source ID is selected
                    const sourceIdSelect = document.getElementById('sourceIdSelect');
                    if (!sourceIdSelect || !sourceIdSelect.value || sourceIdSelect.value.trim() === '' || sourceIdSelect.value === 'none') {
                        this.showMessage(this.language === this.Language.ARABIC ? 'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ JSON.' : 'Please select a valid Source ID before downloading JSON.', 'error');
                        return;
                    }

                    if (!this.jsonForExport || this.questions.length > 1) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ŸäŸÖŸÉŸÜ ÿ™ÿ≠ŸÖŸäŸÑ ÿ≥ÿ§ÿßŸÑ Ÿàÿßÿ≠ÿØ ŸÅŸÇÿ∑ ÿ®ÿµŸäÿ∫ÿ© JSON. ÿßÿ≥ÿ™ÿÆÿØŸÖ ZIP ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ¨ŸÖÿπ.' : 'Only one question can be downloaded as JSON. Use ZIP for bulk download.', 'warning');
                        return;
                    }
                    const filename = `${this.questions[0].metadata.id}.json`;
                    const blob = new Blob([this.jsonForExport], { type: 'application/json' });
                    this.downloadBlob(blob, filename);
                    this.showMessage(this.language === this.Language.ARABIC ? 'ÿ®ÿØÿ° ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ...' : 'Download starting...', 'success');
                }
                async downloadZip() {
                    // Check if Source ID is selected
                    const sourceIdSelect = document.getElementById('sourceIdSelect');
                    if (!sourceIdSelect || !sourceIdSelect.value || sourceIdSelect.value.trim() === '' || sourceIdSelect.value === 'none') {
                        this.showMessage(this.language === this.Language.ARABIC ? 'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ ZIP.' : 'Please select a valid Source ID before downloading ZIP.', 'error');
                        return;
                    }

                    if (this.questions.length === 0) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ŸÑÿß ŸäŸàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑÿ™ÿ≠ŸÖŸäŸÑŸáÿß' : 'No questions to download', 'warning');
                        return;
                    }
                    const randomName = `QuestionsExport_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
                    const jsonsZip = new JSZip();
                    this.questions.forEach((q, idx) => {
                        const singleQuestionObject = this.transformToAdvancedFormat(q, idx);
                        const filename = `${singleQuestionObject.metadata.id}.json`;
                        const content = JSON.stringify(singleQuestionObject, null, 2);
                        jsonsZip.file(filename, content);
                    });
                    const jsonsZipBlob = await jsonsZip.generateAsync({ type: 'blob' });
                    const mainZip = new JSZip();
                    mainZip.file('JSONS.zip', jsonsZipBlob);
                    mainZip.file('question_set_summary.csv', this.generateCSVContent());
                    const blob = await mainZip.generateAsync({ type: 'blob' });
                    this.downloadBlob(blob, `${randomName}.zip`);
                    this.showMessage(this.language === this.Language.ARABIC ? `ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ${randomName}.zip ÿ®ŸÜÿ¨ÿßÿ≠` : `${randomName}.zip downloaded successfully`, 'success');
                }
                downloadBlob(blob, filename) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url; a.download = filename;
                    document.body.appendChild(a); a.click();
                    document.body.removeChild(a); URL.revokeObjectURL(url);
                }
                toggleLanguage() {
                    this.language = this.language === this.Language.ARABIC ? this.Language.ENGLISH : this.Language.ARABIC;
                    this.updateInterfaceLanguage();
                    const html = document.documentElement;
                    if (this.language === this.Language.ARABIC) {
                        html.setAttribute('lang', 'ar');
                        html.setAttribute('dir', 'rtl');
                    } else {
                        html.setAttribute('lang', 'en');
                        html.setAttribute('dir', 'ltr');
                    }
                    this.saveSettings();
                }
                updateInterfaceLanguage() {
                    const isAr = this.language === this.Language.ARABIC;
                    document.documentElement.lang = isAr ? 'ar' : 'en';
                    document.documentElement.dir = isAr ? 'rtl' : 'ltr';
                    const translations = {
                        mainTitle: { ar: 'üöÄ ÿ±ÿßŸÅÿπ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ¨ŸÖÿπ', en: 'üöÄ Bulk Question Uploader' },
                        mainSubtitle: { ar: 'ÿ±ŸÅÿπ Ÿàÿ™ÿ≠ŸàŸäŸÑ ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸÉÿ®Ÿäÿ±ÿ© ŸÖŸÜ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ•ŸÑŸâ ÿµŸäÿ∫ÿ© JSON ŸÖÿ™ŸÇÿØŸÖÿ©', en: 'Upload and convert large batches of questions to advanced JSON format' },
                        panelTitle1: { ar: '<span style="font-size: 1.5em; line-height: 1;">‚ë†</span> ÿßÿÆÿ™ÿ± ŸÜŸàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ (ŸÑŸÑŸÜÿµ ÿßŸÑÿ®ÿ≥Ÿäÿ∑)', en: '<span style="font-size: 1.5em; line-height: 1;">‚ë†</span> Select Type (for Simple Text)' },
                        panelTitle2: { ar: '<span style="font-size: 1.5em; line-height: 1;">‚ë°</span> ÿ£ÿØÿÆŸÑ ÿßŸÑŸÜÿµ', en: '<span style="font-size: 1.5em; line-height: 1;">‚ë°</span> Enter Text' },
                        statsTitle: { ar: 'üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©', en: 'üìä Question Statistics' },
                        panelTitle4: { ar: 'üëÅÔ∏è ŸÖÿπÿßŸäŸÜÿ© ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©', en: 'üëÅÔ∏è Questions Preview' },
                        generateBtn: { ar: 'üöÄ ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≥ÿ¶ŸÑÿ©', en: 'üöÄ Generate Questions' },
                        analyzeBtn: { ar: 'üëÅÔ∏è ÿπÿ±ÿ∂', en: 'üëÅÔ∏è Preview' },
                        enhanceBtn: { ar: 'üíé ÿ™ÿ≠ÿ≥ŸäŸÜ ÿ®ÿßŸÑŸÄ AI', en: 'üíé Enhance with AI' },
                        convertBtn: { ar: 'üîÑ ÿ™ÿ≠ŸàŸäŸÑ ŸÑŸÄ JSON', en: 'üîÑ Convert to JSON' },
                        customizeBtn: { ar: '‚öôÔ∏è ÿ™ÿÆÿµŸäÿµ', en: '‚öôÔ∏è Customize' },
                        tagsBtn: { ar: 'üè∑Ô∏è Tags', en: 'üè∑Ô∏è Tags' },
                        clearBtn: { ar: 'üóëÔ∏è ŸÖÿ≥ÿ≠ ÿßŸÑŸÉŸÑ', en: 'üóëÔ∏è Clear All' },
                        langBtn: { ar: 'üåê English', en: 'üåê ÿßŸÑÿπÿ±ÿ®Ÿäÿ©' },
                        copyBtn: { ar: 'üìã ŸÜÿ≥ÿÆ JSON', en: 'üìã Copy JSON' },
                        downloadBtn: { ar: 'üíæ ÿ™ÿ≠ŸÖŸäŸÑ', en: 'üíæ Download' },
                        downloadZipBtn: { ar: 'üóúÔ∏è ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÄ ZIP', en: 'üóúÔ∏è Download as ZIP' },
                        csvBtn: { ar: 'üìÑ CSV', en: 'üìÑ CSV' },
                        subjectTemplateBtn: { ar: 'üìö Subject Template ID', en: 'üìö Subject Template ID' },
                        closeBtn: { ar: 'ÿ•ÿ∫ŸÑÿßŸÇ', en: 'Close' },
                        generationTitle: { ar: 'üöÄ ÿ™ŸàŸÑŸäÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä', en: 'üöÄ AI Question Generation' },
                        enterContent: { ar: '‚ë† ÿ£ÿØÿÆŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ', en: '‚ë† Enter Content' },
                        selectSettings: { ar: '‚ë° ÿ≠ÿØÿØ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™', en: '‚ë° Select Settings' },
                        multiPartQuestion: { ar: 'ÿ≥ÿ§ÿßŸÑ ŸÖÿ™ÿπÿØÿØ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°', en: 'Multi-part Question' },
                        addGuidelines: { ar: '‚ë¢ (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä) ÿ£ÿ∂ŸÅ ÿ™Ÿàÿ¨ŸäŸáÿßÿ™ ÿÆÿßÿµÿ©', en: '‚ë¢ (Optional) Add Special Guidelines' },
                    };

                    document.getElementById('main-title').innerHTML = translations.mainTitle[this.language];
                    document.getElementById('main-subtitle').innerHTML = translations.mainSubtitle[this.language];
                    document.getElementById('panel-title-1').innerHTML = translations.panelTitle1[this.language];
                    document.getElementById('panel-title-2').innerHTML = translations.panelTitle2[this.language];
                    document.getElementById('stats-title').innerHTML = translations.statsTitle[this.language];
                    document.getElementById('panel-title-4').innerHTML = translations.panelTitle4[this.language];
                    document.getElementById('generate-questions-btn').innerHTML = translations.generateBtn[this.language];
                    document.getElementById('smart-analyze-btn').innerHTML = translations.analyzeBtn[this.language];
                    document.getElementById('aiEnhanceBtn').innerHTML = translations.enhanceBtn[this.language];
                    document.getElementById('convert-json-btn').innerHTML = translations.convertBtn[this.language];
                    document.getElementById('customizeBtn').innerHTML = translations.customizeBtn[this.language];
                    document.getElementById('tagsBtn').innerHTML = translations.tagsBtn[this.language];
                    document.getElementById('clear-all-btn').innerHTML = translations.clearBtn[this.language];
                    document.getElementById('langSwitchBtn').innerHTML = translations.langBtn[this.language];
                    document.getElementById('copyBtn').innerHTML = translations.copyBtn[this.language];
                    document.getElementById('downloadBtn').innerHTML = translations.downloadBtn[this.language];
                    document.getElementById('downloadZipBtn').innerHTML = translations.downloadZipBtn[this.language];
                    document.getElementById('csvBtn').innerHTML = translations.csvBtn[this.language];
                    document.getElementById('subjectTemplateBtn').innerHTML = translations.subjectTemplateBtn[this.language];

                    // Update aria-labels dynamically
                    document.getElementById('generate-questions-btn').setAttribute('aria-label', translations.generateBtn[this.language]);
                    document.getElementById('smart-analyze-btn').setAttribute('aria-label', translations.analyzeBtn[this.language]);
                    document.getElementById('aiEnhanceBtn').setAttribute('aria-label', translations.enhanceBtn[this.language]);
                    document.getElementById('convert-json-btn').setAttribute('aria-label', translations.convertBtn[this.language]);
                    document.getElementById('customizeBtn').setAttribute('aria-label', translations.customizeBtn[this.language]);
                    document.getElementById('tagsBtn').setAttribute('aria-label', translations.tagsBtn[this.language]);
                    document.getElementById('clear-all-btn').setAttribute('aria-label', translations.clearBtn[this.language]);
                    document.getElementById('langSwitchBtn').setAttribute('aria-label', translations.langBtn[this.language]);
                    document.getElementById('copyBtn').setAttribute('aria-label', translations.copyBtn[this.language]);
                    document.getElementById('downloadBtn').setAttribute('aria-label', translations.downloadBtn[this.language]);
                    document.getElementById('downloadZipBtn').setAttribute('aria-label', translations.downloadZipBtn[this.language]);
                    document.getElementById('csvBtn').setAttribute('aria-label', translations.csvBtn[this.language]);

                    // Update modal close buttons aria-labels
                    document.getElementById('customize-modal-close-btn').setAttribute('aria-label', translations.closeBtn[this.language]);
                    document.getElementById('tags-modal-close-btn').setAttribute('aria-label', translations.closeBtn[this.language]);
                    document.getElementById('csv-modal-close-btn').setAttribute('aria-label', translations.closeBtn[this.language]);
                    document.getElementById('subject-template-modal-close-btn').setAttribute('aria-label', translations.closeBtn[this.language]);

                    // Update placeholders dynamically
                    const questionInputPlaceholder = this.language === this.Language.ARABIC ?
                        "ÿ£ÿØÿÆŸÑ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß...\nÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿ£Ÿä ÿ®ŸäÿßŸÜÿßÿ™ ŸàÿµŸÅŸäÿ© ŸÖÿ´ŸÑ id ÿ£Ÿà language (ŸÖÿß ÿπÿØÿß type ÿßŸÑÿ∞Ÿä ÿ≥Ÿäÿ∂ÿßŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß).\nŸäŸÖŸÉŸÜŸÉ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ™ŸÜÿ≥ŸäŸÇÿßÿ™ ŸÖÿÆÿ™ŸÑŸÅÿ© ŸÖÿ´ŸÑ:\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ŸÖÿ™ÿπÿØÿØ (MCQ)\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÜÿµ ÿßŸÑŸÇÿµŸäÿ± (String)\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖŸÇÿßŸÑŸäÿ© (FRQ)\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖŸÑÿ° ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™ (Gap Text)\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ŸàÿµŸäŸÑ (Matching)\n- ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿπÿØÿØÿ© ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°\n- Ÿàÿ∫Ÿäÿ±Ÿáÿß ŸÖŸÜ ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖÿØÿπŸàŸÖÿ©" :
                        "Enter question content here...\nAny metadata like id or language will be ignored (except type which will be added automatically).\nYou can use different formats like:\n- Multiple Choice Questions (MCQ)\n- Short Text Questions (String)\n- Essay Questions (FRQ)\n- Gap Fill Questions (Gap Text)\n- Matching Questions (Matching)\n- Multi-part Questions\n- And other supported types";
                    // Placeholder is now handled by data-placeholder attribute on the wrapper div
                    const questionInputWrapper = document.getElementById('questionInput');
                    if (questionInputWrapper) {
                        questionInputWrapper.setAttribute('data-placeholder', questionInputPlaceholder);
                    }

                    const apiKeyPlaceholder = this.language === this.Language.ARABIC ?
                        "üîë ÿ£ÿØÿÆŸÑ ŸÖŸÅÿ™ÿßÿ≠ API ŸáŸÜÿß" : "üîë Enter API key here";
                    document.getElementById('geminiApiKey').setAttribute('placeholder', apiKeyPlaceholder);
                    document.getElementById('openaiApiKey').setAttribute('placeholder', apiKeyPlaceholder);

                    // Update Generation Modal elements
                    document.getElementById('generation-title').innerHTML = translations.generationTitle[this.language];
                    document.querySelector('.generation-column h4').innerHTML = translations.enterContent[this.language];
                    document.querySelector('.generation-column:nth-child(2) h4').innerHTML = translations.selectSettings[this.language];
                    document.querySelector('label[for="gen-multi-part-count"]').innerHTML = translations.multiPartQuestion[this.language];
                    document.querySelector('.generation-column:nth-child(2) h4:nth-of-type(2)').innerHTML = translations.addGuidelines[this.language];

                    // Update Generation Modal placeholders
                    const genTextPlaceholder = this.language === this.Language.ARABIC ?
                        "ÿßŸÑÿµŸÇ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿØÿ±ÿ≥ ŸáŸÜÿß..." : "Paste lesson content here...";
                    document.getElementById('gen-text-input').setAttribute('placeholder', genTextPlaceholder);

                    const genMultiPartPlaceholder = this.language === this.Language.ARABIC ?
                        "ÿ£ŸÜŸàÿßÿπ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° (ŸÖÿ´ÿßŸÑ: mcq, string)" : "Part types (example: mcq, string)";
                    document.getElementById('gen-multi-part-types').setAttribute('placeholder', genMultiPartPlaceholder);

                    const genCustomPromptPlaceholder = this.language === this.Language.ARABIC ?
                        "ŸÖÿ´ÿßŸÑ: ÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸÅÿßŸáŸäŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©ÿå ÿßÿ¨ÿπŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÑŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ•ÿπÿØÿßÿØŸäÿ©..." : "Example: Focus on key concepts, make questions for preparatory stage...";
                    document.getElementById('gen-custom-prompt').setAttribute('placeholder', genCustomPromptPlaceholder);

                    // Update image drop zone text
                    const dropZoneText = this.language === this.Language.ARABIC ?
                        "ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ÿµŸàÿ±ÿ© ŸáŸÜÿßÿå ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±" : "Drag and drop an image here, or click to select";
                    document.querySelector('#gen-image-drop-zone p').innerHTML = dropZoneText;

                    this.displayResults();
                }
                openCustomizeModal() {
                    this._lastFocus = document.activeElement;
                    const modal = document.getElementById('customizeModal');
                    modal.style.display = 'flex';
                    document.getElementById('categorySelect').value = this.customization.category;
                    document.getElementById('langSelect').value = this.customization.lang;
                    document.getElementById('countrySelect').value = this.customization.country;
                    document.getElementById('dialectSelect').value = this.customization.dialect;

                    // Populate the source ID dropdown and set the value if available
                    this.populateSourceIdDropdown();

                    setTimeout(() => { modal.querySelector('#categorySelect')?.focus(); }, 0);
                }
                closeCustomizeModal() { document.getElementById('customizeModal').style.display = 'none'; if (this._lastFocus && typeof this._lastFocus.focus === 'function') { this._lastFocus.focus(); } }
                saveCustomization() {
                    this.customization.category = document.getElementById('categorySelect').value;
                    this.customization.lang = document.getElementById('langSelect').value;
                    this.customization.country = document.getElementById('countrySelect').value;
                    this.customization.dialect = document.getElementById('dialectSelect').value;
                    this.customization.sourceId = document.getElementById('sourceIdSelect').value;
                    this.saveSettings(); this.closeCustomizeModal();
                    this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™' : 'Settings saved', 'success');
                    if (document.getElementById('jsonOutput').style.display === 'block') this.convertToJSON();
                }
                saveSettings() {
                    localStorage.setItem('aiq_settings', JSON.stringify({ language: this.language, customization: this.customization }));
                }
                loadSettings() {
                    try {
                        const settings = JSON.parse(localStorage.getItem('aiq_settings'));
                        if (settings) {
                            if (settings.language) this.language = settings.language;
                            if (settings.customization) this.customization = { ...this.config.defaults, ...settings.customization };
                        }
                    } catch { }
                }

                populateSourceIdDropdown() {
                    const input = document.getElementById('sourceIdInput');
                    const dropdown = document.getElementById('sourceIdDropdown');
                    const hiddenSelect = document.getElementById('sourceIdSelect');

                    if (!input || !dropdown || !hiddenSelect) return;

                    // Store all source data for filtering
                    this.allSourceData = [
                        { source_id: 'none', name: 'none' },
                        ...this.sourceIdData
                    ];

                    // Set initial value
                    const savedValue = this.customization.sourceId || 'none';
                    const savedItem = this.allSourceData.find(item => item.source_id.toString() === savedValue);
                    if (savedItem) {
                        input.value = savedItem.name;
                        hiddenSelect.value = savedItem.source_id;
                    }

                    // Populate dropdown initially
                    this.filterSourceIdOptions('');

                    // Add event listeners
                    input.addEventListener('input', (e) => {
                        this.filterSourceIdOptions(e.target.value);
                        dropdown.style.display = 'block';
                        this.selectedIndex = -1; // Reset selection when typing
                    });

                    input.addEventListener('focus', () => {
                        dropdown.style.display = 'block';
                    });

                    input.addEventListener('blur', (e) => {
                        // Delay hiding to allow clicking on options
                        setTimeout(() => {
                            dropdown.style.display = 'none';
                        }, 200);
                    });

                    // Keyboard navigation
                    input.addEventListener('keydown', (e) => {
                        const options = dropdown.querySelectorAll('.source-id-option');

                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            this.selectedIndex = Math.min(this.selectedIndex + 1, options.length - 1);
                            this.highlightOption(options);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
                            this.highlightOption(options);
                        } else if (e.key === 'Enter') {
                            e.preventDefault();
                            if (this.selectedIndex >= 0 && options[this.selectedIndex]) {
                                options[this.selectedIndex].click();
                            }
                        } else if (e.key === 'Escape') {
                            dropdown.style.display = 'none';
                            input.blur();
                        }
                    });

                    // Close dropdown when clicking outside
                    document.addEventListener('click', (e) => {
                        if (!e.target.closest('#sourceIdContainer')) {
                            dropdown.style.display = 'none';
                        }
                    });
                }

                filterSourceIdOptions(searchTerm) {
                    const dropdown = document.getElementById('sourceIdDropdown');
                    if (!dropdown) return;

                    // Clear existing options
                    dropdown.innerHTML = '';

                    // Filter options based on search term (search by name or ID)
                    const filteredData = this.allSourceData.filter(item =>
                        item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                        item.source_id.toString().includes(searchTerm)
                    );

                    // Create option elements
                    filteredData.forEach(item => {
                        const option = document.createElement('div');
                        option.className = 'source-id-option';
                        option.style.cssText = 'padding: 10px; cursor: pointer; border-bottom: 1px solid #f3f4f6; transition: background-color 0.2s;';
                        option.innerHTML = `
                        <div style="font-weight: 500; color: #374151;">${item.name}</div>
                        <div style="font-size: 12px; color: #6b7280;">ID: ${item.source_id}</div>
                    `;

                        // Add hover effect
                        option.addEventListener('mouseenter', () => {
                            option.style.backgroundColor = '#f3f4f6';
                        });
                        option.addEventListener('mouseleave', () => {
                            option.style.backgroundColor = 'white';
                        });

                        // Handle selection
                        option.addEventListener('click', () => {
                            this.selectSourceId(item);
                        });

                        dropdown.appendChild(option);
                    });

                    // Show "no results" if no matches
                    if (filteredData.length === 0) {
                        const noResults = document.createElement('div');
                        noResults.style.cssText = 'padding: 10px; color: #6b7280; text-align: center; font-style: italic;';
                        noResults.textContent = 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨';
                        dropdown.appendChild(noResults);
                    }
                }

                selectSourceId(item) {
                    const input = document.getElementById('sourceIdInput');
                    const hiddenSelect = document.getElementById('sourceIdSelect');
                    const dropdown = document.getElementById('sourceIdDropdown');

                    if (!input || !hiddenSelect || !dropdown) return;

                    // Update input and hidden field
                    input.value = item.name;
                    hiddenSelect.value = item.source_id;

                    // Hide dropdown
                    dropdown.style.display = 'none';

                    // Update customization and save
                    this.customization.sourceId = item.source_id;
                    this.saveSettings();

                    // Trigger conversion if needed
                    if (document.getElementById('jsonOutput').style.display === 'block') {
                        this.convertToJSON();
                    }
                }

                highlightOption(options) {
                    // Remove previous highlight
                    options.forEach(option => {
                        option.style.backgroundColor = 'white';
                    });

                    // Highlight selected option
                    if (this.selectedIndex >= 0 && options[this.selectedIndex]) {
                        options[this.selectedIndex].style.backgroundColor = '#e5e7eb';
                    }
                }
                saveApiKeys(provider, value) {
                    this.apiKeys[provider] = value.trim();
                    localStorage.setItem('aiq_api_keys', JSON.stringify(this.apiKeys));
                }
                loadApiKeys() {
                    try {
                        const keys = JSON.parse(localStorage.getItem('aiq_api_keys'));
                        if (keys) {
                            this.apiKeys = keys;
                            document.getElementById('geminiApiKey').value = this.apiKeys.gemini || '';
                            document.getElementById('openaiApiKey').value = this.apiKeys.openai || '';
                        }
                    } catch { }
                }
                openCSVModal() {
                    this._lastFocus = document.activeElement;
                    if (typeof Handsontable === 'undefined') { this.showMessage('Error: Table library not loaded.', 'error'); return; }
                    if (this.questions.length === 0) { this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ£ŸàŸÑÿßŸã.' : 'Please analyze questions first.', 'warning'); return; }
                    const columns = [
                        { data: 'Question Id', type: 'text' },
                        { data: 'Lang', type: 'text', readOnly: true },
                        { data: 'Lesson Id', type: 'text' },
                        { data: 'Attributes', type: 'text', readOnly: true },
                        { data: 'Category', type: 'text', readOnly: true },
                        { data: 'Dialect', type: 'text', readOnly: true }
                    ];
                    const saved = localStorage.getItem('aiq_csv_data');
                    let savedData = null;
                    try {
                        savedData = JSON.parse(saved);
                        if (!Array.isArray(savedData) || savedData.length !== this.questions.length) savedData = null;
                    } catch (e) { savedData = null; }
                    if (savedData) {
                        this.csvData = savedData;
                    } else {
                        this.csvData = this.questions.map((q) => ({
                            'Question Id': q.metadata.id,
                            'Lang': q.metadata.language || this.customization.lang,
                            'Lesson Id': '',
                            'Attributes': q.parts.map(p => this.questionTypeConfigs[p.type]?.jsonType || p.type).join(';'),
                            'Category': q.metadata.category || this.customization.category,
                            'Dialect': this.language === this.Language.ARABIC ? 'Modern_standard' : 'american, british'
                        }));
                    }
                    document.getElementById('csvModalBg').style.display = 'flex';
                    setTimeout(() => { document.getElementById('csv-save-btn')?.focus(); }, 0);
                    if (this.hotInstance) this.hotInstance.destroy();
                    this.hotInstance = new Handsontable(document.getElementById('hotTable'), {
                        data: this.csvData,
                        colHeaders: ['Question Id', 'Lang', 'Lesson Id', 'Attributes', 'Category', 'Dialect'],
                        columns: columns, rowHeaders: true, width: '100%', height: 500,
                        licenseKey: 'non-commercial-and-evaluation', manualColumnResize: true, stretchH: 'all'
                    });
                }
                closeCSVModal() {
                    document.getElementById('csvModalBg').style.display = 'none';
                    if (this.hotInstance) { this.hotInstance.destroy(); this.hotInstance = null; }
                    if (this._lastFocus && typeof this._lastFocus.focus === 'function') { this._lastFocus.focus(); }
                }
                saveCSVData() {
                    if (this.hotInstance) {
                        const tableData = this.hotInstance.getData();
                        this.csvData = tableData.map(row => ({
                            'Question Id': row[0],
                            'Lang': row[1],
                            'Lesson Id': row[2],
                            'Attributes': row[3],
                            'Category': row[4],
                            'Dialect': row[5]
                        }));
                        localStorage.setItem('aiq_csv_data', JSON.stringify(this.csvData));
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿ®ŸäÿßŸÜÿßÿ™ CSV' : 'CSV data saved successfully', 'success');
                        this.closeCSVModal();
                        this.displayResults();
                    }
                }
                _formatCsvCell(value) {
                    if (value === null || value === undefined) {
                        return '';
                    }
                    let stringValue = String(value);
                    if (/[",\n]/.test(stringValue)) {
                        stringValue = stringValue.replace(/"/g, '""');
                        return `"${stringValue}"`;
                    }
                    return stringValue;
                }
                generateCSVContent() {
                    const header = ['Question Id', 'Lang', 'Lesson Id', 'Attributes', 'Category', 'Dialect'];
                    if (this.csvData && this.csvData.length === this.questions.length) {
                        return this.getCSVString();
                    }
                    const csvRowsData = this.questions.map((q, idx) => {
                        const transformedQ = this.transformToAdvancedFormat(q, idx);
                        const firstType = q.parts && q.parts.length > 0 ? (this.questionTypeConfigs[q.parts[0].type]?.jsonType || q.parts[0].type) : "";
                        return [
                            transformedQ.metadata.id,
                            transformedQ.metadata.language,
                            '',
                            firstType,
                            transformedQ.metadata.category,
                            Array.isArray(transformedQ.metadata.dialect) ? transformedQ.metadata.dialect.join(', ') : transformedQ.metadata.dialect
                        ];
                    });

                    const rows = csvRowsData.map(rowData =>
                        rowData.map(cell => this._formatCsvCell(cell)).join(',')
                    );

                    return header.join(',') + '\n' + rows.join('\n');
                }
                getCSVString() {
                    const header = ['Question Id', 'Lang', 'Lesson Id', 'Attributes', 'Category', 'Dialect'];
                    const rows = this.csvData.map(row => {
                        return header.map(col => this._formatCsvCell(row[col])).join(',');
                    });
                    return header.join(',') + '\n' + rows.join('\n');
                }

                // Subject Template ID Functions
                openSubjectTemplateModal() {
                    this._lastFocus = document.activeElement;
                    if (this.questions.length === 0) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ£ŸàŸÑÿßŸã.' : 'Please analyze questions first.', 'warning');
                        return;
                    }

                    document.getElementById('subjectTemplateModalBg').style.display = 'flex';
                    setTimeout(() => { document.getElementById('subjectSelect')?.focus(); }, 0);
                    document.getElementById('subjectSelect').value = '';
                    document.getElementById('englishStageSelect').value = '';
                    document.getElementById('englishOptionsContainer').style.display = 'none';
                    this.updateSubjectQuestionsPreview();
                }

                closeSubjectTemplateModal() {
                    document.getElementById('subjectTemplateModalBg').style.display = 'none';
                    if (this._lastFocus && typeof this._lastFocus.focus === 'function') { this._lastFocus.focus(); }
                }

                updateSubjectQuestionsPreview() {
                    const selectedSubject = document.getElementById('subjectSelect').value;
                    const previewContainer = document.getElementById('subjectQuestionsPreview');
                    const englishContainer = document.getElementById('englishOptionsContainer');

                    // Handle English separately
                    if (selectedSubject === 'English') {
                        englishContainer.style.display = 'block';
                        this.populateEnglishStages();

                        const frqAiCount = this.questions.filter(q =>
                            q.parts.some(part => part.type === this.QuestionType.FRQ_AI)
                        ).length;

                        const stringCount = this.questions.filter(q =>
                            q.parts.some(part => part.type === this.QuestionType.STRING)
                        ).length;

                        // Show selected stage if available
                        const selectedGrade = this.selectedEnglishStage;
                        let stageInfo = '';
                        if (selectedGrade) {
                            const stage = this.getStageFromGrade(selectedGrade);
                            const templates = this.englishTemplatesByStage[stage] || [];
                            stageInfo = `
                            <div style="margin-top:15px; padding:10px; background:#dcfce7; border-radius:8px; border:1px solid #16a34a;">
                                <strong>‚úÖ ÿßŸÑÿµŸÅ ÿßŸÑŸÖÿÆÿ™ÿßÿ±:</strong> Grade ${selectedGrade}<br>
                                <strong>üéØ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©:</strong> ${stage ? stage.replace(/_/g, ' ') : 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}<br>
                                <strong>üìã ÿπÿØÿØ Templates ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©:</strong> ${templates.length}
                            </div>
                        `;
                        }

                        this.setSafeHTML(previewContainer, `
                        <div style="text-align:center; padding:20px;">
                            <div style="font-size:2em; margin-bottom:10px;">üá¨üáß</div>
                            <p style="color:#4338ca; font-weight:bold; margin-bottom:10px;">English Questions</p>
                            <div style="display:flex; gap:20px; justify-content:center; margin-top:15px;">
                                <div style="padding:10px 15px; background:#dbeafe; border-radius:8px;">
                                    <strong>FRQ_AI:</strong> ${frqAiCount}
                                </div>
                                <div style="padding:10px 15px; background:#fef3c7; border-radius:8px;">
                                    <strong>String:</strong> ${stringCount}
                                </div>
                            </div>
                            ${stageInfo}
                            <p style="color:#6b7280; font-size:0.9em; margin-top:15px;">${selectedStage ? 'ÿ≥Ÿäÿ∏Ÿáÿ± dropdown ŸÑŸÉŸÑ ÿ≥ÿ§ÿßŸÑ frq_ai ŸÅŸä ÿßŸÑŸÖÿπÿßŸäŸÜÿ©' : 'ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© Ÿàÿ≥Ÿäÿ∏Ÿáÿ± dropdown ŸÑŸÉŸÑ ÿ≥ÿ§ÿßŸÑ frq_ai ŸÅŸä ÿßŸÑŸÖÿπÿßŸäŸÜÿ©'}</p>
                        </div>
                    `);
                        return;
                    } else {
                        englishContainer.style.display = 'none';
                        this.selectedEnglishStage = null;
                    }

                    if (!selectedSubject) {
                        this.setSafeHTML(previewContainer, '<p style="text-align:center; color:#6b7280;">ÿ≥ÿ™ÿ∏Ÿáÿ± ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ§ŸáŸÑÿ© ŸáŸÜÿß ÿ®ÿπÿØ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖÿßÿØÿ©</p>');
                        return;
                    }

                    const templateId = this.subjectTemplateMap[selectedSubject];
                    if (!templateId) {
                        this.setSafeHTML(previewContainer, '<p style="text-align:center; color:#ef4444;">ÿÆÿ∑ÿ£: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ Template ID ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿßÿØÿ©</p>');
                        return;
                    }

                    const eligibleQuestions = this.questions.filter((q, index) => {
                        return q.parts.some(part =>
                            part.type === this.QuestionType.FRQ_AI ||
                            part.type === this.QuestionType.STRING
                        );
                    });

                    if (eligibleQuestions.length === 0) {
                        this.setSafeHTML(previewContainer, '<p style="text-align:center; color:#f59e0b;">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖŸÜ ŸÜŸàÿπ frq_ai ÿ£Ÿà string ŸÑÿ™ÿ∑ÿ®ŸäŸÇ Template ID ÿπŸÑŸäŸáÿß</p>');
                        return;
                    }

                    let html = `<div style="margin-bottom:15px; padding:10px; background:#dcfce7; border-radius:8px; border:1px solid #16a34a;">
                    <strong>ÿßŸÑŸÖÿßÿØÿ© ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ©:</strong> ${selectedSubject}<br>
                    <strong>Template ID:</strong> ${templateId}<br>
                    <strong>ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ§ŸáŸÑÿ©:</strong> ${eligibleQuestions.length}
                </div>`;

                    html += '<div style="max-height:200px; overflow-y:auto;">';
                    eligibleQuestions.forEach((q, index) => {
                        const questionId = q.metadata.id;
                        const parts = q.parts.filter(part =>
                            part.type === this.QuestionType.FRQ_AI ||
                            part.type === this.QuestionType.STRING
                        );

                        html += `<div style="margin-bottom:10px; padding:8px; background:white; border-radius:6px; border:1px solid #e2e8f0;">
                        <strong>ÿßŸÑÿ≥ÿ§ÿßŸÑ ${index + 1} (ID: ${questionId})</strong><br>
                        <small>ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° ÿßŸÑŸÖÿ§ŸáŸÑÿ©: ${parts.map(p => p.type).join(', ')}</small>
                    </div>`;
                    });
                    html += '</div>';

                    this.setSafeHTML(previewContainer, html);
                }

                populateEnglishStages() {
                    const stageSelect = document.getElementById('englishStageSelect');
                    const currentValue = stageSelect.value; // Save current selection

                    stageSelect.innerHTML = '<option value="">-- ÿßÿÆÿ™ÿ± ÿßŸÑÿµŸÅ --</option>';

                    // Use grade mapping
                    const grades = Object.keys(this.gradeMapping);
                    grades.sort((a, b) => parseInt(a) - parseInt(b)).forEach(grade => {
                        const option = document.createElement('option');
                        option.value = grade;
                        option.textContent = `Grade ${grade}`;
                        stageSelect.appendChild(option);
                    });

                    // Restore selection if it was previously selected
                    if (currentValue && this.gradeMapping[currentValue]) {
                        stageSelect.value = currentValue;
                    }
                }

                saveSubjectTemplateData() {
                    const selectedSubject = document.getElementById('subjectSelect').value;

                    if (!selectedSubject) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ŸÖÿßÿØÿ© ÿ£ŸàŸÑÿßŸã' : 'Please select a subject first', 'warning');
                        return;
                    }

                    // Handle English separately
                    if (selectedSubject === 'English') {
                        const stage = document.getElementById('englishStageSelect').value;

                        if (!stage) {
                            this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©' : 'Please select stage', 'warning');
                            return;
                        }

                        this.selectedEnglishStage = stage;

                        // Apply fixed template ID to String questions
                        const stringTemplateId = '593158513739';
                        let stringCount = 0;

                        this.questions.forEach(q => {
                            q.parts.forEach(part => {
                                if (part.type === this.QuestionType.STRING) {
                                    part.metadata.ai_template_id = stringTemplateId;
                                    stringCount++;
                                }
                            });

                            if (q.parts.some(part => part.type === this.QuestionType.STRING)) {
                                q.metadata.ai_template_id = stringTemplateId;
                            }
                        });

                        this.showMessage(
                            this.language === this.Language.ARABIC
                                ? `ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä ŸÑŸÑŸÖÿ±ÿ≠ŸÑÿ© ${stage.replace(/_/g, ' ')}. ÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ Template ID ÿßŸÑÿ´ÿßÿ®ÿ™ (${stringTemplateId}) ÿπŸÑŸâ ${stringCount} ÿ≥ÿ§ÿßŸÑ String. ÿßŸÑÿ¢ŸÜ ŸäŸÖŸÉŸÜŸÉ ÿßÿÆÿ™Ÿäÿßÿ± Template ID ŸÑŸÉŸÑ ÿ≥ÿ§ÿßŸÑ frq_ai ŸÖŸÜ ÿßŸÑŸÖÿπÿßŸäŸÜÿ©.`
                                : `English settings saved for stage ${stage.replace(/_/g, ' ')}. Fixed Template ID (${stringTemplateId}) applied to ${stringCount} String questions. Now you can select Template ID for each frq_ai question from preview.`,
                            'success'
                        );

                        this.closeSubjectTemplateModal();
                        this.displayResults(); // Re-render preview with dropdowns
                        return;
                    }

                    // Handle other subjects (existing code)
                    const templateId = this.subjectTemplateMap[selectedSubject];
                    if (!templateId) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿÆÿ∑ÿ£: ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ Template ID ŸÑŸáÿ∞Ÿá ÿßŸÑŸÖÿßÿØÿ©' : 'Error: Template ID not found for this subject', 'error');
                        return;
                    }

                    let appliedCount = 0;

                    this.questions.forEach(q => {
                        q.parts.forEach(part => {
                            if (part.type === this.QuestionType.FRQ_AI || part.type === this.QuestionType.STRING) {
                                part.metadata.ai_template_id = templateId;
                                appliedCount++;
                            }
                        });

                        if (q.parts.some(part => part.type === this.QuestionType.FRQ_AI || part.type === this.QuestionType.STRING)) {
                            q.metadata.ai_template_id = templateId;
                        }
                    });

                    this.showMessage(
                        this.language === this.Language.ARABIC
                            ? `ÿ™ŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ Template ID (${templateId}) ÿπŸÑŸâ ${appliedCount} ÿ¨ÿ≤ÿ° ŸÖŸÜ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©`
                            : `Applied Template ID (${templateId}) to ${appliedCount} question parts`,
                        'success'
                    );

                    this.closeSubjectTemplateModal();

                    if (document.getElementById('jsonOutput').style.display === 'block') {
                        this.convertToJSON();
                    }

                    this.displayResults();
                }

                // --- TAGS MODAL ---
                populateTagsModal() {
                    // Organize templates into categories
                    const templateGroups = [
                        {
                            title: 'ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ£ÿ≥ÿßÿ≥Ÿäÿ© (Basic Questions)',
                            items: [
                                { name: 'MCQ', hint: 'ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ŸÖÿ™ÿπÿØÿØ (ŸÜÿ¨ŸÖÿ© Ÿàÿßÿ≠ÿØÿ© ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©)', content: 'type: mcq\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@CHOICES\n* ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµÿ≠Ÿäÿ≠\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n---\n' },
                                { name: 'MRQ', hint: 'ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ© ÿµÿ≠Ÿäÿ≠ÿ© (ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÜÿ¨ŸÖÿ©)', content: 'type: mrq\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@CHOICES\n* ÿßÿÆÿ™Ÿäÿßÿ± ÿµÿ≠Ÿäÿ≠\n* ÿßÿÆÿ™Ÿäÿßÿ± ÿµÿ≠Ÿäÿ≠\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n---\n' },
                                { name: 'OQ (ÿ™ÿ±ÿ™Ÿäÿ®)', hint: 'ÿ™ÿ±ÿ™Ÿäÿ® ÿπŸÜÿßÿµÿ± ÿ®ÿØŸàŸÜ ŸÜÿ¨ŸàŸÖ (ÿ≥Ÿäÿ™ŸÖ ÿßÿπÿ™ÿ®ÿßÿ±Ÿáÿß ÿ™ÿ±ÿ™Ÿäÿ®Ÿãÿß)', content: 'type: oq\n@STEM\nÿ±ÿ™Ÿëÿ® ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑÿ™ÿßŸÑŸäÿ©\n\n@CHOICES\n- ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ£ŸàŸÑ\n- ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ´ÿßŸÜŸä\n- ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ´ÿßŸÑÿ´\n- ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ±ÿßÿ®ÿπ\n---\n' },
                                { name: 'Matching', hint: 'ÿ™ŸàÿµŸäŸÑ ÿ£ÿ≤Ÿàÿßÿ¨ ÿßŸÑÿπŸÜÿßÿµÿ± ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ |', content: 'type: matching\n@STEM\n\n@MATCHING_PAIRS\nÿßŸÑŸÜÿµ 1 | ÿßŸÑŸÜÿ∏Ÿäÿ± 1\nÿßŸÑŸÜÿµ 2 | ÿßŸÑŸÜÿ∏Ÿäÿ± 2\nÿßŸÑŸÜÿµ 3 | ÿßŸÑŸÜÿ∏Ÿäÿ± 3\n---\n' }
                            ]
                        },
                        {
                            title: 'ŸÜÿµŸäÿ© Ÿàÿ•ÿØÿÆÿßŸÑ (Text & Input)',
                            items: [
                                { name: 'String', hint: 'ŸÜÿµ ŸÇÿµŸäÿ± ŸÉÿ•ÿ¨ÿßÿ®ÿ©', content: 'type: string\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@ANSWER\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© ŸáŸÜÿß\n---\n' },
                                { name: 'Gap Text', hint: 'ŸÖŸÑÿ° ŸÅÿ±ÿßÿ∫ÿßÿ™: ÿßŸÉÿ™ÿ® ÿßŸÑÿ¨ŸÖŸÑ Ÿàÿ∂ÿπ ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™ ŸàÿßŸÖŸÑÿ£ @GAPS', content: 'type: gapText\n@STEM\nÿßŸÉÿ™ÿ® ÿßŸÑŸÜÿµ ŸÖÿπ [ŸÅÿ±ÿßÿ∫] ŸáŸÜÿß\n@BLANK\n@GAPS\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© 1\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© 2\n---\n' },
                                { name: 'Input Box', hint: 'ŸÇŸäŸÖÿ© + Ÿàÿ≠ÿØÿ© ŸÖŸÅÿµŸàŸÑÿ© ÿ®ŸÄ |', content: 'type: input_box\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@ANSWER\n12 | cm\n---\n' }
                            ]
                        },
                        {
                            title: 'ÿ∞ŸÉÿßÿ° ÿßÿµÿ∑ŸÜÿßÿπŸä (AI Powered)',
                            items: [
                                { name: 'FRQ (AI)', hint: 'ÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸÇÿßŸÑŸäÿ© Ÿäÿ™ŸÖ ÿ™ŸÇŸäŸäŸÖŸáÿß ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä', content: 'type: frq_ai\nai_template_id: 593158513739\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@ANSWER\nÿ•ÿ¨ÿßÿ®ÿ© ŸÜŸÖŸàÿ∞ÿ¨Ÿäÿ© ŸÖÿÆÿ™ÿµÿ±ÿ©\n---\n' },
                                { name: 'String (AI)', hint: 'ŸÜÿµ ŸÇÿµŸäÿ± ŸÖÿπ ÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ÿ∞ŸÉÿßÿ° ÿßÿµÿ∑ŸÜÿßÿπŸä ŸÑÿ™ŸÇŸäŸäŸÖ ÿ•ÿ¨ÿßÿ®ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ© ŸÖÿπ ÿØÿ±ÿ¨ÿßÿ™ Ÿàÿ™ÿπŸÑŸäŸÇÿßÿ™', content: 'type: string\nai_template_id: 593158513739\n@STEM\nÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸáŸÜÿß\n\n@ANSWER\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© ŸáŸÜÿß\n\n@GUIDELINES\nÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ® 1 - 1 - ÿ™ÿπŸÑŸäŸÇ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© 1\nÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ® 2 - 0 - ÿ™ÿπŸÑŸäŸÇ ÿπŸÑŸâ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© 2\n---\n' }
                            ]
                        },
                        {
                            title: 'ŸáŸäŸÉŸÑŸäÿ© (Structural)',
                            items: [
                                { name: 'Multi-Part', hint: 'ÿ≥ÿ§ÿßŸÑ ŸÖÿ™ÿπÿØÿØ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ @STATEMENT Ÿà @PART', content: '@STATEMENT\nŸÖŸÇÿØŸÖÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿπÿßŸÖÿ©\n@PART\ntype: mcq\n@STEM\nŸÜÿµ ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ£ŸàŸÑ\n@CHOICES\n* ÿµÿ≠Ÿäÿ≠\n- ÿÆÿ∑ÿ£\n@PART\ntype: string\n@STEM\nŸÜÿµ ÿßŸÑÿ¨ÿ≤ÿ° ÿßŸÑÿ´ÿßŸÜŸä\n@ANSWER\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸáŸÜÿß\n---\n' },
                                { name: 'Task-Based', hint: 'ÿ≥ÿ§ÿßŸÑ ŸÇÿßÿ¶ŸÖ ÿπŸÑŸâ ÿßŸÑŸÖŸáŸÖÿ© ŸÖÿπ ŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ©', content: 'type: mcq\n@OVERVIEW\nŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿ£Ÿà ÿßŸÑÿ≥ŸäÿßŸÇ\n@TASK\nÿßŸÑŸÖŸáŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÖŸÜ ÿßŸÑÿ∑ÿßŸÑÿ®\n@STEM\nŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä\n@CHOICES\n* ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿµÿ≠Ÿäÿ≠\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n- ÿßÿÆÿ™Ÿäÿßÿ± ÿÆÿßÿ∑ÿ¶\n---\n' },
                                { name: 'Poem', hint: 'ŸÇÿßŸÑÿ® ÿ¥ÿπÿ±: ÿ∂ÿπ ÿßŸÑÿ£ÿ®Ÿäÿßÿ™ ÿ®ŸäŸÜ @POEM Ÿà @END_POEM', content: 'type: string\n@STEM\n@POEM\nÿ±ŸéŸÖŸéŸàŸÜŸä ÿ®ÿπŸèŸÇŸÖŸç ŸÅŸä ÿßŸÑÿ¥ÿ®ÿßÿ® ŸàŸÑŸäÿ™ŸÜŸä\nÿπŸÇŸêŸÖÿ™Ÿè ŸÅŸÑŸÖ ÿ£ÿ¨Ÿíÿ≤ÿπŸí ŸÑŸÇŸàŸÑŸê ÿπŸêÿØÿßÿ™Ÿä\nÿ£ŸÜÿß ÿßŸÑÿ®ÿ≠ÿ± ŸÅŸä ÿ£ÿ≠ÿ¥ÿßÿ¶Ÿá ÿßŸÑÿØÿ±ŸèŸë ŸÉÿßŸÖŸÜŸå\nŸÅŸáŸÑ ÿ≥ÿßÿ°ŸéŸÑŸàÿß ÿßŸÑÿ∫ŸàŸéŸëÿßÿµŸé ÿπŸÜ ÿµŸéÿØŸéŸÅÿßÿ™Ÿäÿü\n@END_POEM\n\n@ANSWER\n...\n---\n' },
                                { name: 'Overview-Only', hint: 'ÿ≥ÿ§ÿßŸÑ ŸÖÿπ ŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ© ŸÅŸÇÿ∑', content: 'type: string\n@OVERVIEW\nŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿ£Ÿà ÿßŸÑÿ≥ŸäÿßŸÇ\n@STEM\nŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä\n@ANSWER\nÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸáŸÜÿß\n---\n' }
                            ]
                        }
                    ];

                    // Organize tags into categories
                    const tagGroups = [
                        {
                            title: 'Ÿàÿ≥ŸàŸÖ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ (Content Tags)',
                            items: [
                                { tag: '@STEM', hint: 'ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä' },
                                { tag: '@CHOICES', hint: 'ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ (ÿπŸÜÿµÿ± ŸÅŸä ŸÉŸÑ ÿ≥ÿ∑ÿ±)' },
                                { tag: '@ANSWER', hint: 'ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© (String/FRQ_AI/Input Box)' },
                                { tag: '@GAPS', hint: 'ÿ•ÿ¨ÿßÿ®ÿßÿ™ ŸÖŸÑÿ° ÿßŸÑŸÅÿ±ÿßÿ∫ÿßÿ™ (ŸÉŸÑ ÿ•ÿ¨ÿßÿ®ÿ© ŸÅŸä ÿ≥ÿ∑ÿ±)' },
                                { tag: '@MATCHING_PAIRS', hint: 'ÿ£ÿ≤Ÿàÿßÿ¨ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ© (ÿßŸÅÿµŸÑ ÿ®ŸäŸÜŸáÿß ÿ®ŸÄ |)' },
                                { tag: '@BLANK', hint: 'Ÿàÿ∂ÿπ ŸÅÿ±ÿßÿ∫ ÿØÿßÿÆŸÑ ŸÜÿµ ÿßŸÑÿ¨ŸÖŸÑÿ©' }
                            ]
                        },
                        {
                            title: 'ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÜŸàÿπ (Type Definition)',
                            items: [
                                { tag: 'type: mcq', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: MCQ' },
                                { tag: 'type: mrq', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: MRQ' },
                                { tag: 'type: oq', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: OQ (ÿ™ÿ±ÿ™Ÿäÿ®)' },
                                { tag: 'type: matching', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: Matching' },
                                { tag: 'type: gapText', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: Gap Text' },
                                { tag: 'type: string', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: String' },
                                { tag: 'type: frq_ai', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: FRQ (AI)' },
                                { tag: 'type: input_box', hint: 'ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ¨ÿ≤ÿ°: Input Box' }
                            ]
                        },
                        {
                            title: 'ŸáŸäŸÉŸÑ ŸàŸÖÿ≥ÿßÿπÿØÿ© (Structure & Guidelines)',
                            items: [
                                { tag: '@STATEMENT', hint: 'ŸÖŸÇÿØŸÖÿ© ÿ™ÿ≥ÿ®ŸÇ ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ°' },
                                { tag: '@PART', hint: 'ÿ¨ÿ≤ÿ° ÿ¨ÿØŸäÿØ ÿØÿßÿÆŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ' },
                                { tag: '@OVERVIEW', hint: 'ŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿ£Ÿà ÿßŸÑÿ≥ŸäÿßŸÇ' },
                                { tag: '@TASK', hint: 'ŸàÿµŸÅ ÿßŸÑŸÖŸáŸÖÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÖŸÜ ÿßŸÑÿ∑ÿßŸÑÿ®' },
                                { tag: '@GUIDELINES', hint: 'ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ ŸÑÿ£ÿ≥ÿ¶ŸÑÿ© String (ÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ® - ÿπŸÑÿßŸÖÿ© - ÿ™ÿπŸÑŸäŸÇ)' }
                            ]
                        },
                        {
                            title: 'ÿ£ÿÆÿ±Ÿâ (Misc)',
                            items: [
                                { tag: '@POEM', hint: 'ÿ®ÿØÿßŸäÿ© ŸÖŸÇÿ∑ÿπ ÿ¥ÿπÿ± (ÿ£ÿ®Ÿäÿßÿ™ ŸÅŸä ÿ£ÿ≥ÿ∑ÿ± ŸÖŸÜŸÅÿµŸÑÿ©)ÿõ ÿ£ÿÆÿ™ŸÖ ÿ®ŸÄ @END_POEM' },
                                { tag: '@END_POEM', hint: 'ŸÜŸáÿßŸäÿ© ŸÖŸÇÿ∑ÿπ ÿßŸÑÿ¥ÿπÿ±' },
                                { tag: '[U]', hint: 'Ÿàÿ∂ÿπ ÿÆÿ∑ ÿ™ÿ≠ÿ™ ÿßŸÑŸÜÿµ: [U]ÿßŸÑŸÜÿµ[/U]' },
                                { tag: '---', hint: 'ÿÆÿ∑ ŸÅÿßÿµŸÑ ÿ®ŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©' }
                            ]
                        }
                    ];

                    const templatesContainer = document.querySelector('#templates-section');
                    const tagsContainer = document.querySelector('#tags-section');

                    // Clear existing grids
                    const templatesGrid = templatesContainer.querySelector('.tags-grid');
                    const tagsGrid = tagsContainer.querySelector('.tags-grid');
                    templatesGrid.innerHTML = '';
                    tagsGrid.innerHTML = '';

                    // Render template groups
                    templateGroups.forEach(group => {
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'tag-group';
                        
                        const titleDiv = document.createElement('div');
                        titleDiv.className = 'tag-group-title';
                        titleDiv.textContent = group.title;
                        groupDiv.appendChild(titleDiv);
                        
                        const gridDiv = document.createElement('div');
                        gridDiv.className = 'tags-grid';
                        
                        group.items.forEach(item => {
                            const btn = document.createElement('button');
                            btn.className = 'tag-btn';
                            btn.textContent = item.name;
                            btn.title = item.hint;
                            btn.dataset.tag = item.content;
                            gridDiv.appendChild(btn);
                        });
                        
                        groupDiv.appendChild(gridDiv);
                        templatesContainer.appendChild(groupDiv);
                    });

                    // Render tag groups
                    tagGroups.forEach(group => {
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'tag-group';
                        
                        const titleDiv = document.createElement('div');
                        titleDiv.className = 'tag-group-title';
                        titleDiv.textContent = group.title;
                        groupDiv.appendChild(titleDiv);
                        
                        const gridDiv = document.createElement('div');
                        gridDiv.className = 'tags-grid';
                        
                        group.items.forEach(item => {
                            const btn = document.createElement('button');
                            btn.className = 'tag-btn';
                            btn.textContent = item.tag;
                            btn.title = item.hint;
                            btn.dataset.tag = item.tag;
                            gridDiv.appendChild(btn);
                        });
                        
                        groupDiv.appendChild(gridDiv);
                        tagsContainer.appendChild(groupDiv);
                    });

                    // Use event delegation for all tag buttons
                    document.getElementById('tagsModalBody').addEventListener('click', (e) => {
                        if (e.target.classList.contains('tag-btn')) {
                            this.insertTag(e.target.dataset.tag);
                        }
                    });
                }

                insertTag(tag) {
                    // For rich text editor, we need to insert at cursor position
                    const editor = document.getElementById('questionInput-editor');
                    if (editor) {
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.deleteContents();
                            
                            // Create highlighted span for the tag
                            const span = document.createElement('span');
                            span.className = 'editor-keyword';
                            span.textContent = tag;
                            
                            // Insert the highlighted tag
                            range.insertNode(span);
                            
                            // Insert a space after the tag for better UX
                            const spaceNode = document.createTextNode('\u00A0');
                            range.setStartAfter(span);
                            range.insertNode(spaceNode);
                            
                            // Move cursor after the space
                            range.setStartAfter(spaceNode);
                            range.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            editor.focus();
                        } else {
                            // Fallback: append at end with highlighting
                            const currentValue = getQuestionInputValue();
                            const highlightedTag = `<span class="editor-keyword">${tag}</span>&nbsp;`;
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = currentValue + highlightedTag;
                            editor.appendChild(tempDiv);
                            editor.focus();
                        }
                    }
                }

                toggleTagsModal(show) {
                    const modal = document.getElementById('tagsModal');
                    const isVisible = modal.style.display === 'flex' || modal.style.display === 'block';
                    const shouldShow = typeof show === 'boolean' ? show : !isVisible;
                    if (shouldShow) {
                        this._lastFocus = document.activeElement;
                        modal.style.display = 'flex';
                        setTimeout(() => { document.getElementById('tags-modal-close-btn')?.focus(); }, 0);
                    } else {
                        modal.style.display = 'none';
                        if (this._lastFocus && typeof this._lastFocus.focus === 'function') { this._lastFocus.focus(); }
                    }
                }

                makeModalDraggable() {
                    const modal = document.getElementById('tagsModal');
                    const header = document.getElementById('tagsModalHeader');
                    let isDragging = false;
                    let offsetX, offsetY;

                    header.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        offsetX = e.clientX - modal.offsetLeft;
                        offsetY = e.clientY - modal.offsetTop;
                        document.body.style.userSelect = 'none';
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (isDragging) {
                            modal.style.left = `${e.clientX - offsetX}px`;
                            modal.style.top = `${e.clientY - offsetY}px`;
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                        document.body.style.userSelect = '';
                    });
                }

                // --- NEW FEATURES ---
                cleanAndFormat() {
                    let text = getQuestionInputValue();

                    // Basic formatter that tries to detect and format different question types
                    const lines = text.split(/[\n\r]+/).map(l => l.trim()).filter(l => l);

                    if (lines.length === 0) {
                        this.showMessage('ŸÑÿß ŸäŸàÿ¨ÿØ ŸÜÿµ ŸÑÿ™ŸÜÿ≥ŸäŸÇŸá.', 'warning');
                        return;
                    }

                    let formattedText = '';
                    let currentStem = '';
                    let currentChoices = [];
                    let inQuestion = false;

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];

                        // Check if this is a choice line (starts with a), 1), ÿ£), etc.)
                        const isChoice = /^([a-zA-Z\u0623-\u064A0-9])[.)]\s*(.+)/.test(line);

                        if (isChoice) {
                            // Extract choice text
                            const choiceText = line.replace(/^[a-zA-Z\u0623-\u064A0-9]+[.)]\s*/, '').trim();
                            currentChoices.push(choiceText);
                            inQuestion = true;
                        } else {
                            // Not a choice line
                            if (inQuestion && currentChoices.length > 0) {
                                // We have collected a question, format it
                                formattedText += this._formatQuestion(currentStem, currentChoices);
                                currentStem = '';
                                currentChoices = [];
                                inQuestion = false;
                            }

                            // This line is part of the stem
                            if (currentStem) currentStem += ' ';
                            currentStem += line;
                        }
                    }

                    // Handle the last question if any
                    if (currentChoices.length > 0) {
                        formattedText += this._formatQuestion(currentStem, currentChoices);
                    }

                    if (!formattedText) {
                        // No structured questions found, just clean up the text
                        formattedText = lines.join('\n');
                        this.showMessage('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÜŸÖÿ∑ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿπÿ±ŸàŸÅ. ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿµ ŸÅŸÇÿ∑.', 'info');
                    } else {
                        this.showMessage('ÿ™ŸÖ ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜÿµ ÿ®ŸÜÿ¨ÿßÿ≠.', 'success');
                    }

                    this.setInputText(formattedText.trim());
                    this.runLiveValidation();
                }

                _formatQuestion(stem, choices) {
                    // Auto-detect question type based on active type or default to MCQ
                    const type = this.activeQuestionType !== this.QuestionType.UNKNOWN ?
                        this.questionTypeConfigs[this.activeQuestionType]?.jsonType || 'mcq' : 'mcq';

                    let formatted = `type: ${type}\n@STEM\n${stem.trim()}\n`;

                    // Format choices based on question type
                    if (type === 'mcq' || type === 'mrq' || type === 'oq') {
                        formatted += '@CHOICES\n';
                        choices.forEach(choice => {
                            formatted += `- ${choice}\n`;
                        });
                    } else if (type === 'matching') {
                        formatted += '@CHOICES\n';
                        const half = Math.ceil(choices.length / 2);
                        for (let i = 0; i < half; i++) {
                            formatted += `- ${choices[i]}\n`;
                        }
                        formatted += '@PAIRS\n';
                        for (let i = half; i < choices.length; i++) {
                            formatted += `- ${choices[i]}\n`;
                        }
                    } else {
                        // For other types, just add choices as is
                        formatted += '@CHOICES\n';
                        choices.forEach(choice => {
                            formatted += `- ${choice}\n`;
                        });
                    }

                    formatted += '---\n';
                    return formatted;
                }

                runLiveValidation() {
                    const text = this.getInputText();
                    const blocks = text.trim().split(/\n---\n/);

                    this.questions = blocks.filter(block => block.trim()).map((block, index) => {
                        const q = this._parseQuestionBlock(block, index);
                        q.validationWarning = this.validateQuestion(q);
                        return q;
                    });

                    this.displayResults();
                }

                validateQuestion(q) {
                    // Get valid question types
                    const validTypes = Object.values(this.QuestionType).filter(t => t !== this.QuestionType.UNKNOWN);

                    // Check Source ID selection (only during export validation)
                    if (this.questions.length > 0) { // Only check during export, not during live validation
                        const sourceIdSelect = document.getElementById('sourceIdSelect');
                        if (!sourceIdSelect || !sourceIdSelect.value || sourceIdSelect.value.trim() === '' || sourceIdSelect.value === 'none') {
                            return this.language === this.Language.ARABIC ?
                                'Ÿäÿ¨ÿ® ÿßÿÆÿ™Ÿäÿßÿ± Source ID ÿµÿ≠Ÿäÿ≠ ŸÇÿ®ŸÑ ÿßŸÑÿ™ÿµÿØŸäÿ±.' :
                                'Please select a valid Source ID before export.';
                        }
                    }

                    // Validate metadata (if present in export format)
                    if (q.metadata) {
                        // Check required metadata fields
                        if (!q.metadata.id) {
                            return this.language === this.Language.ARABIC ?
                                'Metadata: ÿ≠ŸÇŸÑ id ŸÖÿ∑ŸÑŸàÿ®.' :
                                'Metadata: Missing required field "id".';
                        }

                        // Validate category
                        if (q.metadata.category && !['lesson', 'exam'].includes(q.metadata.category)) {
                            return this.language === this.Language.ARABIC ?
                                `Metadata: category Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ "lesson" ÿ£Ÿà "exam".` :
                                `Metadata: Invalid category "${q.metadata.category}". Must be "lesson" or "exam".`;
                        }

                        // Validate country
                        if (q.metadata.country && q.metadata.country !== 'eg') {
                            return this.language === this.Language.ARABIC ?
                                'Metadata: country Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ "eg".' :
                                'Metadata: country must be "eg".';
                        }

                        // Validate source_id structure
                        if (q.metadata.source_id && (typeof q.metadata.source_id !== 'object' || !q.metadata.source_id.value)) {
                            return this.language === this.Language.ARABIC ?
                                'Metadata: source_id Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ object Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ value.' :
                                'Metadata: source_id must be an object with a "value" key.';
                        }

                        // Validate dialect
                        if (q.metadata.dialect && (!Array.isArray(q.metadata.dialect) || q.metadata.dialect.length === 0)) {
                            return this.language === this.Language.ARABIC ?
                                'Metadata: dialect Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.' :
                                'Metadata: dialect must be a non-empty array.';
                        }
                    }

                    // Validate multipart statement
                    if (q.parts && q.parts.length > 1 && !q.statement) {
                        return this.language === this.Language.ARABIC ?
                            'ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿπÿØÿØÿ© ÿßŸÑÿ£ÿ¨ÿ≤ÿßÿ° Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ≠ŸÇŸÑ statement.' :
                            'Multipart questions must have a "statement" field.';
                    }

                    for (let partIndex = 0; partIndex < q.parts.length; partIndex++) {
                        const part = q.parts[partIndex];
                        const partNum = partIndex + 1;

                        // Validate part number 'n' (if present in export format)
                        if (part.n !== undefined && part.n !== partNum) {
                            return this.language === this.Language.ARABIC ?
                                `Part ${partNum}: ÿ±ŸÇŸÖ ÿßŸÑŸÄ part 'n' (${part.n}) ŸÑÿß Ÿäÿ∑ÿßÿ®ŸÇ ŸÖŸàÿ∂ÿπŸá (${partNum}).` :
                                `Part ${partNum}: Part number 'n' (${part.n}) does not match its position (${partNum}).`;
                        }

                        // Validate stem (if present)
                        if (part.stem !== undefined && (typeof part.stem !== 'string' || part.stem.trim() === '')) {
                            return this.language === this.Language.ARABIC ?
                                `Part ${partNum}: ÿ≠ŸÇŸÑ stem Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                `Part ${partNum}: 'stem' must be a non-empty string.`;
                        }

                        // Validate standalone (if present)
                        if (part.standalone !== undefined && typeof part.standalone !== 'boolean') {
                            return this.language === this.Language.ARABIC ?
                                `Part ${partNum}: ÿ≠ŸÇŸÑ standalone Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ boolean.` :
                                `Part ${partNum}: 'standalone' must be a boolean.`;
                        }

                        // Validate subtype (if present)
                        if (part.subtype !== undefined && part.subtype !== null) {
                            return this.language === this.Language.ARABIC ?
                                `Part ${partNum}: ÿ≠ŸÇŸÑ subtype Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ null.` :
                                `Part ${partNum}: 'subtype' must be null.`;
                        }

                        // Check if type is valid
                        if (!part.type || part.type === this.QuestionType.UNKNOWN || !validTypes.includes(part.type)) {
                            const validTypesStr = validTypes.join(', ');
                            return this.language === this.Language.ARABIC
                                ? `Part ${partNum}: ŸÜŸàÿπ ÿßŸÑÿ≥ÿ§ÿßŸÑ "${part.type}" ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠. ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ÿ®Ÿáÿß: ${validTypesStr}`
                                : `Part ${partNum}: Invalid question type "${part.type}". Valid types: ${validTypesStr}`;
                        }

                        // ===== MCQ Validation =====
                        if (part.type === this.QuestionType.MCQ) {
                            if (!part.choices || !Array.isArray(part.choices) || part.choices.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (mcq): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (mcq): 'choices' must be a non-empty array.`;
                            }

                            // Validate choice structure (if choices are objects with type/html_content)
                            const hasChoiceStructure = part.choices.length > 0 && typeof part.choices[0] === 'object' && part.choices[0].type;
                            if (hasChoiceStructure) {
                                const keyChoices = part.choices.filter(c => c.type === 'key');
                                if (keyChoices.length !== 1) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (mcq): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ choice Ÿàÿßÿ≠ÿØ ŸÖŸÜ ŸÜŸàÿπ "key"ÿå ŸàŸèÿ¨ÿØ ${keyChoices.length}.` :
                                        `Part ${partNum} (mcq): Must have exactly 1 key choice, found ${keyChoices.length}.`;
                                }

                                // Validate each choice
                                for (let i = 0; i < part.choices.length; i++) {
                                    const choice = part.choices[i];
                                    const choiceError = this.validateChoice(choice, partNum, i + 1);
                                    if (choiceError) return choiceError;
                                }
                            } else {
                                // Simple string choices validation
                                if (part.choices.length < 2) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ.`
                                        : `Part ${partNum}: Must have at least 2 choices.`;
                                }

                                // Check for empty choices
                                const emptyChoices = part.choices.filter(c => !c || c.trim() === '');
                                if (emptyChoices.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÅÿßÿ±ÿ∫ÿ©.`
                                        : `Part ${partNum}: Contains empty choices.`;
                                }

                                // Check for duplicate choices
                                const trimmedChoices = part.choices.map(c => c.trim().toLowerCase());
                                const duplicates = trimmedChoices.filter((item, index) => trimmedChoices.indexOf(item) !== index);
                                if (duplicates.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ©.`
                                        : `Part ${partNum}: Contains duplicate choices.`;
                                }
                            }

                            if (!Array.isArray(part.answer) && part.answer === undefined) {
                                return `Part ${partNum}: ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ŸÖÿ™ÿπÿØÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ© (*).`;
                            }
                            // Check answer is within range
                            if (part.choices && part.answer !== undefined && (part.answer < 0 || part.answer >= part.choices.length)) {
                                return this.language === this.Language.ARABIC
                                    ? `Part ${partNum}: ÿ±ŸÇŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠.`
                                    : `Part ${partNum}: Answer index out of range.`;
                            }
                        }

                        // ===== MRQ Validation =====
                        if (part.type === this.QuestionType.MRQ) {
                            if (!part.choices || !Array.isArray(part.choices) || part.choices.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (mrq): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (mrq): 'choices' must be a non-empty array.`;
                            }

                            // Validate choice structure
                            const hasChoiceStructure = part.choices.length > 0 && typeof part.choices[0] === 'object' && part.choices[0].type;
                            if (hasChoiceStructure) {
                                const keyChoices = part.choices.filter(c => c.type === 'key');
                                if (keyChoices.length < 2) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (mrq): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ 2 choices ŸÖŸÜ ŸÜŸàÿπ "key" ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑÿå ŸàŸèÿ¨ÿØ ${keyChoices.length}.` :
                                        `Part ${partNum} (mrq): Must have at least 2 key choices, found ${keyChoices.length}.`;
                                }

                                // Validate each choice
                                for (let i = 0; i < part.choices.length; i++) {
                                    const choice = part.choices[i];
                                    const choiceError = this.validateChoice(choice, partNum, i + 1);
                                    if (choiceError) return choiceError;
                                }
                            } else {
                                // Simple validation for string choices
                                if (part.choices.length < 2) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ±ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ.`
                                        : `Part ${partNum}: Must have at least 2 choices.`;
                                }
                            }

                            // Check has at least one answer
                            if (!Array.isArray(part.answer) || part.answer.length === 0) {
                                return this.language === this.Language.ARABIC
                                    ? `Part ${partNum}: Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ (*).`
                                    : `Part ${partNum}: Must have at least one correct answer.`;
                            }
                            // Check has more than one correct answer
                            if (part.answer.length === 1) {
                                return this.language === this.Language.ARABIC
                                    ? `Part ${partNum}: Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÅŸÇÿ∑. ŸäŸÅÿ∂ŸÑ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ MCQ ÿ®ÿØŸÑÿßŸã ŸÖŸÜŸá.`
                                    : `Part ${partNum}: Has only one correct answer. Consider using MCQ instead.`;
                            }
                            // Check answer indices are within range
                            if (part.choices) {
                                const invalidIndices = part.answer.filter(idx => idx < 0 || idx >= part.choices.length);
                                if (invalidIndices.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: ÿ®ÿπÿ∂ ÿ£ÿ±ŸÇÿßŸÖ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠.`
                                        : `Part ${partNum}: Some answer indices out of range.`;
                                }
                            }
                        }

                        // ===== OQ (Ordering) Validation =====
                        if (part.type === this.QuestionType.OQ) {
                            if (!part.choices || !Array.isArray(part.choices) || part.choices.length < 2) {
                                return this.language === this.Language.ARABIC
                                    ? `Part ${partNum} (oq): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿπŸÜÿµÿ±ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÑÿ™ÿ±ÿ™Ÿäÿ®.`
                                    : `Part ${partNum} (oq): Must have at least 2 items to order.`;
                            }

                            // Validate all choices are "distractor" type
                            const hasChoiceStructure = part.choices.length > 0 && typeof part.choices[0] === 'object' && part.choices[0].type;
                            if (hasChoiceStructure) {
                                const nonDistractorChoices = part.choices.filter(c => c.type !== 'distractor');
                                if (nonDistractorChoices.length > 0) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (oq): ŸÉŸÑ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖŸÜ ŸÜŸàÿπ "distractor".` :
                                        `Part ${partNum} (oq): All choices must have type "distractor".`;
                                }

                                // Validate each choice
                                for (let i = 0; i < part.choices.length; i++) {
                                    const choice = part.choices[i];
                                    const choiceError = this.validateChoice(choice, partNum, i + 1);
                                    if (choiceError) return choiceError;
                                }
                            }

                            // Validate direction
                            if (part.direction && !['vertical', 'horizontal'].includes(part.direction)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (oq): direction Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ "vertical" ÿ£Ÿà "horizontal".` :
                                    `Part ${partNum} (oq): 'direction' must be "vertical" or "horizontal".`;
                            }
                        }

                        // ===== GMRQ Validation =====
                        if (part.type === this.QuestionType.GMRQ) {
                            if (!part.choices || !Array.isArray(part.choices) || part.choices.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (gmrq): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (gmrq): 'choices' must be a non-empty array.`;
                            }

                            // Count groups (assuming choices have a 'group' property)
                            const groups = {};
                            part.choices.forEach(c => {
                                const group = c.group || 1;
                                if (!groups[group]) groups[group] = [];
                                groups[group].push(c);
                            });

                            const groupCount = Object.keys(groups).length;
                            if (groupCount !== 2) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (gmrq): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ™ŸäŸÜ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ÿå ŸàŸèÿ¨ÿØ ${groupCount}.` :
                                    `Part ${partNum} (gmrq): Must have exactly 2 groups, found ${groupCount}.`;
                            }

                            // Validate each group has exactly 1 key choice
                            for (const [groupNum, groupChoices] of Object.entries(groups)) {
                                const keyChoices = groupChoices.filter(c => c.type === 'key');
                                if (keyChoices.length !== 1) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (gmrq): ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿ© ${groupNum} Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ choice Ÿàÿßÿ≠ÿØ ŸÖŸÜ ŸÜŸàÿπ "key"ÿå ŸàŸèÿ¨ÿØ ${keyChoices.length}.` :
                                        `Part ${partNum} (gmrq): Group ${groupNum} must have exactly 1 key choice, found ${keyChoices.length}.`;
                                }
                            }
                        }

                        // ===== Opinion Validation =====
                        if (part.type === this.QuestionType.OPINION) {
                            if (!part.choices || !Array.isArray(part.choices) || part.choices.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (opinion): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (opinion): 'choices' must be a non-empty array.`;
                            }

                            // Validate all choices are "distractor" type
                            const hasChoiceStructure = part.choices.length > 0 && typeof part.choices[0] === 'object' && part.choices[0].type;
                            if (hasChoiceStructure) {
                                const nonDistractorChoices = part.choices.filter(c => c.type !== 'distractor');
                                if (nonDistractorChoices.length > 0) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (opinion): ŸÉŸÑ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖŸÜ ŸÜŸàÿπ "distractor".` :
                                        `Part ${partNum} (opinion): All choices must have type "distractor".`;
                                }
                            }
                        }

                        // ===== MATCHING Validation =====
                        if (part.type === this.QuestionType.MATCHING) {
                            if (!part.pairs || part.pairs.some(p => p.length !== 2)) {
                                return `Part ${partNum}: ŸÉŸÑ ÿ≥ÿ∑ÿ± ŸÅŸä ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ŸàÿµŸäŸÑ Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿπŸÜÿµÿ±ŸäŸÜ ŸäŸÅÿµŸÑ ÿ®ŸäŸÜŸáŸÖÿß "|".`;
                            }

                            // Check for duplicate items on left side
                            if (part.pairs) {
                                const leftItems = part.pairs.map(pair => pair[0].trim().toLowerCase());
                                const duplicateLeft = leftItems.filter((item, index) => leftItems.indexOf(item) !== index);
                                if (duplicateLeft.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: ÿπŸÜÿßÿµÿ± ŸÖŸÉÿ±ÿ±ÿ© ŸÅŸä ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£Ÿäÿ≥ÿ±.`
                                        : `Part ${partNum}: Duplicate items on left side.`;
                                }

                                // Check for duplicate items on right side
                                const rightItems = part.pairs.map(pair => pair[1].trim().toLowerCase());
                                const duplicateRight = rightItems.filter((item, index) => rightItems.indexOf(item) !== index);
                                if (duplicateRight.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: ÿπŸÜÿßÿµÿ± ŸÖŸÉÿ±ÿ±ÿ© ŸÅŸä ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ŸäŸÖŸÜ.`
                                        : `Part ${partNum}: Duplicate items on right side.`;
                                }

                                // Check for duplicate pairs
                                const pairStrings = part.pairs.map(pair => `${pair[0].trim().toLowerCase()}|${pair[1].trim().toLowerCase()}`);
                                const duplicatePairs = pairStrings.filter((item, index) => pairStrings.indexOf(item) !== index);
                                if (duplicatePairs.length > 0) {
                                    return this.language === this.Language.ARABIC
                                        ? `Part ${partNum}: ÿ£ÿ≤Ÿàÿßÿ¨ ŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ© ÿ™ŸÖÿßŸÖÿßŸã.`
                                        : `Part ${partNum}: Duplicate pairs found.`;
                                }
                            }

                            // Validate choices structure if present
                            if (part.choices && Array.isArray(part.choices)) {
                                const hasChoiceStructure = part.choices.length > 0 && typeof part.choices[0] === 'object' && part.choices[0].type;
                                if (hasChoiceStructure) {
                                    // Count groups
                                    const groups = {};
                                    part.choices.forEach(c => {
                                        const group = c.group || 1;
                                        if (!groups[group]) groups[group] = [];
                                        groups[group].push(c);
                                    });

                                    const groupCount = Object.keys(groups).length;
                                    if (groupCount !== 2) {
                                        return this.language === this.Language.ARABIC ?
                                            `Part ${partNum} (matching): Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖÿ¨ŸÖŸàÿπÿ™ŸäŸÜ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑ÿå ŸàŸèÿ¨ÿØ ${groupCount}.` :
                                            `Part ${partNum} (matching): Must have exactly 2 groups, found ${groupCount}.`;
                                    }

                                    // Validate all are distractor
                                    const nonDistractorChoices = part.choices.filter(c => c.type !== 'distractor');
                                    if (nonDistractorChoices.length > 0) {
                                        return this.language === this.Language.ARABIC ?
                                            `Part ${partNum} (matching): ŸÉŸÑ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖŸÜ ŸÜŸàÿπ "distractor".` :
                                            `Part ${partNum} (matching): All choices must have type "distractor".`;
                                    }
                                }
                            }
                        }


                        // ===== GAP_TEXT Validation =====
                        if (part.type === this.QuestionType.GAP_TEXT) {
                            if (part.choices && (!Array.isArray(part.choices) || part.choices.length > 0)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (gapText): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (gapText): 'choices' must be an empty array.`;
                            }

                            // Check @BLANK exists
                            if (!part.stem || !part.stem.includes('@BLANK')) {
                                return this.language === this.Language.ARABIC
                                    ? `Part ${partNum} (gapText): @BLANK ŸÖŸÅŸÇŸàÿØ ŸÅŸä ŸÜÿµ ÿßŸÑÿ≥ÿ§ÿßŸÑ.`
                                    : `Part ${partNum} (gapText): Missing @BLANK in stem.`;
                            }

                            // Validate answers (which will become gap_text_keys)
                            if (!part.answers || !Array.isArray(part.answers) || part.answers.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (gapText): answers Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (gapText): 'answers' must be a non-empty array.`;
                            }

                            // Validate each answer
                            for (let i = 0; i < part.answers.length; i++) {
                                const answer = part.answers[i];
                                if (!answer.value) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (gapText): answer ŸÅŸä ÿßŸÑŸÖŸàÿ∂ÿπ ${i + 1} Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿÆÿßÿµŸäÿ© value.` :
                                        `Part ${partNum} (gapText): answer at index ${i + 1} must have a 'value' property.`;
                                }

                                if (answer.order !== undefined && (typeof answer.order !== 'number' || answer.order <= 0)) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (gapText): order ŸÅŸä ÿßŸÑŸÖŸàÿ∂ÿπ ${i + 1} Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ŸÖŸàÿ¨ÿ®.` :
                                        `Part ${partNum} (gapText): 'order' at index ${i + 1} must be a positive number.`;
                                }
                            }
                        }

                        // ===== STRING Validation =====
                        if (part.type === this.QuestionType.STRING) {
                            if (part.choices !== null && part.choices !== undefined) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (string): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ null.` :
                                    `Part ${partNum} (string): 'choices' must be null.`;
                            }

                            // For STRING questions, answer should be a string during parsing stage
                            if (part.answer && typeof part.answer !== 'string') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (string): answer Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string.` :
                                    `Part ${partNum} (string): 'answer' must be a string.`;
                            }

                            if (part.answer) {
                                // Check for HTML tags
                                if (/<[^>]+>/.test(part.answer)) {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (string): answer ŸÑÿß Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ HTML.` :
                                        `Part ${partNum} (string): answer must not contain HTML.`;
                                }
                            }

                            // Validate guidelines - REQUIRED for STRING questions
                            if (!part.guidelines || !Array.isArray(part.guidelines) || part.guidelines.length === 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (string): ÿßŸÑÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÜÿµ ÿßŸÑŸÇÿµŸäÿ±. ÿ£ÿ∂ŸÅ @GUIDELINES ŸÖÿπ ÿ£ŸÖÿ´ŸÑÿ© ÿπŸÑŸâ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ŸàÿßŸÑÿØÿ±ÿ¨ÿßÿ™.` :
                                    `Part ${partNum} (string): Guidelines are required for String questions. Add @GUIDELINES with examples of answers and marks.`;
                            }

                            const invalidGuidelines = part.guidelines.filter(g =>
                                !g.student_answer || !g.mark || !g.comment ||
                                (isNaN(g.mark) && g.mark !== '0' && g.mark !== '1')
                            );

                            if (invalidGuidelines.length > 0) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (string): ÿ®ÿπÿ∂ ÿßŸÑÿ•ÿ±ÿ¥ÿßÿØÿßÿ™ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©. ŸÉŸÑ ÿ•ÿ±ÿ¥ÿßÿØ Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿ∑ÿßŸÑÿ® ŸàÿßŸÑÿØÿ±ÿ¨ÿ© ŸàÿßŸÑÿ™ÿπŸÑŸäŸÇ.` :
                                    `Part ${partNum} (string): Some guidelines are incomplete. Each guideline must have student answer, mark, and comment.`;
                            }
                        }

                        // ===== COUNTING Validation =====
                        if (part.type === this.QuestionType.COUNTING) {
                            if (part.choices && (!Array.isArray(part.choices) || part.choices.length > 0)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (counting): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (counting): 'choices' must be an empty array.`;
                            }

                            if (!part.answer || typeof part.answer !== 'string' || isNaN(part.answer)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (counting): ÿ≠ŸÇŸÑ answer Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ŸäŸÖÿ´ŸÑ ÿ±ŸÇŸÖ.` :
                                    `Part ${partNum} (counting): 'answer' field must be a string representing a number.`;
                            }

                            if (part.grid_size && !/^\d+√ó\d+$/.test(part.grid_size)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (counting): grid_size Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ®ÿµŸäÿ∫ÿ© 'rows√ócolumns' (ŸÖÿ´ŸÑ: 3√ó4).` :
                                    `Part ${partNum} (counting): 'grid_size' must be in format 'rows√ócolumns' (e.g., 3√ó4).`;
                            }
                        }

                        // ===== PUZZLE Validation =====
                        if (part.type === this.QuestionType.PUZZLE) {
                            if (part.choices && (!Array.isArray(part.choices) || part.choices.length > 0)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (puzzle): 'choices' must be an empty array.`;
                            }

                            // Validate puzzle dimensions
                            if (!part.puzzleColumns || typeof part.puzzleColumns !== 'string' || isNaN(part.puzzleColumns)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleColumns Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ŸäŸÖÿ´ŸÑ ÿ±ŸÇŸÖ.` :
                                    `Part ${partNum} (puzzle): 'puzzleColumns' must be a string representing a number.`;
                            }

                            if (!part.puzzleRows || typeof part.puzzleRows !== 'string' || isNaN(part.puzzleRows)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleRows Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ŸäŸÖÿ´ŸÑ ÿ±ŸÇŸÖ.` :
                                    `Part ${partNum} (puzzle): 'puzzleRows' must be a string representing a number.`;
                            }

                            // Validate puzzle image
                            if (!part.puzzleImage || typeof part.puzzleImage !== 'string') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleImage Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string URL.` :
                                    `Part ${partNum} (puzzle): 'puzzleImage' must be a string URL.`;
                            }

                            if (!part.puzzleImageHeight || typeof part.puzzleImageHeight !== 'string' || isNaN(part.puzzleImageHeight)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleImageHeight Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ŸäŸÖÿ´ŸÑ ÿ±ŸÇŸÖ.` :
                                    `Part ${partNum} (puzzle): 'puzzleImageHeight' must be a string representing a number.`;
                            }

                            if (!part.puzzleImageWidth || typeof part.puzzleImageWidth !== 'string' || isNaN(part.puzzleImageWidth)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleImageWidth Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ŸäŸÖÿ´ŸÑ ÿ±ŸÇŸÖ.` :
                                    `Part ${partNum} (puzzle): 'puzzleImageWidth' must be a string representing a number.`;
                            }

                            // Validate puzzle pieces
                            if (!part.puzzleImageSplited || !Array.isArray(part.puzzleImageSplited)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): puzzleImageSplited Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (puzzle): 'puzzleImageSplited' must be a non-empty array.`;
                            }

                            const expectedPieces = parseInt(part.puzzleRows) * parseInt(part.puzzleColumns);
                            if (part.puzzleImageSplited.length !== expectedPieces) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (puzzle): ŸÖÿ™ŸàŸÇÿπ ${expectedPieces} ŸÇÿ∑ÿπÿ© ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿµŸÅŸàŸÅ ŸàÿßŸÑÿ£ÿπŸÖÿØÿ©ÿå ŸÑŸÉŸÜ ŸàŸèÿ¨ÿØ ${part.puzzleImageSplited.length}.` :
                                    `Part ${partNum} (puzzle): Expected ${expectedPieces} image pieces based on rows and columns, but found ${part.puzzleImageSplited.length}.`;
                            }

                            // Validate each puzzle piece
                            for (let i = 0; i < part.puzzleImageSplited.length; i++) {
                                const piece = part.puzzleImageSplited[i];
                                if (piece.index === undefined || typeof piece.index !== 'number') {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (puzzle): ÿßŸÑŸÇÿ∑ÿπÿ© ${i + 1} ŸÖŸÅŸÇŸàÿØÿ© ÿ£Ÿà ŸÑÿØŸäŸáÿß index ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.` :
                                        `Part ${partNum} (puzzle): Piece at index ${i + 1} is missing or has invalid 'index'.`;
                                }

                                if (piece.fixed_order === undefined || typeof piece.fixed_order !== 'number') {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (puzzle): ÿßŸÑŸÇÿ∑ÿπÿ© ${i + 1} ŸÖŸÅŸÇŸàÿØÿ© ÿ£Ÿà ŸÑÿØŸäŸáÿß fixed_order ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.` :
                                        `Part ${partNum} (puzzle): Piece at index ${i + 1} is missing or has invalid 'fixed_order'.`;
                                }

                                if (piece.correct_order === undefined || typeof piece.correct_order !== 'number') {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (puzzle): ÿßŸÑŸÇÿ∑ÿπÿ© ${i + 1} ŸÖŸÅŸÇŸàÿØÿ© ÿ£Ÿà ŸÑÿØŸäŸáÿß correct_order ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.` :
                                        `Part ${partNum} (puzzle): Piece at index ${i + 1} is missing or has invalid 'correct_order'.`;
                                }

                                if (!piece.src || typeof piece.src !== 'string') {
                                    return this.language === this.Language.ARABIC ?
                                        `Part ${partNum} (puzzle): ÿßŸÑŸÇÿ∑ÿπÿ© ${i + 1} ŸÖŸÅŸÇŸàÿØÿ© ÿ£Ÿà ŸÑÿØŸäŸáÿß src ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.` :
                                        `Part ${partNum} (puzzle): Piece at index ${i + 1} is missing or has invalid 'src'.`;
                                }
                            }
                        }

                        // ===== INPUT_BOX Validation =====
                        if (part.type === this.QuestionType.INPUT_BOX) {
                            if (part.choices && (!Array.isArray(part.choices) || part.choices.length > 0)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (input_box): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (input_box): 'choices' must be an empty array.`;
                            }

                            if (!part.answer || typeof part.answer !== 'object') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (input_box): ÿ≠ŸÇŸÑ answer Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ object.` :
                                    `Part ${partNum} (input_box): 'answer' field must be an object.`;
                            }

                            if (typeof part.answer.value !== 'string') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (input_box): answer.value Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string.` :
                                    `Part ${partNum} (input_box): 'answer.value' must be a string.`;
                            }

                            // For INPUT_BOX questions, constrains is added during transform stage
                            // So we don't validate it during parsing stage

                            if (part.answer.unit !== undefined && typeof part.answer.unit !== 'string') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (input_box): answer.unit Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ÿ£Ÿà undefined.` :
                                    `Part ${partNum} (input_box): 'answer.unit' must be a string or undefined.`;
                            }
                        }

                        // ===== FRQ_AI Validation =====
                        if (part.type === this.QuestionType.FRQ_AI) {
                            if (part.choices && (!Array.isArray(part.choices) || part.choices.length > 0)) {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (frq_ai): choices Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array ŸÅÿßÿ±ÿ∫.` :
                                    `Part ${partNum} (frq_ai): 'choices' must be an empty array.`;
                            }

                            if (!part.answer || typeof part.answer !== 'string') {
                                return this.language === this.Language.ARABIC ?
                                    `Part ${partNum} (frq_ai): ÿ≠ŸÇŸÑ answer ŸÖÿ∑ŸÑŸàÿ® ŸàŸäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string.` :
                                    `Part ${partNum} (frq_ai): 'answer' field is required and must be a string.`;
                            }

                            // For FRQ_AI questions, ai field is added during transform stage
                            // So we don't validate it during parsing stage
                        }
                    }

                    return null; // No validation errors
                }

                // Helper function to validate choice structure
                validateChoice(choice, partNum, choiceNum) {
                    const requiredFields = ['type', 'html_content', 'values', 'unit', 'index', 'fixed_order', 'last_order'];

                    for (const field of requiredFields) {
                        if (choice[field] === undefined) {
                            return this.language === this.Language.ARABIC ?
                                `Part ${partNum}, Choice ${choiceNum}: ÿ≠ŸÇŸÑ "${field}" ŸÖŸÅŸÇŸàÿØ.` :
                                `Part ${partNum}, Choice ${choiceNum}: Missing required field "${field}".`;
                        }
                    }

                    // Validate type
                    if (!['key', 'distractor'].includes(choice.type)) {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: ŸÜŸàÿπ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± "${choice.type}" ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ "key" ÿ£Ÿà "distractor".` :
                            `Part ${partNum}, Choice ${choiceNum}: Invalid choice type "${choice.type}". Must be "key" or "distractor".`;
                    }

                    // Validate html_content
                    if (typeof choice.html_content !== 'string' || choice.html_content.trim() === '') {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: html_content Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ string ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'html_content' must be a non-empty string.`;
                    }

                    // Validate values
                    if (!Array.isArray(choice.values)) {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: values Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ array.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'values' must be an array.`;
                    }

                    // Validate unit
                    if (choice.unit !== null && typeof choice.unit !== 'string') {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: unit Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ null ÿ£Ÿà string.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'unit' must be null or a string.`;
                    }

                    // Validate index
                    if (typeof choice.index !== 'number' || choice.index < 0) {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: index Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ÿ∫Ÿäÿ± ÿ≥ÿßŸÑÿ®.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'index' must be a non-negative number.`;
                    }

                    // Validate fixed_order
                    if (typeof choice.fixed_order !== 'number' || choice.fixed_order <= 0) {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: fixed_order Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿ±ŸÇŸÖ ŸÖŸàÿ¨ÿ®.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'fixed_order' must be a positive number.`;
                    }

                    // Validate last_order
                    if (typeof choice.last_order !== 'boolean') {
                        return this.language === this.Language.ARABIC ?
                            `Part ${partNum}, Choice ${choiceNum}: last_order Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ boolean.` :
                            `Part ${partNum}, Choice ${choiceNum}: 'last_order' must be a boolean.`;
                    }

                    return null; // No errors
                }

                autoSaveContent() {
                    const content = this.getInputText();
                    localStorage.setItem('aiq_autosave_content', content);
                    this.logger.info('Content auto-saved.');
                }

                loadAutoSavedContent() {
                    const savedContent = localStorage.getItem('aiq_autosave_content');
                    if (savedContent) {
                        this.setInputText(savedContent);
                        this.showMessage('ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.', 'success');
                        this.runLiveValidation();
                    }
                }

                handleChoiceClick(element) {
                    const questionId = element.dataset.questionId;
                    const choiceIndex = parseInt(element.dataset.choiceIndex, 10);
                    const partIndex = parseInt(element.closest('.part-preview').dataset.partIndex, 10);

                    const question = this.questions.find(q => q.metadata.id === questionId);
                    if (!question || !question.parts[partIndex]) return;

                    const part = question.parts[partIndex];

                    if (part.type === this.QuestionType.MCQ) {
                        part.answer = choiceIndex;
                    } else if (part.type === this.QuestionType.MRQ) {
                        if (!Array.isArray(part.answer)) part.answer = [];
                        const answerIndex = part.answer.indexOf(choiceIndex);
                        if (answerIndex > -1) {
                            part.answer.splice(answerIndex, 1);
                        } else {
                            part.answer.push(choiceIndex);
                        }
                    }

                    this._regenerateQuestionContent(question);
                    this.updateTextareaFromQuestions();
                    this.updateUIAfterChange();
                }

                _regenerateQuestionContent(question) {
                    let newContentBlock = '';
                    if (question.statement) {
                        newContentBlock += `@STATEMENT\n${question.statement}\n`;
                    }

                    question.parts.forEach(part => {
                        if (question.statement) {
                            newContentBlock += `@PART\n`;
                            // Add type only for multi-part questions
                            newContentBlock += `type: ${part.type}\n`;
                        }
                        // For single-part questions, type is already in _metaHeader, so don't add it here
                        newContentBlock += `@STEM\n${part.stem}\n`;

                        if (part.type === 'mcq' || part.type === 'mrq' || part.type === 'oq') {
                            newContentBlock += `@CHOICES\n`;
                            const correctAnswers = new Set(Array.isArray(part.answer) ? part.answer : [part.answer]);
                            part.choices.forEach((choice, i) => {
                                const prefix = correctAnswers.has(i) ? '* ' : '- ';
                                newContentBlock += `${prefix}${choice}\n`;
                            });
                        } else if (part.type === 'string') {
                            newContentBlock += `@ANSWER\n${part.answer}\n`;

                            // Add guidelines if present
                            if (part.guidelines && Array.isArray(part.guidelines) && part.guidelines.length > 0) {
                                newContentBlock += `\n@GUIDELINES\n`;
                                part.guidelines.forEach(guideline => {
                                    // Use the new simplified format
                                    newContentBlock += `${guideline.student_answer} - ${guideline.mark} - ${guideline.comment}\n`;
                                });
                            }
                        } else if (part.type === 'frq' || part.type === 'frq_ai') {
                            newContentBlock += `@ANSWER\n${part.answer}\n`;

                            // Add task_target and overall_task_instructions if present
                            if (part.metadata?.task_target) {
                                newContentBlock += `\n@TASK_TARGET\n${part.metadata.task_target}\n`;
                            }
                            if (part.metadata?.overall_task_instructions) {
                                newContentBlock += `\n@OVERALL_TASK_INSTRUCTIONS\n${part.metadata.overall_task_instructions}\n`;
                            }
                        }
                        // Add other types here if needed
                    });
                    question._contentBlock = newContentBlock.trim();
                }

                updateTextareaFromQuestions() {
                    const fullText = this.questions.map(q => {
                        return (q._metaHeader + q._contentBlock).trim();
                    }).join('\n---\n');
                    this.setInputText(fullText);
                    this.autoSaveContent(); // Save changes after programmatic update
                }

                syntaxHighlight(json) {
                    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return json.replace(
                        /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
                        (match) => {
                            let cls = 'number';
                            if (/^"/.test(match)) {
                                cls = /:$/.test(match) ? 'key' : 'string';
                            } else if (/true|false/.test(match)) {
                                cls = 'boolean';
                            } else if (/null/.test(match)) {
                                cls = 'null';
                            }
                            return '<span class="' + cls + '">' + match + '</span>';
                        }
                    );
                }

                // =================================================================
                // NEW AND REFACTORED AI & MODAL METHODS
                // =================================================================

                _getApiKey() {
                    return this.aiProvider === 'gemini'
                        ? document.getElementById('geminiApiKey').value.trim()
                        : document.getElementById('openaiApiKey').value.trim();
                }

                setAIProvider(provider) {
                    this.aiProvider = provider;
                    this._updateApiProviderUI();
                }

                _updateApiProviderUI() {
                    document.getElementById('gemini-key-container').style.display = this.aiProvider === 'gemini' ? 'block' : 'none';
                    document.getElementById('openai-key-container').style.display = this.aiProvider === 'openai' ? 'block' : 'none';
                }

                populateGenerationModal() {
                    const container = document.getElementById('gen-q-types-container');
                    if (!container) {
                        this.logger.error("Generation modal container #gen-q-types-container not found.");
                        return;
                    }
                    container.innerHTML = ''; // Clear existing content

                    if (!this.questionTypeConfigs) {
                        this.logger.error("Question type configs not available for generation modal.");
                        return;
                    }

                    const orderedTypes = [
                        this.QuestionType.MCQ,
                        this.QuestionType.MRQ,
                        this.QuestionType.MATCHING,
                        this.QuestionType.OQ,          // <-- ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™Ÿá
                        this.QuestionType.GAP_TEXT,
                        this.QuestionType.INPUT_BOX,  // <-- ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™Ÿá
                        this.QuestionType.STRING,
                        this.QuestionType.FRQ_AI      // <-- ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ™Ÿá
                    ];

                    for (const typeKey of orderedTypes) {
                        if (!this.questionTypeConfigs[typeKey]) continue;

                        const config = this.questionTypeConfigs[typeKey];
                        const row = document.createElement('div');
                        row.className = 'gen-q-type-row';

                        const label = document.createElement('label');
                        label.htmlFor = `gen-q-count-${typeKey}`;
                        label.textContent = config.label;

                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = `gen-q-count-${typeKey}`;
                        input.min = '0';
                        input.value = (typeKey === this.QuestionType.MCQ) ? '5' : '0';
                        input.dataset.type = typeKey;

                        row.appendChild(label);
                        row.appendChild(input);
                        container.appendChild(row);
                    }
                }

                openGenerationModal() {
                    this._lastFocus = document.activeElement;
                    document.getElementById('generationModalBg').style.display = 'flex';
                    setTimeout(() => { document.getElementById('gen-text-input')?.focus(); }, 0);
                }

                closeGenerationModal() {
                    document.getElementById('generationModalBg').style.display = 'none';
                    // Reset fields
                    document.getElementById('gen-text-input').value = '';
                    document.getElementById('gen-custom-prompt').value = '';
                    document.getElementById('gen-image-preview').style.display = 'none';
                    document.getElementById('gen-image-preview').src = '';
                    this.uploadedImageBase64 = null;
                    if (this._lastFocus && typeof this._lastFocus.focus === 'function') { this._lastFocus.focus(); }
                }

                setupImageDropZone() {
                    const dropZone = document.getElementById('gen-image-drop-zone');
                    const fileInput = document.getElementById('gen-image-input');
                    const imagePreview = document.getElementById('gen-image-preview');

                    const handleFile = (file) => {
                        if (file && file.type.startsWith('image/')) {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                imagePreview.src = e.target.result;
                                imagePreview.style.display = 'block';
                                this.uploadedImageBase64 = e.target.result.split(',')[1];
                            };
                            reader.readAsDataURL(file);
                        } else {
                            this.showMessage('Please drop an image file.', 'warning');
                        }
                    };

                    dropZone.addEventListener('click', () => fileInput.click());
                    fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

                    dropZone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        dropZone.classList.add('dragover');
                    });
                    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
                    dropZone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('dragover');
                        handleFile(e.dataTransfer.files[0]);
                    });
                }

                async generateQuestionsWithAI() {
                    const apiKey = this._getApiKey();
                    if (!apiKey) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÖŸÅÿ™ÿßÿ≠ API ÿ£ŸàŸÑÿßŸã' : 'Please enter an API key first', 'warning');
                        return;
                    }

                    const contextText = document.getElementById('gen-text-input').value.trim();
                    if (!contextText && !this.uploadedImageBase64) {
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ŸÜÿµ ÿ£Ÿà ÿ±ŸÅÿπ ÿµŸàÿ±ÿ©' : 'Please enter text or upload an image', 'warning');
                        return;
                    }

                    const generateBtn = document.getElementById('modal-generate-btn');
                    const originalText = generateBtn.innerHTML;
                    generateBtn.innerHTML = `<div class="spinner"></div> ${this.language === this.Language.ARABIC ? 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ŸàŸÑŸäÿØ...' : 'Generating...'}`;
                    generateBtn.disabled = true;

                    try {
                        const questionRequests = [];
                        document.querySelectorAll('#gen-q-types-container input').forEach(input => {
                            const count = parseInt(input.value, 10);
                            if (count > 0) {
                                questionRequests.push(`- ${count} ${input.dataset.type.toUpperCase()} questions`);
                            }
                        });

                        if (questionRequests.length === 0) {
                            this.showMessage(this.language === this.Language.ARABIC ? 'ÿßŸÑÿ±ÿ¨ÿßÿ° ÿ™ÿ≠ÿØŸäÿØ ÿπÿØÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ±ÿßÿØ ÿ™ŸàŸÑŸäÿØŸáÿß' : 'Please specify the number of questions to generate', 'warning');
                            return;
                        }

                        const customPrompt = document.getElementById('gen-custom-prompt').value.trim();

                        const languageInstruction = this.language === this.Language.ARABIC
                            ? 'Generate the questions in Arabic.'
                            : 'Generate the questions in English.';

                        let prompt = `Based on the following context, generate questions in the specified format.
**${languageInstruction}**

Context:
${contextText}

Generate exactly these questions:
${questionRequests.join('\n')}

${customPrompt ? `Additional Instructions: ${customPrompt}` : ''}

**Mathematics Rules (Crucial and must be followed precisely):**
- Wrap inline math like $x^2$ with single backticks: \`x^2\`.
- Wrap display math like $$...$$ or LaTeX environments like \\begin{...} with double backticks: \`\`...\`\`.
- **Never** generate math with '$' delimiters. Always use backticks.

Strictly follow this formatting for each question:
- Start with 'type: [question_type]'.
- Use @STEM for the question text.
- Use @CHOICES for MCQ/MRQ options, with '*' for correct and '-' for incorrect answers.
- **For any list like @CHOICES or @GAPS, you MUST put each item on a new line.** // <<< ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±
- Use @ANSWER for string/frq answers.
- Use @MATCHING_PAIRS for matching questions, separated by '|'.
- Use @GAPS for gap-fill answers.
- Separate each complete question block with '---'.
`;

                        const aiResponse = await this._callAI(prompt, apiKey, this.uploadedImageBase64);
                        const formattedQuestions = this.postProcessAIFormatted(aiResponse);

                        const currentValue = getQuestionInputValue();
                        const separator = currentValue.trim() ? '\n---\n' : '';
                        setQuestionInputValue(currentValue + separator + formattedQuestions);

                        this.closeGenerationModal();
                        this.showMessage(this.language === this.Language.ARABIC ? 'ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠!' : 'Questions generated successfully!', 'success');
                        await this.smartAnalyze();

                    } catch (error) {
                        this.logger.error('AI Question Generation Error:', error);
                        this.showMessage(`${this.language === this.Language.ARABIC ? 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸàŸÑŸäÿØ: ' : 'Generation error: '}${error.message}`, 'error');
                    } finally {
                        generateBtn.innerHTML = originalText;
                        generateBtn.disabled = false;
                    }
                }

                async _callAI(prompt, apiKey, imageBase64 = null) {
                    this.aiAbortController?.abort();
                    this.aiAbortController = new AbortController();
                    const timer = setTimeout(() => this.aiAbortController.abort(), 60000); // 60s timeout

                    try {
                        let endpoint, options;

                        if (this.aiProvider === 'gemini') {
                            endpoint = this.config.api.geminiEndpoint + encodeURIComponent(apiKey);
                            const parts = [{ text: prompt }];
                            if (imageBase64) {
                                parts.push({ inline_data: { mime_type: 'image/jpeg', data: imageBase64 } });
                            }
                            options = {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    contents: [{ role: 'user', parts: parts }],
                                    generationConfig: { temperature: 0.3, topK: 40, topP: 0.95, maxOutputTokens: 8192 }
                                }),
                                signal: this.aiAbortController.signal
                            };
                        } else { // openai
                            endpoint = this.config.api.openaiEndpoint;
                            const content = [{ type: 'text', text: prompt }];
                            if (imageBase64) {
                                content.push({ type: 'image_url', image_url: { url: `data:image/jpeg;base64,${imageBase64}` } });
                            }
                            options = {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify({
                                    model: imageBase64 ? "gpt-4o" : "gpt-4-turbo",
                                    messages: [{ role: 'user', content: content }],
                                    temperature: 0.3,
                                    max_tokens: 4096
                                }),
                                signal: this.aiAbortController.signal
                            };
                        }

                        const response = await fetch(endpoint, options);
                        clearTimeout(timer);

                        if (!response.ok) {
                            const txt = await response.text().catch(() => '');
                            throw new Error(`API Error ${response.status}: ${txt || response.statusText}`);
                        }

                        const data = await response.json();

                        if (this.aiProvider === 'gemini') {
                            if (data?.promptFeedback?.blockReason) {
                                throw new Error(`Blocked by safety: ${data.promptFeedback.blockReason}`);
                            }
                            return data?.candidates?.[0]?.content?.parts?.find(p => typeof p.text === 'string')?.text || '';
                        } else { // openai
                            return data?.choices?.[0]?.message?.content || '';
                        }

                    } catch (error) {
                        clearTimeout(timer);
                        this.logger.error('API call failed:', error);
                        throw error;
                    }
                }
            }
            const app = new AIQuestionConverter();
            window.app = app; // Make app globally accessible for RichTextManager
            app.init();
        });
    </script>

    <!-- Kashida Engine for Poetry -->
    <script>
        // Apply Kashida to all poems automatically
        function applyKashidaToPoems() {
            // Wait for KashidaEngine to be available
            if (typeof KashidaEngine === 'undefined' || typeof KashidaEngine.unifyTextsWidths !== 'function') {
                console.warn('‚ö†Ô∏è Kashida Engine not loaded yet');
                return;
            }

            // Find all poems that need kashida processing
            const poems = document.querySelectorAll('.Poem[data-kashida-pending="true"]');

            poems.forEach(poemElement => {
                try {
                    // Get all verses from the poem
                    const verseElements = poemElement.querySelectorAll('p');
                    if (verseElements.length === 0) return;

                    // Extract verse text
                    const verses = Array.from(verseElements).map(p => p.textContent.trim());

                    // Get the computed font from the poem element
                    const computedStyle = window.getComputedStyle(poemElement);
                    const font = computedStyle.font ||
                        `${computedStyle.fontStyle} ${computedStyle.fontWeight} ${computedStyle.fontSize}/${computedStyle.lineHeight} ${computedStyle.fontFamily}`;

                    // Apply kashida using KashidaEngine API
                    const processedVerses = KashidaEngine.unifyTextsWidths(verses, font);

                    // Update the verses with kashida
                    verseElements.forEach((p, index) => {
                        if (processedVerses[index]) {
                            p.textContent = processedVerses[index];
                        }
                    });

                    // Mark as processed
                    poemElement.removeAttribute('data-kashida-pending');
                    poemElement.setAttribute('data-kashida-applied', 'true');

                    console.log('‚úÖ Kashida applied to poem with', verseElements.length, 'verses');
                } catch (err) {
                    console.error('‚ùå Error applying kashida to poem:', err);
                }
            });
        }

        // Apply kashida when DOM changes (new questions loaded)
        const observer = new MutationObserver((mutations) => {
            let shouldApplyKashida = false;
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) { // Element node
                        if (node.classList && node.classList.contains('Poem')) {
                            shouldApplyKashida = true;
                        } else if (node.querySelector && node.querySelector('.Poem[data-kashida-pending="true"]')) {
                            shouldApplyKashida = true;
                        }
                    }
                });
            });
            if (shouldApplyKashida) {
                // Delay slightly to ensure styles are computed
                setTimeout(applyKashidaToPoems, 100);
            }
        });

        // Start observing the document for changes
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        // Also apply on window load
        window.addEventListener('load', () => {
            setTimeout(applyKashidaToPoems, 200);
        });
    </script>
</body>

</html>
